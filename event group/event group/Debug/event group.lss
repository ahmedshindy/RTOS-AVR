
event group.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000270e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000018  00800060  0000270e  000027a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000041e  00800078  00800078  000027ba  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  000027bc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e7  00000000  00000000  00002f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00002ff8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000334d  00000000  00000000  00003138  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b21  00000000  00000000  00006485  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000129a  00000000  00000000  00006fa6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b18  00000000  00000000  00008240  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000145f  00000000  00000000  00008d58  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003d88  00000000  00000000  0000a1b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000148  00000000  00000000  0000df3f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 3e 05 	jmp	0xa7c	; 0xa7c <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e0       	ldi	r30, 0x0E	; 14
      68:	f7 e2       	ldi	r31, 0x27	; 39
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a8 37       	cpi	r26, 0x78	; 120
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	a8 e7       	ldi	r26, 0x78	; 120
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 39       	cpi	r26, 0x96	; 150
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 89 00 	call	0x112	; 0x112 <main>
      8a:	0c 94 85 13 	jmp	0x270a	; 0x270a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <Task2>:

void Task2( void *pvParameters)
{

	/*Some initializations*/
	DDRD |= (1<<7);
      92:	8f 9a       	sbi	0x11, 7	; 17
	DDRD |= (1<<6);
      94:	8e 9a       	sbi	0x11, 6	; 17
	DDRD |= (1<<5);
      96:	8d 9a       	sbi	0x11, 5	; 17
		{
			PORTD ^= (1<<6);
		}
		else if (myBitsReturned == 0x03)
		{
			PORTD ^= (1<<5);
      98:	d0 e2       	ldi	r29, 0x20	; 32
		{
			PORTD ^= (1<<7);
		}
		else if(myBitsReturned == 0x02)
		{
			PORTD ^= (1<<6);
      9a:	c0 e4       	ldi	r28, 0x40	; 64
	DDRD |= (1<<6);
	DDRD |= (1<<5);
	EventBits_t myBitsReturned = 0X00;
	while(1)
	{
		myBitsReturned = xEventGroupWaitBits(myEventGroup,0x03,pdTRUE,pdFALSE,1000);
      9c:	80 91 78 00 	lds	r24, 0x0078
      a0:	90 91 79 00 	lds	r25, 0x0079
      a4:	63 e0       	ldi	r22, 0x03	; 3
      a6:	70 e0       	ldi	r23, 0x00	; 0
      a8:	41 e0       	ldi	r20, 0x01	; 1
      aa:	20 e0       	ldi	r18, 0x00	; 0
      ac:	08 ee       	ldi	r16, 0xE8	; 232
      ae:	13 e0       	ldi	r17, 0x03	; 3
      b0:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <xEventGroupWaitBits>
		if (myBitsReturned == 0x01)
      b4:	81 30       	cpi	r24, 0x01	; 1
      b6:	91 05       	cpc	r25, r1
      b8:	21 f4       	brne	.+8      	; 0xc2 <Task2+0x30>
		{
			PORTD ^= (1<<7);
      ba:	82 b3       	in	r24, 0x12	; 18
      bc:	80 58       	subi	r24, 0x80	; 128
      be:	82 bb       	out	0x12, r24	; 18
      c0:	ed cf       	rjmp	.-38     	; 0x9c <Task2+0xa>
		}
		else if(myBitsReturned == 0x02)
      c2:	82 30       	cpi	r24, 0x02	; 2
      c4:	91 05       	cpc	r25, r1
      c6:	21 f4       	brne	.+8      	; 0xd0 <Task2+0x3e>
		{
			PORTD ^= (1<<6);
      c8:	82 b3       	in	r24, 0x12	; 18
      ca:	8c 27       	eor	r24, r28
      cc:	82 bb       	out	0x12, r24	; 18
      ce:	e6 cf       	rjmp	.-52     	; 0x9c <Task2+0xa>
		}
		else if (myBitsReturned == 0x03)
      d0:	83 30       	cpi	r24, 0x03	; 3
      d2:	91 05       	cpc	r25, r1
      d4:	19 f7       	brne	.-58     	; 0x9c <Task2+0xa>
		{
			PORTD ^= (1<<5);
      d6:	82 b3       	in	r24, 0x12	; 18
      d8:	8d 27       	eor	r24, r29
      da:	82 bb       	out	0x12, r24	; 18
      dc:	df cf       	rjmp	.-66     	; 0x9c <Task2+0xa>

000000de <SetBit1>:

void SetBit1( void *pvParameters)
{
	while(1)
	{
		vTaskDelay(2000);
      de:	80 ed       	ldi	r24, 0xD0	; 208
      e0:	97 e0       	ldi	r25, 0x07	; 7
      e2:	0e 94 67 0e 	call	0x1cce	; 0x1cce <vTaskDelay>
		xEventGroupSetBits(myEventGroup,0x02);
      e6:	80 91 78 00 	lds	r24, 0x0078
      ea:	90 91 79 00 	lds	r25, 0x0079
      ee:	62 e0       	ldi	r22, 0x02	; 2
      f0:	70 e0       	ldi	r23, 0x00	; 0
      f2:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <xEventGroupSetBits>
      f6:	f3 cf       	rjmp	.-26     	; 0xde <SetBit1>

000000f8 <SetBit0>:

void SetBit0( void *pvParameters)
{
	while(1)
	{
		vTaskDelay(5000);
      f8:	88 e8       	ldi	r24, 0x88	; 136
      fa:	93 e1       	ldi	r25, 0x13	; 19
      fc:	0e 94 67 0e 	call	0x1cce	; 0x1cce <vTaskDelay>
		xEventGroupSetBits(myEventGroup,0x01);
     100:	80 91 78 00 	lds	r24, 0x0078
     104:	90 91 79 00 	lds	r25, 0x0079
     108:	61 e0       	ldi	r22, 0x01	; 1
     10a:	70 e0       	ldi	r23, 0x00	; 0
     10c:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <xEventGroupSetBits>
     110:	f3 cf       	rjmp	.-26     	; 0xf8 <SetBit0>

00000112 <main>:

int main(void)
{
	
	// Create Tasks
	xTaskCreate(SetBit0,"Bit0",100,NULL,3,NULL);
     112:	8c e7       	ldi	r24, 0x7C	; 124
     114:	90 e0       	ldi	r25, 0x00	; 0
     116:	60 e6       	ldi	r22, 0x60	; 96
     118:	70 e0       	ldi	r23, 0x00	; 0
     11a:	44 e6       	ldi	r20, 0x64	; 100
     11c:	50 e0       	ldi	r21, 0x00	; 0
     11e:	20 e0       	ldi	r18, 0x00	; 0
     120:	30 e0       	ldi	r19, 0x00	; 0
     122:	03 e0       	ldi	r16, 0x03	; 3
     124:	ee 24       	eor	r14, r14
     126:	ff 24       	eor	r15, r15
     128:	0e 94 08 0a 	call	0x1410	; 0x1410 <xTaskCreate>
	xTaskCreate(SetBit1,"Bit1",100,NULL,2,NULL);
     12c:	8f e6       	ldi	r24, 0x6F	; 111
     12e:	90 e0       	ldi	r25, 0x00	; 0
     130:	65 e6       	ldi	r22, 0x65	; 101
     132:	70 e0       	ldi	r23, 0x00	; 0
     134:	44 e6       	ldi	r20, 0x64	; 100
     136:	50 e0       	ldi	r21, 0x00	; 0
     138:	20 e0       	ldi	r18, 0x00	; 0
     13a:	30 e0       	ldi	r19, 0x00	; 0
     13c:	02 e0       	ldi	r16, 0x02	; 2
     13e:	0e 94 08 0a 	call	0x1410	; 0x1410 <xTaskCreate>
	xTaskCreate(Task2,"Task 2",200,NULL,1,NULL);
     142:	89 e4       	ldi	r24, 0x49	; 73
     144:	90 e0       	ldi	r25, 0x00	; 0
     146:	6a e6       	ldi	r22, 0x6A	; 106
     148:	70 e0       	ldi	r23, 0x00	; 0
     14a:	48 ec       	ldi	r20, 0xC8	; 200
     14c:	50 e0       	ldi	r21, 0x00	; 0
     14e:	20 e0       	ldi	r18, 0x00	; 0
     150:	30 e0       	ldi	r19, 0x00	; 0
     152:	01 e0       	ldi	r16, 0x01	; 1
     154:	0e 94 08 0a 	call	0x1410	; 0x1410 <xTaskCreate>
	//Create Event Group
	myEventGroup = xEventGroupCreate();
     158:	0e 94 c8 00 	call	0x190	; 0x190 <xEventGroupCreate>
     15c:	90 93 79 00 	sts	0x0079, r25
     160:	80 93 78 00 	sts	0x0078, r24
	vTaskStartScheduler();
     164:	0e 94 a1 0c 	call	0x1942	; 0x1942 <vTaskStartScheduler>
     168:	ff cf       	rjmp	.-2      	; 0x168 <main+0x56>

0000016a <prvTestWaitCondition>:

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
BaseType_t xWaitConditionMet = pdFALSE;

	if( xWaitForAllBits == pdFALSE )
     16a:	44 23       	and	r20, r20
     16c:	41 f4       	brne	.+16     	; 0x17e <prvTestWaitCondition+0x14>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     16e:	68 23       	and	r22, r24
     170:	79 23       	and	r23, r25
		{
			xWaitConditionMet = pdTRUE;
     172:	81 e0       	ldi	r24, 0x01	; 1
     174:	61 15       	cp	r22, r1
     176:	71 05       	cpc	r23, r1
     178:	51 f4       	brne	.+20     	; 0x18e <prvTestWaitCondition+0x24>
     17a:	80 e0       	ldi	r24, 0x00	; 0
     17c:	08 95       	ret
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     17e:	9b 01       	movw	r18, r22
     180:	28 23       	and	r18, r24
     182:	39 23       	and	r19, r25
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
		{
			xWaitConditionMet = pdTRUE;
     184:	81 e0       	ldi	r24, 0x01	; 1
     186:	62 17       	cp	r22, r18
     188:	73 07       	cpc	r23, r19
     18a:	09 f0       	breq	.+2      	; 0x18e <prvTestWaitCondition+0x24>
     18c:	80 e0       	ldi	r24, 0x00	; 0
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
}
     18e:	08 95       	ret

00000190 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     190:	cf 93       	push	r28
     192:	df 93       	push	r29
	EventGroup_t *pxEventBits;

		/* Allocate the event group. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
     194:	8b e0       	ldi	r24, 0x0B	; 11
     196:	90 e0       	ldi	r25, 0x00	; 0
     198:	0e 94 5e 02 	call	0x4bc	; 0x4bc <pvPortMalloc>
     19c:	ec 01       	movw	r28, r24

		if( pxEventBits != NULL )
     19e:	00 97       	sbiw	r24, 0x00	; 0
     1a0:	31 f0       	breq	.+12     	; 0x1ae <xEventGroupCreate+0x1e>
		{
			pxEventBits->uxEventBits = 0;
     1a2:	fc 01       	movw	r30, r24
     1a4:	11 92       	st	Z+, r1
     1a6:	11 92       	st	Z+, r1
     1a8:	cf 01       	movw	r24, r30
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     1aa:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
		{
			traceEVENT_GROUP_CREATE_FAILED();
		}

		return ( EventGroupHandle_t ) pxEventBits;
	}
     1ae:	8c 2f       	mov	r24, r28
     1b0:	9d 2f       	mov	r25, r29
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <xEventGroupWaitBits>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     1b8:	af 92       	push	r10
     1ba:	bf 92       	push	r11
     1bc:	cf 92       	push	r12
     1be:	df 92       	push	r13
     1c0:	ef 92       	push	r14
     1c2:	ff 92       	push	r15
     1c4:	0f 93       	push	r16
     1c6:	1f 93       	push	r17
     1c8:	cf 93       	push	r28
     1ca:	df 93       	push	r29
     1cc:	5c 01       	movw	r10, r24
     1ce:	6b 01       	movw	r12, r22
     1d0:	e4 2e       	mov	r14, r20
     1d2:	f2 2e       	mov	r15, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     1d4:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     1d8:	f5 01       	movw	r30, r10
     1da:	c0 81       	ld	r28, Z
     1dc:	d1 81       	ldd	r29, Z+1	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     1de:	ce 01       	movw	r24, r28
     1e0:	b6 01       	movw	r22, r12
     1e2:	4f 2d       	mov	r20, r15
     1e4:	0e 94 b5 00 	call	0x16a	; 0x16a <prvTestWaitCondition>

		if( xWaitConditionMet != pdFALSE )
     1e8:	88 23       	and	r24, r24
     1ea:	51 f0       	breq	.+20     	; 0x200 <xEventGroupWaitBits+0x48>
			block. */
			uxReturn = uxCurrentEventBits;
			xTicksToWait = ( TickType_t ) 0;

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     1ec:	ee 20       	and	r14, r14
     1ee:	01 f1       	breq	.+64     	; 0x230 <xEventGroupWaitBits+0x78>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1f0:	c0 94       	com	r12
     1f2:	d0 94       	com	r13
     1f4:	cc 22       	and	r12, r28
     1f6:	dd 22       	and	r13, r29
     1f8:	f5 01       	movw	r30, r10
     1fa:	d1 82       	std	Z+1, r13	; 0x01
     1fc:	c0 82       	st	Z, r12
     1fe:	18 c0       	rjmp	.+48     	; 0x230 <xEventGroupWaitBits+0x78>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     200:	01 15       	cp	r16, r1
     202:	11 05       	cpc	r17, r1
     204:	a9 f0       	breq	.+42     	; 0x230 <xEventGroupWaitBits+0x78>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     206:	ee 20       	and	r14, r14
     208:	19 f4       	brne	.+6      	; 0x210 <xEventGroupWaitBits+0x58>
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
EventBits_t uxReturn, uxControlBits = 0;
     20a:	60 e0       	ldi	r22, 0x00	; 0
     20c:	70 e0       	ldi	r23, 0x00	; 0
     20e:	02 c0       	rjmp	.+4      	; 0x214 <xEventGroupWaitBits+0x5c>
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     210:	60 e0       	ldi	r22, 0x00	; 0
     212:	71 e0       	ldi	r23, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     214:	f1 10       	cpse	r15, r1
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     216:	74 60       	ori	r23, 0x04	; 4
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     218:	6c 29       	or	r22, r12
     21a:	7d 29       	or	r23, r13
     21c:	c5 01       	movw	r24, r10
     21e:	02 96       	adiw	r24, 0x02	; 2
     220:	a8 01       	movw	r20, r16
     222:	0e 94 77 0f 	call	0x1eee	; 0x1eee <vTaskPlaceOnUnorderedEventList>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     226:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     22a:	88 23       	and	r24, r24
     22c:	39 f4       	brne	.+14     	; 0x23c <xEventGroupWaitBits+0x84>
     22e:	04 c0       	rjmp	.+8      	; 0x238 <xEventGroupWaitBits+0x80>
			uxReturn = 0;

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     230:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
     234:	ce 01       	movw	r24, r28
     236:	21 c0       	rjmp	.+66     	; 0x27a <xEventGroupWaitBits+0xc2>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     238:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     23c:	0e 94 fd 10 	call	0x21fa	; 0x21fa <uxTaskResetEventItemValue>
     240:	ec 01       	movw	r28, r24

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     242:	91 fd       	sbrc	r25, 1
     244:	18 c0       	rjmp	.+48     	; 0x276 <xEventGroupWaitBits+0xbe>
		{
			taskENTER_CRITICAL();
     246:	0f b6       	in	r0, 0x3f	; 63
     248:	f8 94       	cli
     24a:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     24c:	f5 01       	movw	r30, r10
     24e:	c0 81       	ld	r28, Z
     250:	d1 81       	ldd	r29, Z+1	; 0x01

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     252:	ce 01       	movw	r24, r28
     254:	b6 01       	movw	r22, r12
     256:	4f 2d       	mov	r20, r15
     258:	0e 94 b5 00 	call	0x16a	; 0x16a <prvTestWaitCondition>
     25c:	88 23       	and	r24, r24
     25e:	49 f0       	breq	.+18     	; 0x272 <xEventGroupWaitBits+0xba>
				{
					if( xClearOnExit != pdFALSE )
     260:	ee 20       	and	r14, r14
     262:	39 f0       	breq	.+14     	; 0x272 <xEventGroupWaitBits+0xba>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     264:	c0 94       	com	r12
     266:	d0 94       	com	r13
     268:	cc 22       	and	r12, r28
     26a:	dd 22       	and	r13, r29
     26c:	f5 01       	movw	r30, r10
     26e:	d1 82       	std	Z+1, r13	; 0x01
     270:	c0 82       	st	Z, r12
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     272:	0f 90       	pop	r0
     274:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     276:	ce 01       	movw	r24, r28
     278:	90 70       	andi	r25, 0x00	; 0
	}
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	1f 91       	pop	r17
     280:	0f 91       	pop	r16
     282:	ff 90       	pop	r15
     284:	ef 90       	pop	r14
     286:	df 90       	pop	r13
     288:	cf 90       	pop	r12
     28a:	bf 90       	pop	r11
     28c:	af 90       	pop	r10
     28e:	08 95       	ret

00000290 <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     290:	fc 01       	movw	r30, r24
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     292:	0f b6       	in	r0, 0x3f	; 63
     294:	f8 94       	cli
     296:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     298:	80 81       	ld	r24, Z
     29a:	91 81       	ldd	r25, Z+1	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     29c:	60 95       	com	r22
     29e:	70 95       	com	r23
     2a0:	68 23       	and	r22, r24
     2a2:	79 23       	and	r23, r25
     2a4:	71 83       	std	Z+1, r23	; 0x01
     2a6:	60 83       	st	Z, r22
	}
	taskEXIT_CRITICAL();
     2a8:	0f 90       	pop	r0
     2aa:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
     2ac:	08 95       	ret

000002ae <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     2ae:	fc 01       	movw	r30, r24
		uxReturn = pxEventBits->uxEventBits;
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
}
     2b0:	80 81       	ld	r24, Z
     2b2:	91 81       	ldd	r25, Z+1	; 0x01
     2b4:	08 95       	ret

000002b6 <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     2b6:	af 92       	push	r10
     2b8:	bf 92       	push	r11
     2ba:	cf 92       	push	r12
     2bc:	df 92       	push	r13
     2be:	ef 92       	push	r14
     2c0:	ff 92       	push	r15
     2c2:	0f 93       	push	r16
     2c4:	1f 93       	push	r17
     2c6:	cf 93       	push	r28
     2c8:	df 93       	push	r29
     2ca:	8c 01       	movw	r16, r24
     2cc:	eb 01       	movw	r28, r22
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ce:	0f 2e       	mov	r0, r31
     2d0:	f5 e0       	ldi	r31, 0x05	; 5
     2d2:	cf 2e       	mov	r12, r31
     2d4:	dd 24       	eor	r13, r13
     2d6:	f0 2d       	mov	r31, r0
     2d8:	c8 0e       	add	r12, r24
     2da:	d9 1e       	adc	r13, r25
	vTaskSuspendAll();
     2dc:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     2e0:	d8 01       	movw	r26, r16
     2e2:	17 96       	adiw	r26, 0x07	; 7
     2e4:	ed 91       	ld	r30, X+
     2e6:	fc 91       	ld	r31, X
     2e8:	18 97       	sbiw	r26, 0x08	; 8

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     2ea:	8d 91       	ld	r24, X+
     2ec:	9c 91       	ld	r25, X
     2ee:	11 97       	sbiw	r26, 0x01	; 1
     2f0:	8c 2b       	or	r24, r28
     2f2:	9d 2b       	or	r25, r29
     2f4:	11 96       	adiw	r26, 0x01	; 1
     2f6:	9c 93       	st	X, r25
     2f8:	8e 93       	st	-X, r24

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     2fa:	ce 16       	cp	r12, r30
     2fc:	df 06       	cpc	r13, r31
     2fe:	c1 f1       	breq	.+112    	; 0x370 <xEventGroupSetBits+0xba>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     300:	aa 24       	eor	r10, r10
     302:	bb 24       	eor	r11, r11
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     304:	ff 24       	eor	r15, r15
     306:	f3 94       	inc	r15
     308:	ee 24       	eor	r14, r14
     30a:	01 c0       	rjmp	.+2      	; 0x30e <xEventGroupSetBits+0x58>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     30c:	fe 01       	movw	r30, r28
		{
			pxNext = listGET_NEXT( pxListItem );
     30e:	c2 81       	ldd	r28, Z+2	; 0x02
     310:	d3 81       	ldd	r29, Z+3	; 0x03
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     312:	80 81       	ld	r24, Z
     314:	91 81       	ldd	r25, Z+1	; 0x01
			xMatchFound = pdFALSE;

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     316:	bc 01       	movw	r22, r24
     318:	60 70       	andi	r22, 0x00	; 0
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     31a:	9c 01       	movw	r18, r24
     31c:	30 70       	andi	r19, 0x00	; 0

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     31e:	92 fd       	sbrc	r25, 2
     320:	0b c0       	rjmp	.+22     	; 0x338 <xEventGroupSetBits+0x82>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     322:	d8 01       	movw	r26, r16
     324:	8d 91       	ld	r24, X+
     326:	9c 91       	ld	r25, X
     328:	11 97       	sbiw	r26, 0x01	; 1
     32a:	82 23       	and	r24, r18
     32c:	93 23       	and	r25, r19
				{
					xMatchFound = pdTRUE;
     32e:	4f 2d       	mov	r20, r15
     330:	00 97       	sbiw	r24, 0x00	; 0
     332:	69 f4       	brne	.+26     	; 0x34e <xEventGroupSetBits+0x98>
     334:	4e 2d       	mov	r20, r14
     336:	0b c0       	rjmp	.+22     	; 0x34e <xEventGroupSetBits+0x98>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     338:	d8 01       	movw	r26, r16
     33a:	8d 91       	ld	r24, X+
     33c:	9c 91       	ld	r25, X
     33e:	11 97       	sbiw	r26, 0x01	; 1
     340:	82 23       	and	r24, r18
     342:	93 23       	and	r25, r19
			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
				{
					xMatchFound = pdTRUE;
     344:	4f 2d       	mov	r20, r15
     346:	28 17       	cp	r18, r24
     348:	39 07       	cpc	r19, r25
     34a:	09 f0       	breq	.+2      	; 0x34e <xEventGroupSetBits+0x98>
     34c:	4e 2d       	mov	r20, r14
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     34e:	44 23       	and	r20, r20
     350:	59 f0       	breq	.+22     	; 0x368 <xEventGroupSetBits+0xb2>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     352:	70 ff       	sbrs	r23, 0
     354:	02 c0       	rjmp	.+4      	; 0x35a <xEventGroupSetBits+0xa4>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     356:	a2 2a       	or	r10, r18
     358:	b3 2a       	or	r11, r19
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     35a:	d8 01       	movw	r26, r16
     35c:	6d 91       	ld	r22, X+
     35e:	7c 91       	ld	r23, X
     360:	72 60       	ori	r23, 0x02	; 2
     362:	cf 01       	movw	r24, r30
     364:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <xTaskRemoveFromUnorderedEventList>

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     368:	cc 16       	cp	r12, r28
     36a:	dd 06       	cpc	r13, r29
     36c:	79 f6       	brne	.-98     	; 0x30c <xEventGroupSetBits+0x56>
     36e:	02 c0       	rjmp	.+4      	; 0x374 <xEventGroupSetBits+0xbe>
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t *pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     370:	aa 24       	eor	r10, r10
     372:	bb 24       	eor	r11, r11
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     374:	c5 01       	movw	r24, r10
     376:	80 95       	com	r24
     378:	90 95       	com	r25
     37a:	f8 01       	movw	r30, r16
     37c:	a0 80       	ld	r10, Z
     37e:	b1 80       	ldd	r11, Z+1	; 0x01
     380:	a8 22       	and	r10, r24
     382:	b9 22       	and	r11, r25
     384:	b1 82       	std	Z+1, r11	; 0x01
     386:	a0 82       	st	Z, r10
	}
	( void ) xTaskResumeAll();
     388:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

	return pxEventBits->uxEventBits;
}
     38c:	d8 01       	movw	r26, r16
     38e:	8c 91       	ld	r24, X
     390:	11 96       	adiw	r26, 0x01	; 1
     392:	9c 91       	ld	r25, X
     394:	11 97       	sbiw	r26, 0x01	; 1
     396:	df 91       	pop	r29
     398:	cf 91       	pop	r28
     39a:	1f 91       	pop	r17
     39c:	0f 91       	pop	r16
     39e:	ff 90       	pop	r15
     3a0:	ef 90       	pop	r14
     3a2:	df 90       	pop	r13
     3a4:	cf 90       	pop	r12
     3a6:	bf 90       	pop	r11
     3a8:	af 90       	pop	r10
     3aa:	08 95       	ret

000003ac <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     3ac:	af 92       	push	r10
     3ae:	bf 92       	push	r11
     3b0:	cf 92       	push	r12
     3b2:	df 92       	push	r13
     3b4:	ef 92       	push	r14
     3b6:	ff 92       	push	r15
     3b8:	0f 93       	push	r16
     3ba:	1f 93       	push	r17
     3bc:	cf 93       	push	r28
     3be:	df 93       	push	r29
     3c0:	6c 01       	movw	r12, r24
     3c2:	eb 01       	movw	r28, r22
     3c4:	7a 01       	movw	r14, r20
     3c6:	59 01       	movw	r10, r18
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     3c8:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     3cc:	f6 01       	movw	r30, r12
     3ce:	00 81       	ld	r16, Z
     3d0:	11 81       	ldd	r17, Z+1	; 0x01

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     3d2:	c6 01       	movw	r24, r12
     3d4:	be 01       	movw	r22, r28
     3d6:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     3da:	c0 2b       	or	r28, r16
     3dc:	d1 2b       	or	r29, r17
     3de:	c7 01       	movw	r24, r14
     3e0:	8c 23       	and	r24, r28
     3e2:	9d 23       	and	r25, r29
     3e4:	8e 15       	cp	r24, r14
     3e6:	9f 05       	cpc	r25, r15
     3e8:	51 f4       	brne	.+20     	; 0x3fe <xEventGroupSync+0x52>
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     3ea:	80 95       	com	r24
     3ec:	90 95       	com	r25
     3ee:	f6 01       	movw	r30, r12
     3f0:	20 81       	ld	r18, Z
     3f2:	31 81       	ldd	r19, Z+1	; 0x01
     3f4:	82 23       	and	r24, r18
     3f6:	93 23       	and	r25, r19
     3f8:	91 83       	std	Z+1, r25	; 0x01
     3fa:	80 83       	st	Z, r24
     3fc:	12 c0       	rjmp	.+36     	; 0x422 <xEventGroupSync+0x76>

			xTicksToWait = 0;
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     3fe:	a1 14       	cp	r10, r1
     400:	b1 04       	cpc	r11, r1
     402:	61 f0       	breq	.+24     	; 0x41c <xEventGroupSync+0x70>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     404:	b7 01       	movw	r22, r14
     406:	75 60       	ori	r23, 0x05	; 5
     408:	c6 01       	movw	r24, r12
     40a:	02 96       	adiw	r24, 0x02	; 2
     40c:	a5 01       	movw	r20, r10
     40e:	0e 94 77 0f 	call	0x1eee	; 0x1eee <vTaskPlaceOnUnorderedEventList>
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     412:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
     416:	88 23       	and	r24, r24
     418:	49 f4       	brne	.+18     	; 0x42c <xEventGroupSync+0x80>
     41a:	06 c0       	rjmp	.+12     	; 0x428 <xEventGroupSync+0x7c>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     41c:	f6 01       	movw	r30, r12
     41e:	c0 81       	ld	r28, Z
     420:	d1 81       	ldd	r29, Z+1	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     422:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
     426:	1c c0       	rjmp	.+56     	; 0x460 <xEventGroupSync+0xb4>

	if( xTicksToWait != ( TickType_t ) 0 )
	{
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
     428:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     42c:	0e 94 fd 10 	call	0x21fa	; 0x21fa <uxTaskResetEventItemValue>

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     430:	91 fd       	sbrc	r25, 1
     432:	14 c0       	rjmp	.+40     	; 0x45c <xEventGroupSync+0xb0>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     434:	0f b6       	in	r0, 0x3f	; 63
     436:	f8 94       	cli
     438:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     43a:	f6 01       	movw	r30, r12
     43c:	80 81       	ld	r24, Z
     43e:	91 81       	ldd	r25, Z+1	; 0x01

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     440:	97 01       	movw	r18, r14
     442:	28 23       	and	r18, r24
     444:	39 23       	and	r19, r25
     446:	2e 15       	cp	r18, r14
     448:	3f 05       	cpc	r19, r15
     44a:	31 f4       	brne	.+12     	; 0x458 <xEventGroupSync+0xac>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     44c:	20 95       	com	r18
     44e:	30 95       	com	r19
     450:	28 23       	and	r18, r24
     452:	39 23       	and	r19, r25
     454:	31 83       	std	Z+1, r19	; 0x01
     456:	20 83       	st	Z, r18
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     458:	0f 90       	pop	r0
     45a:	0f be       	out	0x3f, r0	; 63
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     45c:	ec 01       	movw	r28, r24
     45e:	d0 70       	andi	r29, 0x00	; 0
	}

	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	return uxReturn;
}
     460:	8c 2f       	mov	r24, r28
     462:	9d 2f       	mov	r25, r29
     464:	df 91       	pop	r29
     466:	cf 91       	pop	r28
     468:	1f 91       	pop	r17
     46a:	0f 91       	pop	r16
     46c:	ff 90       	pop	r15
     46e:	ef 90       	pop	r14
     470:	df 90       	pop	r13
     472:	cf 90       	pop	r12
     474:	bf 90       	pop	r11
     476:	af 90       	pop	r10
     478:	08 95       	ret

0000047a <vEventGroupDelete>:
	return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     47a:	cf 93       	push	r28
     47c:	df 93       	push	r29
     47e:	ec 01       	movw	r28, r24
EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

	vTaskSuspendAll();
     480:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     484:	8a 81       	ldd	r24, Y+2	; 0x02
     486:	88 23       	and	r24, r24
     488:	49 f0       	breq	.+18     	; 0x49c <vEventGroupDelete+0x22>
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and	cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     48a:	8f 81       	ldd	r24, Y+7	; 0x07
     48c:	98 85       	ldd	r25, Y+8	; 0x08
     48e:	60 e0       	ldi	r22, 0x00	; 0
     490:	72 e0       	ldi	r23, 0x02	; 2
     492:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <xTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     496:	8a 81       	ldd	r24, Y+2	; 0x02
     498:	88 23       	and	r24, r24
     49a:	b9 f7       	brne	.-18     	; 0x48a <vEventGroupDelete+0x10>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     49c:	ce 01       	movw	r24, r28
     49e:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     4a2:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
}
     4a6:	df 91       	pop	r29
     4a8:	cf 91       	pop	r28
     4aa:	08 95       	ret

000004ac <vEventGroupSetBitsCallback>:

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
     4ac:	ba 01       	movw	r22, r20
     4ae:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <xEventGroupSetBits>
}
     4b2:	08 95       	ret

000004b4 <vEventGroupClearBitsCallback>:

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
     4b4:	ba 01       	movw	r22, r20
     4b6:	0e 94 48 01 	call	0x290	; 0x290 <xEventGroupClearBits>
}
     4ba:	08 95       	ret

000004bc <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4bc:	0f 93       	push	r16
     4be:	1f 93       	push	r17
     4c0:	cf 93       	push	r28
     4c2:	df 93       	push	r29
     4c4:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     4c6:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     4ca:	80 91 7a 00 	lds	r24, 0x007A
     4ce:	88 23       	and	r24, r24
     4d0:	f9 f4       	brne	.+62     	; 0x510 <pvPortMalloc+0x54>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     4d2:	84 e8       	ldi	r24, 0x84	; 132
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	90 93 7c 00 	sts	0x007C, r25
     4da:	80 93 7b 00 	sts	0x007B, r24
	xStart.xBlockSize = ( size_t ) 0;
     4de:	10 92 7e 00 	sts	0x007E, r1
     4e2:	10 92 7d 00 	sts	0x007D, r1

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     4e6:	83 e8       	ldi	r24, 0x83	; 131
     4e8:	93 e0       	ldi	r25, 0x03	; 3
     4ea:	90 93 82 00 	sts	0x0082, r25
     4ee:	80 93 81 00 	sts	0x0081, r24
	xEnd.pxNextFreeBlock = NULL;
     4f2:	e1 e8       	ldi	r30, 0x81	; 129
     4f4:	f0 e0       	ldi	r31, 0x00	; 0
     4f6:	12 92       	st	-Z, r1
     4f8:	12 92       	st	-Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     4fa:	90 93 87 00 	sts	0x0087, r25
     4fe:	80 93 86 00 	sts	0x0086, r24
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     502:	f0 93 85 00 	sts	0x0085, r31
     506:	e0 93 84 00 	sts	0x0084, r30
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     50a:	81 e0       	ldi	r24, 0x01	; 1
     50c:	80 93 7a 00 	sts	0x007A, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     510:	20 97       	sbiw	r28, 0x00	; 0
     512:	09 f4       	brne	.+2      	; 0x516 <pvPortMalloc+0x5a>
     514:	62 c0       	rjmp	.+196    	; 0x5da <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
     516:	9e 01       	movw	r18, r28
     518:	2c 5f       	subi	r18, 0xFC	; 252
     51a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     51c:	23 96       	adiw	r28, 0x03	; 3
     51e:	83 e0       	ldi	r24, 0x03	; 3
     520:	c2 38       	cpi	r28, 0x82	; 130
     522:	d8 07       	cpc	r29, r24
     524:	08 f0       	brcs	.+2      	; 0x528 <pvPortMalloc+0x6c>
     526:	5c c0       	rjmp	.+184    	; 0x5e0 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     528:	e0 91 7b 00 	lds	r30, 0x007B
     52c:	f0 91 7c 00 	lds	r31, 0x007C

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     530:	ab e7       	ldi	r26, 0x7B	; 123
     532:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     534:	02 c0       	rjmp	.+4      	; 0x53a <pvPortMalloc+0x7e>
     536:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     538:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     53a:	82 81       	ldd	r24, Z+2	; 0x02
     53c:	93 81       	ldd	r25, Z+3	; 0x03
     53e:	82 17       	cp	r24, r18
     540:	93 07       	cpc	r25, r19
     542:	20 f4       	brcc	.+8      	; 0x54c <pvPortMalloc+0x90>
     544:	80 81       	ld	r24, Z
     546:	91 81       	ldd	r25, Z+1	; 0x01
     548:	00 97       	sbiw	r24, 0x00	; 0
     54a:	a9 f7       	brne	.-22     	; 0x536 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     54c:	c0 e0       	ldi	r28, 0x00	; 0
     54e:	ef 37       	cpi	r30, 0x7F	; 127
     550:	fc 07       	cpc	r31, r28
     552:	09 f4       	brne	.+2      	; 0x556 <pvPortMalloc+0x9a>
     554:	48 c0       	rjmp	.+144    	; 0x5e6 <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     556:	8d 91       	ld	r24, X+
     558:	9c 91       	ld	r25, X
     55a:	11 97       	sbiw	r26, 0x01	; 1
     55c:	8c 01       	movw	r16, r24
     55e:	0c 5f       	subi	r16, 0xFC	; 252
     560:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     562:	80 81       	ld	r24, Z
     564:	91 81       	ldd	r25, Z+1	; 0x01
     566:	11 96       	adiw	r26, 0x01	; 1
     568:	9c 93       	st	X, r25
     56a:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     56c:	82 81       	ldd	r24, Z+2	; 0x02
     56e:	93 81       	ldd	r25, Z+3	; 0x03
     570:	82 1b       	sub	r24, r18
     572:	93 0b       	sbc	r25, r19
     574:	89 30       	cpi	r24, 0x09	; 9
     576:	91 05       	cpc	r25, r1
     578:	18 f1       	brcs	.+70     	; 0x5c0 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     57a:	af 01       	movw	r20, r30
     57c:	42 0f       	add	r20, r18
     57e:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     580:	da 01       	movw	r26, r20
     582:	13 96       	adiw	r26, 0x03	; 3
     584:	9c 93       	st	X, r25
     586:	8e 93       	st	-X, r24
     588:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     58a:	33 83       	std	Z+3, r19	; 0x03
     58c:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     58e:	12 96       	adiw	r26, 0x02	; 2
     590:	2d 91       	ld	r18, X+
     592:	3c 91       	ld	r19, X
     594:	13 97       	sbiw	r26, 0x03	; 3
     596:	6b e7       	ldi	r22, 0x7B	; 123
     598:	70 e0       	ldi	r23, 0x00	; 0
     59a:	01 c0       	rjmp	.+2      	; 0x59e <pvPortMalloc+0xe2>
     59c:	bd 01       	movw	r22, r26
     59e:	eb 01       	movw	r28, r22
     5a0:	a8 81       	ld	r26, Y
     5a2:	b9 81       	ldd	r27, Y+1	; 0x01
     5a4:	12 96       	adiw	r26, 0x02	; 2
     5a6:	8d 91       	ld	r24, X+
     5a8:	9c 91       	ld	r25, X
     5aa:	13 97       	sbiw	r26, 0x03	; 3
     5ac:	82 17       	cp	r24, r18
     5ae:	93 07       	cpc	r25, r19
     5b0:	a8 f3       	brcs	.-22     	; 0x59c <pvPortMalloc+0xe0>
     5b2:	ea 01       	movw	r28, r20
     5b4:	b9 83       	std	Y+1, r27	; 0x01
     5b6:	a8 83       	st	Y, r26
     5b8:	db 01       	movw	r26, r22
     5ba:	11 96       	adiw	r26, 0x01	; 1
     5bc:	5c 93       	st	X, r21
     5be:	4e 93       	st	-X, r20
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     5c0:	80 91 71 00 	lds	r24, 0x0071
     5c4:	90 91 72 00 	lds	r25, 0x0072
     5c8:	22 81       	ldd	r18, Z+2	; 0x02
     5ca:	33 81       	ldd	r19, Z+3	; 0x03
     5cc:	82 1b       	sub	r24, r18
     5ce:	93 0b       	sbc	r25, r19
     5d0:	90 93 72 00 	sts	0x0072, r25
     5d4:	80 93 71 00 	sts	0x0071, r24
     5d8:	08 c0       	rjmp	.+16     	; 0x5ea <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     5da:	00 e0       	ldi	r16, 0x00	; 0
     5dc:	10 e0       	ldi	r17, 0x00	; 0
     5de:	05 c0       	rjmp	.+10     	; 0x5ea <pvPortMalloc+0x12e>
     5e0:	00 e0       	ldi	r16, 0x00	; 0
     5e2:	10 e0       	ldi	r17, 0x00	; 0
     5e4:	02 c0       	rjmp	.+4      	; 0x5ea <pvPortMalloc+0x12e>
     5e6:	00 e0       	ldi	r16, 0x00	; 0
     5e8:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5ea:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5ee:	80 2f       	mov	r24, r16
     5f0:	91 2f       	mov	r25, r17
     5f2:	df 91       	pop	r29
     5f4:	cf 91       	pop	r28
     5f6:	1f 91       	pop	r17
     5f8:	0f 91       	pop	r16
     5fa:	08 95       	ret

000005fc <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5fc:	0f 93       	push	r16
     5fe:	1f 93       	push	r17
     600:	cf 93       	push	r28
     602:	df 93       	push	r29
     604:	ec 01       	movw	r28, r24
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     606:	00 97       	sbiw	r24, 0x00	; 0
     608:	39 f1       	breq	.+78     	; 0x658 <vPortFree+0x5c>
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
     60a:	8c 01       	movw	r16, r24
     60c:	04 50       	subi	r16, 0x04	; 4
     60e:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
     610:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     614:	f8 01       	movw	r30, r16
     616:	22 81       	ldd	r18, Z+2	; 0x02
     618:	33 81       	ldd	r19, Z+3	; 0x03
     61a:	ab e7       	ldi	r26, 0x7B	; 123
     61c:	b0 e0       	ldi	r27, 0x00	; 0
     61e:	01 c0       	rjmp	.+2      	; 0x622 <vPortFree+0x26>
     620:	df 01       	movw	r26, r30
     622:	ed 91       	ld	r30, X+
     624:	fc 91       	ld	r31, X
     626:	11 97       	sbiw	r26, 0x01	; 1
     628:	82 81       	ldd	r24, Z+2	; 0x02
     62a:	93 81       	ldd	r25, Z+3	; 0x03
     62c:	82 17       	cp	r24, r18
     62e:	93 07       	cpc	r25, r19
     630:	b8 f3       	brcs	.-18     	; 0x620 <vPortFree+0x24>
     632:	24 97       	sbiw	r28, 0x04	; 4
     634:	f9 83       	std	Y+1, r31	; 0x01
     636:	e8 83       	st	Y, r30
     638:	0d 93       	st	X+, r16
     63a:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     63c:	80 91 71 00 	lds	r24, 0x0071
     640:	90 91 72 00 	lds	r25, 0x0072
     644:	2a 81       	ldd	r18, Y+2	; 0x02
     646:	3b 81       	ldd	r19, Y+3	; 0x03
     648:	82 0f       	add	r24, r18
     64a:	93 1f       	adc	r25, r19
     64c:	90 93 72 00 	sts	0x0072, r25
     650:	80 93 71 00 	sts	0x0071, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     654:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
	}
}
     658:	df 91       	pop	r29
     65a:	cf 91       	pop	r28
     65c:	1f 91       	pop	r17
     65e:	0f 91       	pop	r16
     660:	08 95       	ret

00000662 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
     662:	80 91 71 00 	lds	r24, 0x0071
     666:	90 91 72 00 	lds	r25, 0x0072
     66a:	08 95       	ret

0000066c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
     66c:	08 95       	ret

0000066e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     66e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     670:	03 96       	adiw	r24, 0x03	; 3
     672:	92 83       	std	Z+2, r25	; 0x02
     674:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     676:	2f ef       	ldi	r18, 0xFF	; 255
     678:	3f ef       	ldi	r19, 0xFF	; 255
     67a:	34 83       	std	Z+4, r19	; 0x04
     67c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     67e:	96 83       	std	Z+6, r25	; 0x06
     680:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     682:	90 87       	std	Z+8, r25	; 0x08
     684:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     686:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     688:	08 95       	ret

0000068a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     68a:	fc 01       	movw	r30, r24
     68c:	11 86       	std	Z+9, r1	; 0x09
     68e:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     690:	08 95       	ret

00000692 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     692:	cf 93       	push	r28
     694:	df 93       	push	r29
     696:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     698:	dc 01       	movw	r26, r24
     69a:	11 96       	adiw	r26, 0x01	; 1
     69c:	cd 91       	ld	r28, X+
     69e:	dc 91       	ld	r29, X
     6a0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     6a2:	d3 83       	std	Z+3, r29	; 0x03
     6a4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     6a6:	2c 81       	ldd	r18, Y+4	; 0x04
     6a8:	3d 81       	ldd	r19, Y+5	; 0x05
     6aa:	35 83       	std	Z+5, r19	; 0x05
     6ac:	24 83       	std	Z+4, r18	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     6ae:	ac 81       	ldd	r26, Y+4	; 0x04
     6b0:	bd 81       	ldd	r27, Y+5	; 0x05
     6b2:	13 96       	adiw	r26, 0x03	; 3
     6b4:	7c 93       	st	X, r23
     6b6:	6e 93       	st	-X, r22
     6b8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     6ba:	7d 83       	std	Y+5, r23	; 0x05
     6bc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     6be:	91 87       	std	Z+9, r25	; 0x09
     6c0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     6c2:	fc 01       	movw	r30, r24
     6c4:	20 81       	ld	r18, Z
     6c6:	2f 5f       	subi	r18, 0xFF	; 255
     6c8:	20 83       	st	Z, r18
}
     6ca:	df 91       	pop	r29
     6cc:	cf 91       	pop	r28
     6ce:	08 95       	ret

000006d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     6d0:	cf 93       	push	r28
     6d2:	df 93       	push	r29
     6d4:	ac 01       	movw	r20, r24
     6d6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     6d8:	28 81       	ld	r18, Y
     6da:	39 81       	ldd	r19, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     6dc:	8f ef       	ldi	r24, 0xFF	; 255
     6de:	2f 3f       	cpi	r18, 0xFF	; 255
     6e0:	38 07       	cpc	r19, r24
     6e2:	21 f4       	brne	.+8      	; 0x6ec <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     6e4:	fa 01       	movw	r30, r20
     6e6:	a7 81       	ldd	r26, Z+7	; 0x07
     6e8:	b0 85       	ldd	r27, Z+8	; 0x08
     6ea:	0d c0       	rjmp	.+26     	; 0x706 <vListInsert+0x36>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     6ec:	da 01       	movw	r26, r20
     6ee:	13 96       	adiw	r26, 0x03	; 3
     6f0:	01 c0       	rjmp	.+2      	; 0x6f4 <vListInsert+0x24>
     6f2:	df 01       	movw	r26, r30
     6f4:	12 96       	adiw	r26, 0x02	; 2
     6f6:	ed 91       	ld	r30, X+
     6f8:	fc 91       	ld	r31, X
     6fa:	13 97       	sbiw	r26, 0x03	; 3
     6fc:	80 81       	ld	r24, Z
     6fe:	91 81       	ldd	r25, Z+1	; 0x01
     700:	28 17       	cp	r18, r24
     702:	39 07       	cpc	r19, r25
     704:	b0 f7       	brcc	.-20     	; 0x6f2 <vListInsert+0x22>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     706:	12 96       	adiw	r26, 0x02	; 2
     708:	ed 91       	ld	r30, X+
     70a:	fc 91       	ld	r31, X
     70c:	13 97       	sbiw	r26, 0x03	; 3
     70e:	fb 83       	std	Y+3, r31	; 0x03
     710:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     712:	d5 83       	std	Z+5, r29	; 0x05
     714:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     716:	bd 83       	std	Y+5, r27	; 0x05
     718:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     71a:	13 96       	adiw	r26, 0x03	; 3
     71c:	dc 93       	st	X, r29
     71e:	ce 93       	st	-X, r28
     720:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     722:	59 87       	std	Y+9, r21	; 0x09
     724:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
     726:	fa 01       	movw	r30, r20
     728:	80 81       	ld	r24, Z
     72a:	8f 5f       	subi	r24, 0xFF	; 255
     72c:	80 83       	st	Z, r24
}
     72e:	df 91       	pop	r29
     730:	cf 91       	pop	r28
     732:	08 95       	ret

00000734 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     734:	cf 93       	push	r28
     736:	df 93       	push	r29
     738:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     73a:	c0 85       	ldd	r28, Z+8	; 0x08
     73c:	d1 85       	ldd	r29, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     73e:	a2 81       	ldd	r26, Z+2	; 0x02
     740:	b3 81       	ldd	r27, Z+3	; 0x03
     742:	84 81       	ldd	r24, Z+4	; 0x04
     744:	95 81       	ldd	r25, Z+5	; 0x05
     746:	15 96       	adiw	r26, 0x05	; 5
     748:	9c 93       	st	X, r25
     74a:	8e 93       	st	-X, r24
     74c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     74e:	a4 81       	ldd	r26, Z+4	; 0x04
     750:	b5 81       	ldd	r27, Z+5	; 0x05
     752:	82 81       	ldd	r24, Z+2	; 0x02
     754:	93 81       	ldd	r25, Z+3	; 0x03
     756:	13 96       	adiw	r26, 0x03	; 3
     758:	9c 93       	st	X, r25
     75a:	8e 93       	st	-X, r24
     75c:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     75e:	a9 81       	ldd	r26, Y+1	; 0x01
     760:	ba 81       	ldd	r27, Y+2	; 0x02
     762:	ae 17       	cp	r26, r30
     764:	bf 07       	cpc	r27, r31
     766:	31 f4       	brne	.+12     	; 0x774 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     768:	14 96       	adiw	r26, 0x04	; 4
     76a:	8d 91       	ld	r24, X+
     76c:	9c 91       	ld	r25, X
     76e:	15 97       	sbiw	r26, 0x05	; 5
     770:	9a 83       	std	Y+2, r25	; 0x02
     772:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     774:	11 86       	std	Z+9, r1	; 0x09
     776:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     778:	88 81       	ld	r24, Y
     77a:	81 50       	subi	r24, 0x01	; 1
     77c:	88 83       	st	Y, r24

	return pxList->uxNumberOfItems;
}
     77e:	df 91       	pop	r29
     780:	cf 91       	pop	r28
     782:	08 95       	ret

00000784 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     784:	21 e1       	ldi	r18, 0x11	; 17
     786:	fc 01       	movw	r30, r24
     788:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     78a:	31 97       	sbiw	r30, 0x01	; 1
     78c:	32 e2       	ldi	r19, 0x22	; 34
     78e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     790:	fc 01       	movw	r30, r24
     792:	32 97       	sbiw	r30, 0x02	; 2
     794:	a3 e3       	ldi	r26, 0x33	; 51
     796:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     798:	fc 01       	movw	r30, r24
     79a:	33 97       	sbiw	r30, 0x03	; 3
     79c:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     79e:	fc 01       	movw	r30, r24
     7a0:	34 97       	sbiw	r30, 0x04	; 4
     7a2:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     7a4:	fc 01       	movw	r30, r24
     7a6:	35 97       	sbiw	r30, 0x05	; 5
     7a8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     7aa:	fc 01       	movw	r30, r24
     7ac:	36 97       	sbiw	r30, 0x06	; 6
     7ae:	60 e8       	ldi	r22, 0x80	; 128
     7b0:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     7b2:	fc 01       	movw	r30, r24
     7b4:	37 97       	sbiw	r30, 0x07	; 7
     7b6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     7b8:	fc 01       	movw	r30, r24
     7ba:	38 97       	sbiw	r30, 0x08	; 8
     7bc:	62 e0       	ldi	r22, 0x02	; 2
     7be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     7c0:	fc 01       	movw	r30, r24
     7c2:	39 97       	sbiw	r30, 0x09	; 9
     7c4:	63 e0       	ldi	r22, 0x03	; 3
     7c6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     7c8:	fc 01       	movw	r30, r24
     7ca:	3a 97       	sbiw	r30, 0x0a	; 10
     7cc:	64 e0       	ldi	r22, 0x04	; 4
     7ce:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     7d0:	fc 01       	movw	r30, r24
     7d2:	3b 97       	sbiw	r30, 0x0b	; 11
     7d4:	65 e0       	ldi	r22, 0x05	; 5
     7d6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     7d8:	fc 01       	movw	r30, r24
     7da:	3c 97       	sbiw	r30, 0x0c	; 12
     7dc:	66 e0       	ldi	r22, 0x06	; 6
     7de:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     7e0:	fc 01       	movw	r30, r24
     7e2:	3d 97       	sbiw	r30, 0x0d	; 13
     7e4:	67 e0       	ldi	r22, 0x07	; 7
     7e6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     7e8:	fc 01       	movw	r30, r24
     7ea:	3e 97       	sbiw	r30, 0x0e	; 14
     7ec:	68 e0       	ldi	r22, 0x08	; 8
     7ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     7f0:	fc 01       	movw	r30, r24
     7f2:	3f 97       	sbiw	r30, 0x0f	; 15
     7f4:	69 e0       	ldi	r22, 0x09	; 9
     7f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     7f8:	fc 01       	movw	r30, r24
     7fa:	70 97       	sbiw	r30, 0x10	; 16
     7fc:	60 e1       	ldi	r22, 0x10	; 16
     7fe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     800:	fc 01       	movw	r30, r24
     802:	71 97       	sbiw	r30, 0x11	; 17
     804:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     806:	fc 01       	movw	r30, r24
     808:	72 97       	sbiw	r30, 0x12	; 18
     80a:	22 e1       	ldi	r18, 0x12	; 18
     80c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     80e:	fc 01       	movw	r30, r24
     810:	73 97       	sbiw	r30, 0x13	; 19
     812:	23 e1       	ldi	r18, 0x13	; 19
     814:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     816:	fc 01       	movw	r30, r24
     818:	74 97       	sbiw	r30, 0x14	; 20
     81a:	24 e1       	ldi	r18, 0x14	; 20
     81c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     81e:	fc 01       	movw	r30, r24
     820:	75 97       	sbiw	r30, 0x15	; 21
     822:	25 e1       	ldi	r18, 0x15	; 21
     824:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     826:	fc 01       	movw	r30, r24
     828:	76 97       	sbiw	r30, 0x16	; 22
     82a:	26 e1       	ldi	r18, 0x16	; 22
     82c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     82e:	fc 01       	movw	r30, r24
     830:	77 97       	sbiw	r30, 0x17	; 23
     832:	27 e1       	ldi	r18, 0x17	; 23
     834:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     836:	fc 01       	movw	r30, r24
     838:	78 97       	sbiw	r30, 0x18	; 24
     83a:	28 e1       	ldi	r18, 0x18	; 24
     83c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     83e:	fc 01       	movw	r30, r24
     840:	79 97       	sbiw	r30, 0x19	; 25
     842:	29 e1       	ldi	r18, 0x19	; 25
     844:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     846:	fc 01       	movw	r30, r24
     848:	7a 97       	sbiw	r30, 0x1a	; 26
     84a:	20 e2       	ldi	r18, 0x20	; 32
     84c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     84e:	fc 01       	movw	r30, r24
     850:	7b 97       	sbiw	r30, 0x1b	; 27
     852:	21 e2       	ldi	r18, 0x21	; 33
     854:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     856:	fc 01       	movw	r30, r24
     858:	7c 97       	sbiw	r30, 0x1c	; 28
     85a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     85c:	fc 01       	movw	r30, r24
     85e:	7d 97       	sbiw	r30, 0x1d	; 29
     860:	23 e2       	ldi	r18, 0x23	; 35
     862:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     864:	fc 01       	movw	r30, r24
     866:	7e 97       	sbiw	r30, 0x1e	; 30
     868:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     86a:	fc 01       	movw	r30, r24
     86c:	7f 97       	sbiw	r30, 0x1f	; 31
     86e:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     870:	fc 01       	movw	r30, r24
     872:	b0 97       	sbiw	r30, 0x20	; 32
     874:	26 e2       	ldi	r18, 0x26	; 38
     876:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     878:	fc 01       	movw	r30, r24
     87a:	b1 97       	sbiw	r30, 0x21	; 33
     87c:	27 e2       	ldi	r18, 0x27	; 39
     87e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     880:	fc 01       	movw	r30, r24
     882:	b2 97       	sbiw	r30, 0x22	; 34
     884:	28 e2       	ldi	r18, 0x28	; 40
     886:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     888:	fc 01       	movw	r30, r24
     88a:	b3 97       	sbiw	r30, 0x23	; 35
     88c:	29 e2       	ldi	r18, 0x29	; 41
     88e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     890:	fc 01       	movw	r30, r24
     892:	b4 97       	sbiw	r30, 0x24	; 36
     894:	20 e3       	ldi	r18, 0x30	; 48
     896:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     898:	fc 01       	movw	r30, r24
     89a:	b5 97       	sbiw	r30, 0x25	; 37
     89c:	21 e3       	ldi	r18, 0x31	; 49
     89e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     8a0:	86 97       	sbiw	r24, 0x26	; 38
}
     8a2:	08 95       	ret

000008a4 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     8a4:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
     8a6:	8c e7       	ldi	r24, 0x7C	; 124
     8a8:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     8aa:	8b e0       	ldi	r24, 0x0B	; 11
     8ac:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     8ae:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     8b0:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
     8b2:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     8b4:	a0 91 07 04 	lds	r26, 0x0407
     8b8:	b0 91 08 04 	lds	r27, 0x0408
     8bc:	cd 91       	ld	r28, X+
     8be:	cd bf       	out	0x3d, r28	; 61
     8c0:	dd 91       	ld	r29, X+
     8c2:	de bf       	out	0x3e, r29	; 62
     8c4:	ff 91       	pop	r31
     8c6:	ef 91       	pop	r30
     8c8:	df 91       	pop	r29
     8ca:	cf 91       	pop	r28
     8cc:	bf 91       	pop	r27
     8ce:	af 91       	pop	r26
     8d0:	9f 91       	pop	r25
     8d2:	8f 91       	pop	r24
     8d4:	7f 91       	pop	r23
     8d6:	6f 91       	pop	r22
     8d8:	5f 91       	pop	r21
     8da:	4f 91       	pop	r20
     8dc:	3f 91       	pop	r19
     8de:	2f 91       	pop	r18
     8e0:	1f 91       	pop	r17
     8e2:	0f 91       	pop	r16
     8e4:	ff 90       	pop	r15
     8e6:	ef 90       	pop	r14
     8e8:	df 90       	pop	r13
     8ea:	cf 90       	pop	r12
     8ec:	bf 90       	pop	r11
     8ee:	af 90       	pop	r10
     8f0:	9f 90       	pop	r9
     8f2:	8f 90       	pop	r8
     8f4:	7f 90       	pop	r7
     8f6:	6f 90       	pop	r6
     8f8:	5f 90       	pop	r5
     8fa:	4f 90       	pop	r4
     8fc:	3f 90       	pop	r3
     8fe:	2f 90       	pop	r2
     900:	1f 90       	pop	r1
     902:	0f 90       	pop	r0
     904:	0f be       	out	0x3f, r0	; 63
     906:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     908:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     90a:	81 e0       	ldi	r24, 0x01	; 1
     90c:	08 95       	ret

0000090e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     90e:	08 95       	ret

00000910 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     910:	0f 92       	push	r0
     912:	0f b6       	in	r0, 0x3f	; 63
     914:	f8 94       	cli
     916:	0f 92       	push	r0
     918:	1f 92       	push	r1
     91a:	11 24       	eor	r1, r1
     91c:	2f 92       	push	r2
     91e:	3f 92       	push	r3
     920:	4f 92       	push	r4
     922:	5f 92       	push	r5
     924:	6f 92       	push	r6
     926:	7f 92       	push	r7
     928:	8f 92       	push	r8
     92a:	9f 92       	push	r9
     92c:	af 92       	push	r10
     92e:	bf 92       	push	r11
     930:	cf 92       	push	r12
     932:	df 92       	push	r13
     934:	ef 92       	push	r14
     936:	ff 92       	push	r15
     938:	0f 93       	push	r16
     93a:	1f 93       	push	r17
     93c:	2f 93       	push	r18
     93e:	3f 93       	push	r19
     940:	4f 93       	push	r20
     942:	5f 93       	push	r21
     944:	6f 93       	push	r22
     946:	7f 93       	push	r23
     948:	8f 93       	push	r24
     94a:	9f 93       	push	r25
     94c:	af 93       	push	r26
     94e:	bf 93       	push	r27
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	ef 93       	push	r30
     956:	ff 93       	push	r31
     958:	a0 91 07 04 	lds	r26, 0x0407
     95c:	b0 91 08 04 	lds	r27, 0x0408
     960:	0d b6       	in	r0, 0x3d	; 61
     962:	0d 92       	st	X+, r0
     964:	0e b6       	in	r0, 0x3e	; 62
     966:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     968:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     96c:	a0 91 07 04 	lds	r26, 0x0407
     970:	b0 91 08 04 	lds	r27, 0x0408
     974:	cd 91       	ld	r28, X+
     976:	cd bf       	out	0x3d, r28	; 61
     978:	dd 91       	ld	r29, X+
     97a:	de bf       	out	0x3e, r29	; 62
     97c:	ff 91       	pop	r31
     97e:	ef 91       	pop	r30
     980:	df 91       	pop	r29
     982:	cf 91       	pop	r28
     984:	bf 91       	pop	r27
     986:	af 91       	pop	r26
     988:	9f 91       	pop	r25
     98a:	8f 91       	pop	r24
     98c:	7f 91       	pop	r23
     98e:	6f 91       	pop	r22
     990:	5f 91       	pop	r21
     992:	4f 91       	pop	r20
     994:	3f 91       	pop	r19
     996:	2f 91       	pop	r18
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	cf 90       	pop	r12
     9a4:	bf 90       	pop	r11
     9a6:	af 90       	pop	r10
     9a8:	9f 90       	pop	r9
     9aa:	8f 90       	pop	r8
     9ac:	7f 90       	pop	r7
     9ae:	6f 90       	pop	r6
     9b0:	5f 90       	pop	r5
     9b2:	4f 90       	pop	r4
     9b4:	3f 90       	pop	r3
     9b6:	2f 90       	pop	r2
     9b8:	1f 90       	pop	r1
     9ba:	0f 90       	pop	r0
     9bc:	0f be       	out	0x3f, r0	; 63
     9be:	0f 90       	pop	r0

	asm volatile ( "ret" );
     9c0:	08 95       	ret

000009c2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     9c2:	0f 92       	push	r0
     9c4:	0f b6       	in	r0, 0x3f	; 63
     9c6:	f8 94       	cli
     9c8:	0f 92       	push	r0
     9ca:	1f 92       	push	r1
     9cc:	11 24       	eor	r1, r1
     9ce:	2f 92       	push	r2
     9d0:	3f 92       	push	r3
     9d2:	4f 92       	push	r4
     9d4:	5f 92       	push	r5
     9d6:	6f 92       	push	r6
     9d8:	7f 92       	push	r7
     9da:	8f 92       	push	r8
     9dc:	9f 92       	push	r9
     9de:	af 92       	push	r10
     9e0:	bf 92       	push	r11
     9e2:	cf 92       	push	r12
     9e4:	df 92       	push	r13
     9e6:	ef 92       	push	r14
     9e8:	ff 92       	push	r15
     9ea:	0f 93       	push	r16
     9ec:	1f 93       	push	r17
     9ee:	2f 93       	push	r18
     9f0:	3f 93       	push	r19
     9f2:	4f 93       	push	r20
     9f4:	5f 93       	push	r21
     9f6:	6f 93       	push	r22
     9f8:	7f 93       	push	r23
     9fa:	8f 93       	push	r24
     9fc:	9f 93       	push	r25
     9fe:	af 93       	push	r26
     a00:	bf 93       	push	r27
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	ef 93       	push	r30
     a08:	ff 93       	push	r31
     a0a:	a0 91 07 04 	lds	r26, 0x0407
     a0e:	b0 91 08 04 	lds	r27, 0x0408
     a12:	0d b6       	in	r0, 0x3d	; 61
     a14:	0d 92       	st	X+, r0
     a16:	0e b6       	in	r0, 0x3e	; 62
     a18:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     a1a:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <xTaskIncrementTick>
     a1e:	88 23       	and	r24, r24
     a20:	11 f0       	breq	.+4      	; 0xa26 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     a22:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     a26:	a0 91 07 04 	lds	r26, 0x0407
     a2a:	b0 91 08 04 	lds	r27, 0x0408
     a2e:	cd 91       	ld	r28, X+
     a30:	cd bf       	out	0x3d, r28	; 61
     a32:	dd 91       	ld	r29, X+
     a34:	de bf       	out	0x3e, r29	; 62
     a36:	ff 91       	pop	r31
     a38:	ef 91       	pop	r30
     a3a:	df 91       	pop	r29
     a3c:	cf 91       	pop	r28
     a3e:	bf 91       	pop	r27
     a40:	af 91       	pop	r26
     a42:	9f 91       	pop	r25
     a44:	8f 91       	pop	r24
     a46:	7f 91       	pop	r23
     a48:	6f 91       	pop	r22
     a4a:	5f 91       	pop	r21
     a4c:	4f 91       	pop	r20
     a4e:	3f 91       	pop	r19
     a50:	2f 91       	pop	r18
     a52:	1f 91       	pop	r17
     a54:	0f 91       	pop	r16
     a56:	ff 90       	pop	r15
     a58:	ef 90       	pop	r14
     a5a:	df 90       	pop	r13
     a5c:	cf 90       	pop	r12
     a5e:	bf 90       	pop	r11
     a60:	af 90       	pop	r10
     a62:	9f 90       	pop	r9
     a64:	8f 90       	pop	r8
     a66:	7f 90       	pop	r7
     a68:	6f 90       	pop	r6
     a6a:	5f 90       	pop	r5
     a6c:	4f 90       	pop	r4
     a6e:	3f 90       	pop	r3
     a70:	2f 90       	pop	r2
     a72:	1f 90       	pop	r1
     a74:	0f 90       	pop	r0
     a76:	0f be       	out	0x3f, r0	; 63
     a78:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a7a:	08 95       	ret

00000a7c <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     a7c:	0e 94 e1 04 	call	0x9c2	; 0x9c2 <vPortYieldFromTick>
		asm volatile ( "reti" );
     a80:	18 95       	reti

00000a82 <prvIsQueueEmpty>:

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     a82:	0f b6       	in	r0, 0x3f	; 63
     a84:	f8 94       	cli
     a86:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     a88:	fc 01       	movw	r30, r24
     a8a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     a8c:	0f 90       	pop	r0
     a8e:	0f be       	out	0x3f, r0	; 63

	taskENTER_CRITICAL();
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
		{
			xReturn = pdTRUE;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	91 11       	cpse	r25, r1
     a94:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
     a96:	08 95       	ret

00000a98 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     a98:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     a9a:	44 8d       	ldd	r20, Z+28	; 0x1c
     a9c:	44 23       	and	r20, r20
     a9e:	c1 f0       	breq	.+48     	; 0xad0 <prvCopyDataFromQueue+0x38>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     aa0:	26 81       	ldd	r18, Z+6	; 0x06
     aa2:	37 81       	ldd	r19, Z+7	; 0x07
     aa4:	24 0f       	add	r18, r20
     aa6:	31 1d       	adc	r19, r1
     aa8:	37 83       	std	Z+7, r19	; 0x07
     aaa:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     aac:	a2 81       	ldd	r26, Z+2	; 0x02
     aae:	b3 81       	ldd	r27, Z+3	; 0x03
     ab0:	2a 17       	cp	r18, r26
     ab2:	3b 07       	cpc	r19, r27
     ab4:	20 f0       	brcs	.+8      	; 0xabe <prvCopyDataFromQueue+0x26>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     ab6:	20 81       	ld	r18, Z
     ab8:	31 81       	ldd	r19, Z+1	; 0x01
     aba:	37 83       	std	Z+7, r19	; 0x07
     abc:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     abe:	36 81       	ldd	r19, Z+6	; 0x06
     ac0:	27 81       	ldd	r18, Z+7	; 0x07
     ac2:	86 2f       	mov	r24, r22
     ac4:	97 2f       	mov	r25, r23
     ac6:	63 2f       	mov	r22, r19
     ac8:	72 2f       	mov	r23, r18
     aca:	50 e0       	ldi	r21, 0x00	; 0
     acc:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <memcpy>
     ad0:	08 95       	ret

00000ad2 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     ad2:	ef 92       	push	r14
     ad4:	ff 92       	push	r15
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	cf 93       	push	r28
     adc:	8c 01       	movw	r16, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
     ae4:	fc 01       	movw	r30, r24
     ae6:	c6 8d       	ldd	r28, Z+30	; 0x1e

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     ae8:	1c 16       	cp	r1, r28
     aea:	cc f4       	brge	.+50     	; 0xb1e <prvUnlockQueue+0x4c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     aec:	81 89       	ldd	r24, Z+17	; 0x11
     aee:	88 23       	and	r24, r24
     af0:	31 f4       	brne	.+12     	; 0xafe <prvUnlockQueue+0x2c>
     af2:	15 c0       	rjmp	.+42     	; 0xb1e <prvUnlockQueue+0x4c>
     af4:	f8 01       	movw	r30, r16
     af6:	81 89       	ldd	r24, Z+17	; 0x11
     af8:	88 23       	and	r24, r24
     afa:	41 f4       	brne	.+16     	; 0xb0c <prvUnlockQueue+0x3a>
     afc:	10 c0       	rjmp	.+32     	; 0xb1e <prvUnlockQueue+0x4c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     afe:	0f 2e       	mov	r0, r31
     b00:	f1 e1       	ldi	r31, 0x11	; 17
     b02:	ef 2e       	mov	r14, r31
     b04:	ff 24       	eor	r15, r15
     b06:	f0 2d       	mov	r31, r0
     b08:	e0 0e       	add	r14, r16
     b0a:	f1 1e       	adc	r15, r17
     b0c:	c7 01       	movw	r24, r14
     b0e:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     b12:	88 23       	and	r24, r24
     b14:	11 f0       	breq	.+4      	; 0xb1a <prvUnlockQueue+0x48>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
     b16:	0e 94 55 10 	call	0x20aa	; 0x20aa <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
     b1a:	c1 50       	subi	r28, 0x01	; 1
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
     b1c:	59 f7       	brne	.-42     	; 0xaf4 <prvUnlockQueue+0x22>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
     b1e:	8f ef       	ldi	r24, 0xFF	; 255
     b20:	f8 01       	movw	r30, r16
     b22:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     b24:	0f 90       	pop	r0
     b26:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     b28:	0f b6       	in	r0, 0x3f	; 63
     b2a:	f8 94       	cli
     b2c:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
     b2e:	f8 01       	movw	r30, r16
     b30:	c5 8d       	ldd	r28, Z+29	; 0x1d

		while( cRxLock > queueLOCKED_UNMODIFIED )
     b32:	1c 16       	cp	r1, r28
     b34:	c4 f4       	brge	.+48     	; 0xb66 <prvUnlockQueue+0x94>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     b36:	80 85       	ldd	r24, Z+8	; 0x08
     b38:	88 23       	and	r24, r24
     b3a:	31 f4       	brne	.+12     	; 0xb48 <prvUnlockQueue+0x76>
     b3c:	14 c0       	rjmp	.+40     	; 0xb66 <prvUnlockQueue+0x94>
     b3e:	f8 01       	movw	r30, r16
     b40:	80 85       	ldd	r24, Z+8	; 0x08
     b42:	88 23       	and	r24, r24
     b44:	39 f4       	brne	.+14     	; 0xb54 <prvUnlockQueue+0x82>
     b46:	0f c0       	rjmp	.+30     	; 0xb66 <prvUnlockQueue+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     b48:	ee 24       	eor	r14, r14
     b4a:	ff 24       	eor	r15, r15
     b4c:	68 94       	set
     b4e:	e3 f8       	bld	r14, 3
     b50:	e0 0e       	add	r14, r16
     b52:	f1 1e       	adc	r15, r17
     b54:	c7 01       	movw	r24, r14
     b56:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     b5a:	88 23       	and	r24, r24
     b5c:	11 f0       	breq	.+4      	; 0xb62 <prvUnlockQueue+0x90>
				{
					vTaskMissedYield();
     b5e:	0e 94 55 10 	call	0x20aa	; 0x20aa <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
     b62:	c1 50       	subi	r28, 0x01	; 1
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
     b64:	61 f7       	brne	.-40     	; 0xb3e <prvUnlockQueue+0x6c>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
     b66:	8f ef       	ldi	r24, 0xFF	; 255
     b68:	f8 01       	movw	r30, r16
     b6a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     b6c:	0f 90       	pop	r0
     b6e:	0f be       	out	0x3f, r0	; 63
}
     b70:	cf 91       	pop	r28
     b72:	1f 91       	pop	r17
     b74:	0f 91       	pop	r16
     b76:	ff 90       	pop	r15
     b78:	ef 90       	pop	r14
     b7a:	08 95       	ret

00000b7c <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     b7c:	0f 93       	push	r16
     b7e:	1f 93       	push	r17
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	ec 01       	movw	r28, r24
     b86:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     b88:	0a 8d       	ldd	r16, Y+26	; 0x1a

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     b8a:	4c 8d       	ldd	r20, Y+28	; 0x1c
     b8c:	44 23       	and	r20, r20
     b8e:	61 f4       	brne	.+24     	; 0xba8 <prvCopyDataToQueue+0x2c>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b90:	88 81       	ld	r24, Y
     b92:	99 81       	ldd	r25, Y+1	; 0x01
     b94:	00 97       	sbiw	r24, 0x00	; 0
     b96:	09 f0       	breq	.+2      	; 0xb9a <prvCopyDataToQueue+0x1e>
     b98:	42 c0       	rjmp	.+132    	; 0xc1e <prvCopyDataToQueue+0xa2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     b9a:	8a 81       	ldd	r24, Y+2	; 0x02
     b9c:	9b 81       	ldd	r25, Y+3	; 0x03
     b9e:	0e 94 bc 10 	call	0x2178	; 0x2178 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     ba2:	1b 82       	std	Y+3, r1	; 0x03
     ba4:	1a 82       	std	Y+2, r1	; 0x02
     ba6:	42 c0       	rjmp	.+132    	; 0xc2c <prvCopyDataToQueue+0xb0>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     ba8:	11 23       	and	r17, r17
     baa:	b9 f4       	brne	.+46     	; 0xbda <prvCopyDataToQueue+0x5e>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     bac:	8c 81       	ldd	r24, Y+4	; 0x04
     bae:	9d 81       	ldd	r25, Y+5	; 0x05
     bb0:	50 e0       	ldi	r21, 0x00	; 0
     bb2:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     bb6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     bb8:	8c 81       	ldd	r24, Y+4	; 0x04
     bba:	9d 81       	ldd	r25, Y+5	; 0x05
     bbc:	82 0f       	add	r24, r18
     bbe:	91 1d       	adc	r25, r1
     bc0:	9d 83       	std	Y+5, r25	; 0x05
     bc2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     bc4:	2a 81       	ldd	r18, Y+2	; 0x02
     bc6:	3b 81       	ldd	r19, Y+3	; 0x03
     bc8:	82 17       	cp	r24, r18
     bca:	93 07       	cpc	r25, r19
     bcc:	50 f1       	brcs	.+84     	; 0xc22 <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     bce:	88 81       	ld	r24, Y
     bd0:	99 81       	ldd	r25, Y+1	; 0x01
     bd2:	9d 83       	std	Y+5, r25	; 0x05
     bd4:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     bd6:	80 e0       	ldi	r24, 0x00	; 0
     bd8:	29 c0       	rjmp	.+82     	; 0xc2c <prvCopyDataToQueue+0xb0>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     bda:	8e 81       	ldd	r24, Y+6	; 0x06
     bdc:	9f 81       	ldd	r25, Y+7	; 0x07
     bde:	50 e0       	ldi	r21, 0x00	; 0
     be0:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     be4:	4c 8d       	ldd	r20, Y+28	; 0x1c
     be6:	50 e0       	ldi	r21, 0x00	; 0
     be8:	50 95       	com	r21
     bea:	41 95       	neg	r20
     bec:	5f 4f       	sbci	r21, 0xFF	; 255
     bee:	8e 81       	ldd	r24, Y+6	; 0x06
     bf0:	9f 81       	ldd	r25, Y+7	; 0x07
     bf2:	84 0f       	add	r24, r20
     bf4:	95 1f       	adc	r25, r21
     bf6:	9f 83       	std	Y+7, r25	; 0x07
     bf8:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     bfa:	28 81       	ld	r18, Y
     bfc:	39 81       	ldd	r19, Y+1	; 0x01
     bfe:	82 17       	cp	r24, r18
     c00:	93 07       	cpc	r25, r19
     c02:	30 f4       	brcc	.+12     	; 0xc10 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     c04:	8a 81       	ldd	r24, Y+2	; 0x02
     c06:	9b 81       	ldd	r25, Y+3	; 0x03
     c08:	84 0f       	add	r24, r20
     c0a:	95 1f       	adc	r25, r21
     c0c:	9f 83       	std	Y+7, r25	; 0x07
     c0e:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     c10:	12 30       	cpi	r17, 0x02	; 2
     c12:	49 f4       	brne	.+18     	; 0xc26 <prvCopyDataToQueue+0xaa>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     c14:	00 23       	and	r16, r16
     c16:	49 f0       	breq	.+18     	; 0xc2a <prvCopyDataToQueue+0xae>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
     c18:	01 50       	subi	r16, 0x01	; 1
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	07 c0       	rjmp	.+14     	; 0xc2c <prvCopyDataToQueue+0xb0>
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	05 c0       	rjmp	.+10     	; 0xc2c <prvCopyDataToQueue+0xb0>
     c22:	80 e0       	ldi	r24, 0x00	; 0
     c24:	03 c0       	rjmp	.+6      	; 0xc2c <prvCopyDataToQueue+0xb0>
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	01 c0       	rjmp	.+2      	; 0xc2c <prvCopyDataToQueue+0xb0>
     c2a:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     c2c:	0f 5f       	subi	r16, 0xFF	; 255
     c2e:	0a 8f       	std	Y+26, r16	; 0x1a

	return xReturn;
}
     c30:	df 91       	pop	r29
     c32:	cf 91       	pop	r28
     c34:	1f 91       	pop	r17
     c36:	0f 91       	pop	r16
     c38:	08 95       	ret

00000c3a <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     c3a:	cf 93       	push	r28
     c3c:	df 93       	push	r29
     c3e:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     c46:	48 81       	ld	r20, Y
     c48:	59 81       	ldd	r21, Y+1	; 0x01
     c4a:	2b 8d       	ldd	r18, Y+27	; 0x1b
     c4c:	30 e0       	ldi	r19, 0x00	; 0
     c4e:	ec 8d       	ldd	r30, Y+28	; 0x1c
     c50:	f0 e0       	ldi	r31, 0x00	; 0
     c52:	2e 9f       	mul	r18, r30
     c54:	c0 01       	movw	r24, r0
     c56:	2f 9f       	mul	r18, r31
     c58:	90 0d       	add	r25, r0
     c5a:	3e 9f       	mul	r19, r30
     c5c:	90 0d       	add	r25, r0
     c5e:	11 24       	eor	r1, r1
     c60:	84 0f       	add	r24, r20
     c62:	95 1f       	adc	r25, r21
     c64:	9b 83       	std	Y+3, r25	; 0x03
     c66:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     c68:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     c6a:	5d 83       	std	Y+5, r21	; 0x05
     c6c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     c6e:	c9 01       	movw	r24, r18
     c70:	01 97       	sbiw	r24, 0x01	; 1
     c72:	e8 9f       	mul	r30, r24
     c74:	90 01       	movw	r18, r0
     c76:	e9 9f       	mul	r30, r25
     c78:	30 0d       	add	r19, r0
     c7a:	f8 9f       	mul	r31, r24
     c7c:	30 0d       	add	r19, r0
     c7e:	11 24       	eor	r1, r1
     c80:	24 0f       	add	r18, r20
     c82:	35 1f       	adc	r19, r21
     c84:	3f 83       	std	Y+7, r19	; 0x07
     c86:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
     c88:	8f ef       	ldi	r24, 0xFF	; 255
     c8a:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
     c8c:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     c8e:	66 23       	and	r22, r22
     c90:	61 f4       	brne	.+24     	; 0xcaa <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c92:	88 85       	ldd	r24, Y+8	; 0x08
     c94:	88 23       	and	r24, r24
     c96:	89 f0       	breq	.+34     	; 0xcba <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c98:	ce 01       	movw	r24, r28
     c9a:	08 96       	adiw	r24, 0x08	; 8
     c9c:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     ca0:	88 23       	and	r24, r24
     ca2:	59 f0       	breq	.+22     	; 0xcba <xQueueGenericReset+0x80>
				{
					queueYIELD_IF_USING_PREEMPTION();
     ca4:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
     ca8:	08 c0       	rjmp	.+16     	; 0xcba <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     caa:	ce 01       	movw	r24, r28
     cac:	08 96       	adiw	r24, 0x08	; 8
     cae:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     cb2:	ce 01       	movw	r24, r28
     cb4:	41 96       	adiw	r24, 0x11	; 17
     cb6:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     cba:	0f 90       	pop	r0
     cbc:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     cbe:	81 e0       	ldi	r24, 0x01	; 1
     cc0:	df 91       	pop	r29
     cc2:	cf 91       	pop	r28
     cc4:	08 95       	ret

00000cc6 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
     cc6:	0f 93       	push	r16
     cc8:	1f 93       	push	r17
     cca:	cf 93       	push	r28
     ccc:	df 93       	push	r29
     cce:	08 2f       	mov	r16, r24
     cd0:	16 2f       	mov	r17, r22
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
     cd2:	66 23       	and	r22, r22
     cd4:	21 f0       	breq	.+8      	; 0xcde <xQueueGenericCreate+0x18>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cd6:	68 9f       	mul	r22, r24
     cd8:	c0 01       	movw	r24, r0
     cda:	11 24       	eor	r1, r1
     cdc:	02 c0       	rjmp	.+4      	; 0xce2 <xQueueGenericCreate+0x1c>
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
     cde:	80 e0       	ldi	r24, 0x00	; 0
     ce0:	90 e0       	ldi	r25, 0x00	; 0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     ce2:	4f 96       	adiw	r24, 0x1f	; 31
     ce4:	0e 94 5e 02 	call	0x4bc	; 0x4bc <pvPortMalloc>
     ce8:	ec 01       	movw	r28, r24

		if( pxNewQueue != NULL )
     cea:	00 97       	sbiw	r24, 0x00	; 0
     cec:	71 f0       	breq	.+28     	; 0xd0a <xQueueGenericCreate+0x44>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
     cee:	11 23       	and	r17, r17
     cf0:	19 f4       	brne	.+6      	; 0xcf8 <xQueueGenericCreate+0x32>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     cf2:	99 83       	std	Y+1, r25	; 0x01
     cf4:	88 83       	st	Y, r24
     cf6:	03 c0       	rjmp	.+6      	; 0xcfe <xQueueGenericCreate+0x38>

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
     cf8:	4f 96       	adiw	r24, 0x1f	; 31
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
     cfa:	99 83       	std	Y+1, r25	; 0x01
     cfc:	88 83       	st	Y, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
     cfe:	0b 8f       	std	Y+27, r16	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
     d00:	1c 8f       	std	Y+28, r17	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     d02:	ce 01       	movw	r24, r28
     d04:	61 e0       	ldi	r22, 0x01	; 1
     d06:	0e 94 1d 06 	call	0xc3a	; 0xc3a <xQueueGenericReset>

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
     d0a:	8c 2f       	mov	r24, r28
     d0c:	9d 2f       	mov	r25, r29
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	0f 91       	pop	r16
     d16:	08 95       	ret

00000d18 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     d18:	8f 92       	push	r8
     d1a:	9f 92       	push	r9
     d1c:	bf 92       	push	r11
     d1e:	cf 92       	push	r12
     d20:	df 92       	push	r13
     d22:	ef 92       	push	r14
     d24:	ff 92       	push	r15
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	00 d0       	rcall	.+0      	; 0xd30 <xQueueGenericSend+0x18>
     d30:	00 d0       	rcall	.+0      	; 0xd32 <xQueueGenericSend+0x1a>
     d32:	0f 92       	push	r0
     d34:	cd b7       	in	r28, 0x3d	; 61
     d36:	de b7       	in	r29, 0x3e	; 62
     d38:	8c 01       	movw	r16, r24
     d3a:	4b 01       	movw	r8, r22
     d3c:	5d 83       	std	Y+5, r21	; 0x05
     d3e:	4c 83       	std	Y+4, r20	; 0x04
     d40:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     d42:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d44:	bb 24       	eor	r11, r11
     d46:	b3 94       	inc	r11
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     d48:	cc 24       	eor	r12, r12
     d4a:	dd 24       	eor	r13, r13
     d4c:	68 94       	set
     d4e:	c3 f8       	bld	r12, 3
     d50:	c8 0e       	add	r12, r24
     d52:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     d54:	0f b6       	in	r0, 0x3f	; 63
     d56:	f8 94       	cli
     d58:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     d5a:	f8 01       	movw	r30, r16
     d5c:	92 8d       	ldd	r25, Z+26	; 0x1a
     d5e:	83 8d       	ldd	r24, Z+27	; 0x1b
     d60:	98 17       	cp	r25, r24
     d62:	18 f0       	brcs	.+6      	; 0xd6a <xQueueGenericSend+0x52>
     d64:	f2 e0       	ldi	r31, 0x02	; 2
     d66:	ef 16       	cp	r14, r31
     d68:	d1 f4       	brne	.+52     	; 0xd9e <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     d6a:	c8 01       	movw	r24, r16
     d6c:	b4 01       	movw	r22, r8
     d6e:	4e 2d       	mov	r20, r14
     d70:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     d74:	f8 01       	movw	r30, r16
     d76:	91 89       	ldd	r25, Z+17	; 0x11
     d78:	99 23       	and	r25, r25
     d7a:	49 f0       	breq	.+18     	; 0xd8e <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     d7c:	c8 01       	movw	r24, r16
     d7e:	41 96       	adiw	r24, 0x11	; 17
     d80:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     d84:	88 23       	and	r24, r24
     d86:	39 f0       	breq	.+14     	; 0xd96 <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     d88:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
     d8c:	04 c0       	rjmp	.+8      	; 0xd96 <xQueueGenericSend+0x7e>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     d8e:	88 23       	and	r24, r24
     d90:	11 f0       	breq	.+4      	; 0xd96 <xQueueGenericSend+0x7e>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     d92:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     d96:	0f 90       	pop	r0
     d98:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     d9a:	81 e0       	ldi	r24, 0x01	; 1
     d9c:	52 c0       	rjmp	.+164    	; 0xe42 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     d9e:	8c 81       	ldd	r24, Y+4	; 0x04
     da0:	9d 81       	ldd	r25, Y+5	; 0x05
     da2:	00 97       	sbiw	r24, 0x00	; 0
     da4:	21 f4       	brne	.+8      	; 0xdae <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     da6:	0f 90       	pop	r0
     da8:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     daa:	80 e0       	ldi	r24, 0x00	; 0
     dac:	4a c0       	rjmp	.+148    	; 0xe42 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
     dae:	ff 20       	and	r15, r15
     db0:	29 f4       	brne	.+10     	; 0xdbc <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     db2:	ce 01       	movw	r24, r28
     db4:	01 96       	adiw	r24, 0x01	; 1
     db6:	0e 94 15 10 	call	0x202a	; 0x202a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     dba:	fb 2c       	mov	r15, r11
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     dbc:	0f 90       	pop	r0
     dbe:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     dc0:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     dc4:	0f b6       	in	r0, 0x3f	; 63
     dc6:	f8 94       	cli
     dc8:	0f 92       	push	r0
     dca:	f8 01       	movw	r30, r16
     dcc:	85 8d       	ldd	r24, Z+29	; 0x1d
     dce:	8f 3f       	cpi	r24, 0xFF	; 255
     dd0:	09 f4       	brne	.+2      	; 0xdd4 <xQueueGenericSend+0xbc>
     dd2:	15 8e       	std	Z+29, r1	; 0x1d
     dd4:	f8 01       	movw	r30, r16
     dd6:	86 8d       	ldd	r24, Z+30	; 0x1e
     dd8:	8f 3f       	cpi	r24, 0xFF	; 255
     dda:	09 f4       	brne	.+2      	; 0xdde <xQueueGenericSend+0xc6>
     ddc:	16 8e       	std	Z+30, r1	; 0x1e
     dde:	0f 90       	pop	r0
     de0:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     de2:	ce 01       	movw	r24, r28
     de4:	01 96       	adiw	r24, 0x01	; 1
     de6:	be 01       	movw	r22, r28
     de8:	6c 5f       	subi	r22, 0xFC	; 252
     dea:	7f 4f       	sbci	r23, 0xFF	; 255
     dec:	0e 94 20 10 	call	0x2040	; 0x2040 <xTaskCheckForTimeOut>
     df0:	88 23       	and	r24, r24
     df2:	09 f5       	brne	.+66     	; 0xe36 <xQueueGenericSend+0x11e>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     df4:	0f b6       	in	r0, 0x3f	; 63
     df6:	f8 94       	cli
     df8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     dfa:	f8 01       	movw	r30, r16
     dfc:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     dfe:	0f 90       	pop	r0
     e00:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     e02:	f8 01       	movw	r30, r16
     e04:	83 8d       	ldd	r24, Z+27	; 0x1b
     e06:	98 17       	cp	r25, r24
     e08:	81 f4       	brne	.+32     	; 0xe2a <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e0a:	6c 81       	ldd	r22, Y+4	; 0x04
     e0c:	7d 81       	ldd	r23, Y+5	; 0x05
     e0e:	c6 01       	movw	r24, r12
     e10:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     e14:	c8 01       	movw	r24, r16
     e16:	0e 94 69 05 	call	0xad2	; 0xad2 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     e1a:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
     e1e:	88 23       	and	r24, r24
     e20:	09 f0       	breq	.+2      	; 0xe24 <xQueueGenericSend+0x10c>
     e22:	98 cf       	rjmp	.-208    	; 0xd54 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
     e24:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
     e28:	95 cf       	rjmp	.-214    	; 0xd54 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e2a:	c8 01       	movw	r24, r16
     e2c:	0e 94 69 05 	call	0xad2	; 0xad2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e30:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
     e34:	8f cf       	rjmp	.-226    	; 0xd54 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     e36:	c8 01       	movw	r24, r16
     e38:	0e 94 69 05 	call	0xad2	; 0xad2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e3c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     e40:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e42:	0f 90       	pop	r0
     e44:	0f 90       	pop	r0
     e46:	0f 90       	pop	r0
     e48:	0f 90       	pop	r0
     e4a:	0f 90       	pop	r0
     e4c:	df 91       	pop	r29
     e4e:	cf 91       	pop	r28
     e50:	1f 91       	pop	r17
     e52:	0f 91       	pop	r16
     e54:	ff 90       	pop	r15
     e56:	ef 90       	pop	r14
     e58:	df 90       	pop	r13
     e5a:	cf 90       	pop	r12
     e5c:	bf 90       	pop	r11
     e5e:	9f 90       	pop	r9
     e60:	8f 90       	pop	r8
     e62:	08 95       	ret

00000e64 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
     e64:	cf 93       	push	r28
     e66:	df 93       	push	r29
     e68:	48 2f       	mov	r20, r24
	Queue_t *pxNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	60 e0       	ldi	r22, 0x00	; 0
     e6e:	0e 94 63 06 	call	0xcc6	; 0xcc6 <xQueueGenericCreate>
     e72:	ec 01       	movw	r28, r24

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
		if( pxNewQueue != NULL )
     e74:	00 97       	sbiw	r24, 0x00	; 0
     e76:	61 f0       	breq	.+24     	; 0xe90 <xQueueCreateMutex+0x2c>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
     e78:	1b 82       	std	Y+3, r1	; 0x03
     e7a:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
     e7c:	19 82       	std	Y+1, r1	; 0x01
     e7e:	18 82       	st	Y, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
     e80:	1e 82       	std	Y+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	70 e0       	ldi	r23, 0x00	; 0
     e86:	40 e0       	ldi	r20, 0x00	; 0
     e88:	50 e0       	ldi	r21, 0x00	; 0
     e8a:	20 e0       	ldi	r18, 0x00	; 0
     e8c:	0e 94 8c 06 	call	0xd18	; 0xd18 <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
     e90:	8c 2f       	mov	r24, r28
     e92:	9d 2f       	mov	r25, r29
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	08 95       	ret

00000e9a <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     e9a:	ef 92       	push	r14
     e9c:	ff 92       	push	r15
     e9e:	0f 93       	push	r16
     ea0:	1f 93       	push	r17
     ea2:	cf 93       	push	r28
     ea4:	8c 01       	movw	r16, r24
     ea6:	7a 01       	movw	r14, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     ea8:	fc 01       	movw	r30, r24
     eaa:	92 8d       	ldd	r25, Z+26	; 0x1a
     eac:	83 8d       	ldd	r24, Z+27	; 0x1b
     eae:	98 17       	cp	r25, r24
     eb0:	10 f0       	brcs	.+4      	; 0xeb6 <xQueueGenericSendFromISR+0x1c>
     eb2:	22 30       	cpi	r18, 0x02	; 2
     eb4:	f1 f4       	brne	.+60     	; 0xef2 <xQueueGenericSendFromISR+0x58>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     eb6:	f8 01       	movw	r30, r16
     eb8:	c6 8d       	ldd	r28, Z+30	; 0x1e
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     eba:	c8 01       	movw	r24, r16
     ebc:	42 2f       	mov	r20, r18
     ebe:	0e 94 be 05 	call	0xb7c	; 0xb7c <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     ec2:	cf 3f       	cpi	r28, 0xFF	; 255
     ec4:	89 f4       	brne	.+34     	; 0xee8 <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ec6:	f8 01       	movw	r30, r16
     ec8:	81 89       	ldd	r24, Z+17	; 0x11
     eca:	88 23       	and	r24, r24
     ecc:	a1 f0       	breq	.+40     	; 0xef6 <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ece:	c8 01       	movw	r24, r16
     ed0:	41 96       	adiw	r24, 0x11	; 17
     ed2:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     ed6:	88 23       	and	r24, r24
     ed8:	81 f0       	breq	.+32     	; 0xefa <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     eda:	e1 14       	cp	r14, r1
     edc:	f1 04       	cpc	r15, r1
     ede:	79 f0       	breq	.+30     	; 0xefe <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     ee0:	81 e0       	ldi	r24, 0x01	; 1
     ee2:	f7 01       	movw	r30, r14
     ee4:	80 83       	st	Z, r24
     ee6:	0c c0       	rjmp	.+24     	; 0xf00 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     ee8:	cf 5f       	subi	r28, 0xFF	; 255
     eea:	f8 01       	movw	r30, r16
     eec:	c6 8f       	std	Z+30, r28	; 0x1e
			}

			xReturn = pdPASS;
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	07 c0       	rjmp	.+14     	; 0xf00 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	05 c0       	rjmp	.+10     	; 0xf00 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     ef6:	81 e0       	ldi	r24, 0x01	; 1
     ef8:	03 c0       	rjmp	.+6      	; 0xf00 <xQueueGenericSendFromISR+0x66>
     efa:	81 e0       	ldi	r24, 0x01	; 1
     efc:	01 c0       	rjmp	.+2      	; 0xf00 <xQueueGenericSendFromISR+0x66>
     efe:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f00:	cf 91       	pop	r28
     f02:	1f 91       	pop	r17
     f04:	0f 91       	pop	r16
     f06:	ff 90       	pop	r15
     f08:	ef 90       	pop	r14
     f0a:	08 95       	ret

00000f0c <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     f0c:	cf 93       	push	r28
     f0e:	df 93       	push	r29
     f10:	fc 01       	movw	r30, r24
     f12:	eb 01       	movw	r28, r22
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     f14:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
     f16:	93 8d       	ldd	r25, Z+27	; 0x1b
     f18:	89 17       	cp	r24, r25
     f1a:	b8 f4       	brcc	.+46     	; 0xf4a <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     f1c:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     f1e:	8f 5f       	subi	r24, 0xFF	; 255
     f20:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     f22:	9f 3f       	cpi	r25, 0xFF	; 255
     f24:	71 f4       	brne	.+28     	; 0xf42 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     f26:	81 89       	ldd	r24, Z+17	; 0x11
     f28:	88 23       	and	r24, r24
     f2a:	89 f0       	breq	.+34     	; 0xf4e <xQueueGiveFromISR+0x42>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     f2c:	cf 01       	movw	r24, r30
     f2e:	41 96       	adiw	r24, 0x11	; 17
     f30:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     f34:	88 23       	and	r24, r24
     f36:	69 f0       	breq	.+26     	; 0xf52 <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     f38:	20 97       	sbiw	r28, 0x00	; 0
     f3a:	69 f0       	breq	.+26     	; 0xf56 <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	88 83       	st	Y, r24
     f40:	0b c0       	rjmp	.+22     	; 0xf58 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     f42:	9f 5f       	subi	r25, 0xFF	; 255
     f44:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	07 c0       	rjmp	.+14     	; 0xf58 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     f4a:	80 e0       	ldi	r24, 0x00	; 0
     f4c:	05 c0       	rjmp	.+10     	; 0xf58 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     f4e:	81 e0       	ldi	r24, 0x01	; 1
     f50:	03 c0       	rjmp	.+6      	; 0xf58 <xQueueGiveFromISR+0x4c>
     f52:	81 e0       	ldi	r24, 0x01	; 1
     f54:	01 c0       	rjmp	.+2      	; 0xf58 <xQueueGiveFromISR+0x4c>
     f56:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f58:	df 91       	pop	r29
     f5a:	cf 91       	pop	r28
     f5c:	08 95       	ret

00000f5e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     f5e:	8f 92       	push	r8
     f60:	9f 92       	push	r9
     f62:	af 92       	push	r10
     f64:	bf 92       	push	r11
     f66:	cf 92       	push	r12
     f68:	df 92       	push	r13
     f6a:	ef 92       	push	r14
     f6c:	ff 92       	push	r15
     f6e:	0f 93       	push	r16
     f70:	1f 93       	push	r17
     f72:	cf 93       	push	r28
     f74:	df 93       	push	r29
     f76:	00 d0       	rcall	.+0      	; 0xf78 <xQueueGenericReceive+0x1a>
     f78:	00 d0       	rcall	.+0      	; 0xf7a <xQueueGenericReceive+0x1c>
     f7a:	0f 92       	push	r0
     f7c:	cd b7       	in	r28, 0x3d	; 61
     f7e:	de b7       	in	r29, 0x3e	; 62
     f80:	7c 01       	movw	r14, r24
     f82:	4b 01       	movw	r8, r22
     f84:	5d 83       	std	Y+5, r21	; 0x05
     f86:	4c 83       	std	Y+4, r20	; 0x04
     f88:	c2 2e       	mov	r12, r18
BaseType_t xEntryTimeSet = pdFALSE;
     f8a:	00 e0       	ldi	r16, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     f8c:	dd 24       	eor	r13, r13
     f8e:	d3 94       	inc	r13
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f90:	0f 2e       	mov	r0, r31
     f92:	f1 e1       	ldi	r31, 0x11	; 17
     f94:	af 2e       	mov	r10, r31
     f96:	bb 24       	eor	r11, r11
     f98:	f0 2d       	mov	r31, r0
     f9a:	a8 0e       	add	r10, r24
     f9c:	b9 1e       	adc	r11, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     f9e:	0f b6       	in	r0, 0x3f	; 63
     fa0:	f8 94       	cli
     fa2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     fa4:	f7 01       	movw	r30, r14
     fa6:	12 8d       	ldd	r17, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     fa8:	11 23       	and	r17, r17
     faa:	99 f1       	breq	.+102    	; 0x1012 <xQueueGenericReceive+0xb4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     fac:	a6 80       	ldd	r10, Z+6	; 0x06
     fae:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     fb0:	c7 01       	movw	r24, r14
     fb2:	b4 01       	movw	r22, r8
     fb4:	0e 94 4c 05 	call	0xa98	; 0xa98 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     fb8:	cc 20       	and	r12, r12
     fba:	c9 f4       	brne	.+50     	; 0xfee <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     fbc:	11 50       	subi	r17, 0x01	; 1
     fbe:	f7 01       	movw	r30, r14
     fc0:	12 8f       	std	Z+26, r17	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     fc2:	80 81       	ld	r24, Z
     fc4:	91 81       	ldd	r25, Z+1	; 0x01
     fc6:	00 97       	sbiw	r24, 0x00	; 0
     fc8:	29 f4       	brne	.+10     	; 0xfd4 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     fca:	0e 94 15 11 	call	0x222a	; 0x222a <pvTaskIncrementMutexHeldCount>
     fce:	f7 01       	movw	r30, r14
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     fd4:	f7 01       	movw	r30, r14
     fd6:	80 85       	ldd	r24, Z+8	; 0x08
     fd8:	88 23       	and	r24, r24
     fda:	b9 f0       	breq	.+46     	; 0x100a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     fdc:	c7 01       	movw	r24, r14
     fde:	08 96       	adiw	r24, 0x08	; 8
     fe0:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
     fe4:	88 23       	and	r24, r24
     fe6:	89 f0       	breq	.+34     	; 0x100a <xQueueGenericReceive+0xac>
						{
							queueYIELD_IF_USING_PREEMPTION();
     fe8:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
     fec:	0e c0       	rjmp	.+28     	; 0x100a <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     fee:	f7 01       	movw	r30, r14
     ff0:	b7 82       	std	Z+7, r11	; 0x07
     ff2:	a6 82       	std	Z+6, r10	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ff4:	81 89       	ldd	r24, Z+17	; 0x11
     ff6:	88 23       	and	r24, r24
     ff8:	41 f0       	breq	.+16     	; 0x100a <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ffa:	c7 01       	movw	r24, r14
     ffc:	41 96       	adiw	r24, 0x11	; 17
     ffe:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
    1002:	88 23       	and	r24, r24
    1004:	11 f0       	breq	.+4      	; 0x100a <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1006:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    100a:	0f 90       	pop	r0
    100c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	61 c0       	rjmp	.+194    	; 0x10d4 <xQueueGenericReceive+0x176>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1012:	8c 81       	ldd	r24, Y+4	; 0x04
    1014:	9d 81       	ldd	r25, Y+5	; 0x05
    1016:	00 97       	sbiw	r24, 0x00	; 0
    1018:	21 f4       	brne	.+8      	; 0x1022 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    101a:	0f 90       	pop	r0
    101c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	59 c0       	rjmp	.+178    	; 0x10d4 <xQueueGenericReceive+0x176>
				}
				else if( xEntryTimeSet == pdFALSE )
    1022:	00 23       	and	r16, r16
    1024:	29 f4       	brne	.+10     	; 0x1030 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1026:	ce 01       	movw	r24, r28
    1028:	01 96       	adiw	r24, 0x01	; 1
    102a:	0e 94 15 10 	call	0x202a	; 0x202a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    102e:	0d 2d       	mov	r16, r13
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1034:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1038:	0f b6       	in	r0, 0x3f	; 63
    103a:	f8 94       	cli
    103c:	0f 92       	push	r0
    103e:	f7 01       	movw	r30, r14
    1040:	85 8d       	ldd	r24, Z+29	; 0x1d
    1042:	8f 3f       	cpi	r24, 0xFF	; 255
    1044:	09 f4       	brne	.+2      	; 0x1048 <xQueueGenericReceive+0xea>
    1046:	15 8e       	std	Z+29, r1	; 0x1d
    1048:	f7 01       	movw	r30, r14
    104a:	86 8d       	ldd	r24, Z+30	; 0x1e
    104c:	8f 3f       	cpi	r24, 0xFF	; 255
    104e:	09 f4       	brne	.+2      	; 0x1052 <xQueueGenericReceive+0xf4>
    1050:	16 8e       	std	Z+30, r1	; 0x1e
    1052:	0f 90       	pop	r0
    1054:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1056:	ce 01       	movw	r24, r28
    1058:	01 96       	adiw	r24, 0x01	; 1
    105a:	be 01       	movw	r22, r28
    105c:	6c 5f       	subi	r22, 0xFC	; 252
    105e:	7f 4f       	sbci	r23, 0xFF	; 255
    1060:	0e 94 20 10 	call	0x2040	; 0x2040 <xTaskCheckForTimeOut>
    1064:	88 23       	and	r24, r24
    1066:	51 f5       	brne	.+84     	; 0x10bc <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1068:	c7 01       	movw	r24, r14
    106a:	0e 94 41 05 	call	0xa82	; 0xa82 <prvIsQueueEmpty>
    106e:	88 23       	and	r24, r24
    1070:	f9 f0       	breq	.+62     	; 0x10b0 <xQueueGenericReceive+0x152>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1072:	f7 01       	movw	r30, r14
    1074:	80 81       	ld	r24, Z
    1076:	91 81       	ldd	r25, Z+1	; 0x01
    1078:	00 97       	sbiw	r24, 0x00	; 0
    107a:	51 f4       	brne	.+20     	; 0x1090 <xQueueGenericReceive+0x132>
					{
						taskENTER_CRITICAL();
    107c:	0f b6       	in	r0, 0x3f	; 63
    107e:	f8 94       	cli
    1080:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1082:	f7 01       	movw	r30, r14
    1084:	82 81       	ldd	r24, Z+2	; 0x02
    1086:	93 81       	ldd	r25, Z+3	; 0x03
    1088:	0e 94 5e 10 	call	0x20bc	; 0x20bc <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    108c:	0f 90       	pop	r0
    108e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1090:	6c 81       	ldd	r22, Y+4	; 0x04
    1092:	7d 81       	ldd	r23, Y+5	; 0x05
    1094:	c5 01       	movw	r24, r10
    1096:	0e 94 65 0f 	call	0x1eca	; 0x1eca <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    109a:	c7 01       	movw	r24, r14
    109c:	0e 94 69 05 	call	0xad2	; 0xad2 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    10a0:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
    10a4:	88 23       	and	r24, r24
    10a6:	09 f0       	breq	.+2      	; 0x10aa <xQueueGenericReceive+0x14c>
    10a8:	7a cf       	rjmp	.-268    	; 0xf9e <xQueueGenericReceive+0x40>
				{
					portYIELD_WITHIN_API();
    10aa:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
    10ae:	77 cf       	rjmp	.-274    	; 0xf9e <xQueueGenericReceive+0x40>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    10b0:	c7 01       	movw	r24, r14
    10b2:	0e 94 69 05 	call	0xad2	; 0xad2 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    10b6:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
    10ba:	71 cf       	rjmp	.-286    	; 0xf9e <xQueueGenericReceive+0x40>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    10bc:	c7 01       	movw	r24, r14
    10be:	0e 94 69 05 	call	0xad2	; 0xad2 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    10c2:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    10c6:	c7 01       	movw	r24, r14
    10c8:	0e 94 41 05 	call	0xa82	; 0xa82 <prvIsQueueEmpty>
    10cc:	88 23       	and	r24, r24
    10ce:	09 f4       	brne	.+2      	; 0x10d2 <xQueueGenericReceive+0x174>
    10d0:	66 cf       	rjmp	.-308    	; 0xf9e <xQueueGenericReceive+0x40>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    10d2:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    10d4:	0f 90       	pop	r0
    10d6:	0f 90       	pop	r0
    10d8:	0f 90       	pop	r0
    10da:	0f 90       	pop	r0
    10dc:	0f 90       	pop	r0
    10de:	df 91       	pop	r29
    10e0:	cf 91       	pop	r28
    10e2:	1f 91       	pop	r17
    10e4:	0f 91       	pop	r16
    10e6:	ff 90       	pop	r15
    10e8:	ef 90       	pop	r14
    10ea:	df 90       	pop	r13
    10ec:	cf 90       	pop	r12
    10ee:	bf 90       	pop	r11
    10f0:	af 90       	pop	r10
    10f2:	9f 90       	pop	r9
    10f4:	8f 90       	pop	r8
    10f6:	08 95       	ret

000010f8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    10f8:	ef 92       	push	r14
    10fa:	ff 92       	push	r15
    10fc:	0f 93       	push	r16
    10fe:	1f 93       	push	r17
    1100:	cf 93       	push	r28
    1102:	df 93       	push	r29
    1104:	8c 01       	movw	r16, r24
    1106:	7a 01       	movw	r14, r20
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1108:	fc 01       	movw	r30, r24
    110a:	c2 8d       	ldd	r28, Z+26	; 0x1a

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    110c:	cc 23       	and	r28, r28
    110e:	e9 f0       	breq	.+58     	; 0x114a <xQueueReceiveFromISR+0x52>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1110:	d5 8d       	ldd	r29, Z+29	; 0x1d

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1112:	0e 94 4c 05 	call	0xa98	; 0xa98 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1116:	c1 50       	subi	r28, 0x01	; 1
    1118:	f8 01       	movw	r30, r16
    111a:	c2 8f       	std	Z+26, r28	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    111c:	df 3f       	cpi	r29, 0xFF	; 255
    111e:	81 f4       	brne	.+32     	; 0x1140 <xQueueReceiveFromISR+0x48>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1120:	80 85       	ldd	r24, Z+8	; 0x08
    1122:	88 23       	and	r24, r24
    1124:	a1 f0       	breq	.+40     	; 0x114e <xQueueReceiveFromISR+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1126:	c8 01       	movw	r24, r16
    1128:	08 96       	adiw	r24, 0x08	; 8
    112a:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <xTaskRemoveFromEventList>
    112e:	88 23       	and	r24, r24
    1130:	81 f0       	breq	.+32     	; 0x1152 <xQueueReceiveFromISR+0x5a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1132:	e1 14       	cp	r14, r1
    1134:	f1 04       	cpc	r15, r1
    1136:	79 f0       	breq	.+30     	; 0x1156 <xQueueReceiveFromISR+0x5e>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1138:	81 e0       	ldi	r24, 0x01	; 1
    113a:	f7 01       	movw	r30, r14
    113c:	80 83       	st	Z, r24
    113e:	0c c0       	rjmp	.+24     	; 0x1158 <xQueueReceiveFromISR+0x60>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1140:	df 5f       	subi	r29, 0xFF	; 255
    1142:	f8 01       	movw	r30, r16
    1144:	d5 8f       	std	Z+29, r29	; 0x1d
			}

			xReturn = pdPASS;
    1146:	81 e0       	ldi	r24, 0x01	; 1
    1148:	07 c0       	rjmp	.+14     	; 0x1158 <xQueueReceiveFromISR+0x60>
		}
		else
		{
			xReturn = pdFAIL;
    114a:	80 e0       	ldi	r24, 0x00	; 0
    114c:	05 c0       	rjmp	.+10     	; 0x1158 <xQueueReceiveFromISR+0x60>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
			}

			xReturn = pdPASS;
    114e:	81 e0       	ldi	r24, 0x01	; 1
    1150:	03 c0       	rjmp	.+6      	; 0x1158 <xQueueReceiveFromISR+0x60>
    1152:	81 e0       	ldi	r24, 0x01	; 1
    1154:	01 c0       	rjmp	.+2      	; 0x1158 <xQueueReceiveFromISR+0x60>
    1156:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1158:	df 91       	pop	r29
    115a:	cf 91       	pop	r28
    115c:	1f 91       	pop	r17
    115e:	0f 91       	pop	r16
    1160:	ff 90       	pop	r15
    1162:	ef 90       	pop	r14
    1164:	08 95       	ret

00001166 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1166:	0f 93       	push	r16
    1168:	1f 93       	push	r17
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	ec 01       	movw	r28, r24
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1170:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1172:	88 23       	and	r24, r24
    1174:	49 f0       	breq	.+18     	; 0x1188 <xQueuePeekFromISR+0x22>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1176:	0e 81       	ldd	r16, Y+6	; 0x06
    1178:	1f 81       	ldd	r17, Y+7	; 0x07
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    117a:	ce 01       	movw	r24, r28
    117c:	0e 94 4c 05 	call	0xa98	; 0xa98 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1180:	1f 83       	std	Y+7, r17	; 0x07
    1182:	0e 83       	std	Y+6, r16	; 0x06

			xReturn = pdPASS;
    1184:	81 e0       	ldi	r24, 0x01	; 1
    1186:	01 c0       	rjmp	.+2      	; 0x118a <xQueuePeekFromISR+0x24>
		}
		else
		{
			xReturn = pdFAIL;
    1188:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	1f 91       	pop	r17
    1190:	0f 91       	pop	r16
    1192:	08 95       	ret

00001194 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1194:	0f b6       	in	r0, 0x3f	; 63
    1196:	f8 94       	cli
    1198:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    119a:	fc 01       	movw	r30, r24
    119c:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    119e:	0f 90       	pop	r0
    11a0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    11a2:	08 95       	ret

000011a4 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    11a4:	fc 01       	movw	r30, r24
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    11a6:	0f b6       	in	r0, 0x3f	; 63
    11a8:	f8 94       	cli
    11aa:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    11ac:	92 8d       	ldd	r25, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
    11ae:	0f 90       	pop	r0
    11b0:	0f be       	out	0x3f, r0	; 63
	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    11b2:	83 8d       	ldd	r24, Z+27	; 0x1b
	}
	taskEXIT_CRITICAL();

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    11b4:	89 1b       	sub	r24, r25
    11b6:	08 95       	ret

000011b8 <uxQueueMessagesWaitingFromISR>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    11b8:	fc 01       	movw	r30, r24
    11ba:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    11bc:	08 95       	ret

000011be <xQueueIsQueueEmptyFromISR>:
BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
    11be:	fc 01       	movw	r30, r24
    11c0:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	91 11       	cpse	r25, r1
    11c6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    11c8:	08 95       	ret

000011ca <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    11ca:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
    11cc:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    11ce:	81 e0       	ldi	r24, 0x01	; 1
    11d0:	93 8d       	ldd	r25, Z+27	; 0x1b
    11d2:	29 13       	cpse	r18, r25
    11d4:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    11d6:	08 95       	ret

000011d8 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    11d8:	dc 01       	movw	r26, r24

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
    11da:	80 91 76 04 	lds	r24, 0x0476
    11de:	90 91 77 04 	lds	r25, 0x0477
    11e2:	00 97       	sbiw	r24, 0x00	; 0
    11e4:	51 f0       	breq	.+20     	; 0x11fa <vQueueAddToRegistry+0x22>
    11e6:	ea e7       	ldi	r30, 0x7A	; 122
    11e8:	f4 e0       	ldi	r31, 0x04	; 4
    11ea:	21 e0       	ldi	r18, 0x01	; 1
    11ec:	30 e0       	ldi	r19, 0x00	; 0
    11ee:	a9 01       	movw	r20, r18
    11f0:	80 81       	ld	r24, Z
    11f2:	91 81       	ldd	r25, Z+1	; 0x01
    11f4:	00 97       	sbiw	r24, 0x00	; 0
    11f6:	79 f4       	brne	.+30     	; 0x1216 <vQueueAddToRegistry+0x3e>
    11f8:	02 c0       	rjmp	.+4      	; 0x11fe <vQueueAddToRegistry+0x26>
    11fa:	40 e0       	ldi	r20, 0x00	; 0
    11fc:	50 e0       	ldi	r21, 0x00	; 0
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
    11fe:	fa 01       	movw	r30, r20
    1200:	ee 0f       	add	r30, r30
    1202:	ff 1f       	adc	r31, r31
    1204:	ee 0f       	add	r30, r30
    1206:	ff 1f       	adc	r31, r31
    1208:	ea 58       	subi	r30, 0x8A	; 138
    120a:	fb 4f       	sbci	r31, 0xFB	; 251
    120c:	71 83       	std	Z+1, r23	; 0x01
    120e:	60 83       	st	Z, r22
				xQueueRegistry[ ux ].xHandle = xQueue;
    1210:	b3 83       	std	Z+3, r27	; 0x03
    1212:	a2 83       	std	Z+2, r26	; 0x02

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
    1214:	08 95       	ret
    1216:	2f 5f       	subi	r18, 0xFF	; 255
    1218:	3f 4f       	sbci	r19, 0xFF	; 255
    121a:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    121c:	28 30       	cpi	r18, 0x08	; 8
    121e:	31 05       	cpc	r19, r1
    1220:	31 f7       	brne	.-52     	; 0x11ee <vQueueAddToRegistry+0x16>
    1222:	08 95       	ret

00001224 <pcQueueGetName>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1224:	ac 01       	movw	r20, r24

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1226:	80 91 78 04 	lds	r24, 0x0478
    122a:	90 91 79 04 	lds	r25, 0x0479
    122e:	84 17       	cp	r24, r20
    1230:	95 07       	cpc	r25, r21
    1232:	59 f0       	breq	.+22     	; 0x124a <pcQueueGetName+0x26>
    1234:	ec e7       	ldi	r30, 0x7C	; 124
    1236:	f4 e0       	ldi	r31, 0x04	; 4
    1238:	21 e0       	ldi	r18, 0x01	; 1
    123a:	30 e0       	ldi	r19, 0x00	; 0
    123c:	b9 01       	movw	r22, r18
    123e:	80 81       	ld	r24, Z
    1240:	91 81       	ldd	r25, Z+1	; 0x01
    1242:	84 17       	cp	r24, r20
    1244:	95 07       	cpc	r25, r21
    1246:	69 f4       	brne	.+26     	; 0x1262 <pcQueueGetName+0x3e>
    1248:	02 c0       	rjmp	.+4      	; 0x124e <pcQueueGetName+0x2a>
    124a:	60 e0       	ldi	r22, 0x00	; 0
    124c:	70 e0       	ldi	r23, 0x00	; 0
			{
				pcReturn = xQueueRegistry[ ux ].pcQueueName;
    124e:	fb 01       	movw	r30, r22
    1250:	ee 0f       	add	r30, r30
    1252:	ff 1f       	adc	r31, r31
    1254:	ee 0f       	add	r30, r30
    1256:	ff 1f       	adc	r31, r31
    1258:	ea 58       	subi	r30, 0x8A	; 138
    125a:	fb 4f       	sbci	r31, 0xFB	; 251
    125c:	80 81       	ld	r24, Z
    125e:	91 81       	ldd	r25, Z+1	; 0x01
				break;
    1260:	08 95       	ret
    1262:	2f 5f       	subi	r18, 0xFF	; 255
    1264:	3f 4f       	sbci	r19, 0xFF	; 255
    1266:	34 96       	adiw	r30, 0x04	; 4
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */

		/* Note there is nothing here to protect against another task adding or
		removing entries from the registry while it is being searched. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    1268:	28 30       	cpi	r18, 0x08	; 8
    126a:	31 05       	cpc	r19, r1
    126c:	39 f7       	brne	.-50     	; 0x123c <pcQueueGetName+0x18>
#if ( configQUEUE_REGISTRY_SIZE > 0 )

	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
	UBaseType_t ux;
	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
    126e:	80 e0       	ldi	r24, 0x00	; 0
    1270:	90 e0       	ldi	r25, 0x00	; 0
				mtCOVERAGE_TEST_MARKER();
			}
		}

		return pcReturn;
	}
    1272:	08 95       	ret

00001274 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
    1274:	ac 01       	movw	r20, r24

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
    1276:	80 91 78 04 	lds	r24, 0x0478
    127a:	90 91 79 04 	lds	r25, 0x0479
    127e:	84 17       	cp	r24, r20
    1280:	95 07       	cpc	r25, r21
    1282:	59 f0       	breq	.+22     	; 0x129a <vQueueUnregisterQueue+0x26>
    1284:	ec e7       	ldi	r30, 0x7C	; 124
    1286:	f4 e0       	ldi	r31, 0x04	; 4
    1288:	21 e0       	ldi	r18, 0x01	; 1
    128a:	30 e0       	ldi	r19, 0x00	; 0
    128c:	b9 01       	movw	r22, r18
    128e:	80 81       	ld	r24, Z
    1290:	91 81       	ldd	r25, Z+1	; 0x01
    1292:	84 17       	cp	r24, r20
    1294:	95 07       	cpc	r25, r21
    1296:	79 f4       	brne	.+30     	; 0x12b6 <vQueueUnregisterQueue+0x42>
    1298:	02 c0       	rjmp	.+4      	; 0x129e <vQueueUnregisterQueue+0x2a>
    129a:	60 e0       	ldi	r22, 0x00	; 0
    129c:	70 e0       	ldi	r23, 0x00	; 0
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
    129e:	fb 01       	movw	r30, r22
    12a0:	ee 0f       	add	r30, r30
    12a2:	ff 1f       	adc	r31, r31
    12a4:	ee 0f       	add	r30, r30
    12a6:	ff 1f       	adc	r31, r31
    12a8:	ea 58       	subi	r30, 0x8A	; 138
    12aa:	fb 4f       	sbci	r31, 0xFB	; 251
    12ac:	11 82       	std	Z+1, r1	; 0x01
    12ae:	10 82       	st	Z, r1

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
    12b0:	13 82       	std	Z+3, r1	; 0x03
    12b2:	12 82       	std	Z+2, r1	; 0x02
				break;
    12b4:	08 95       	ret
    12b6:	2f 5f       	subi	r18, 0xFF	; 255
    12b8:	3f 4f       	sbci	r19, 0xFF	; 255
    12ba:	34 96       	adiw	r30, 0x04	; 4
	{
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
    12bc:	28 30       	cpi	r18, 0x08	; 8
    12be:	31 05       	cpc	r19, r1
    12c0:	29 f7       	brne	.-54     	; 0x128c <vQueueUnregisterQueue+0x18>
    12c2:	08 95       	ret

000012c4 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
    12ca:	0e 94 3a 09 	call	0x1274	; 0x1274 <vQueueUnregisterQueue>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    12ce:	ce 01       	movw	r24, r28
    12d0:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    12d4:	df 91       	pop	r29
    12d6:	cf 91       	pop	r28
    12d8:	08 95       	ret

000012da <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    12da:	fc 01       	movw	r30, r24

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    12dc:	82 85       	ldd	r24, Z+10	; 0x0a
    12de:	93 85       	ldd	r25, Z+11	; 0x0b
    12e0:	24 e0       	ldi	r18, 0x04	; 4
    12e2:	8b 36       	cpi	r24, 0x6B	; 107
    12e4:	92 07       	cpc	r25, r18
    12e6:	61 f4       	brne	.+24     	; 0x1300 <prvTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    12e8:	24 89       	ldd	r18, Z+20	; 0x14
    12ea:	35 89       	ldd	r19, Z+21	; 0x15
    12ec:	84 e0       	ldi	r24, 0x04	; 4
    12ee:	29 35       	cpi	r18, 0x59	; 89
    12f0:	38 07       	cpc	r19, r24
    12f2:	41 f0       	breq	.+16     	; 0x1304 <prvTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
	BaseType_t xReturn = pdFALSE;
    12f4:	81 e0       	ldi	r24, 0x01	; 1
    12f6:	21 15       	cp	r18, r1
    12f8:	31 05       	cpc	r19, r1
    12fa:	29 f0       	breq	.+10     	; 0x1306 <prvTaskIsTaskSuspended+0x2c>
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	08 95       	ret
    1300:	80 e0       	ldi	r24, 0x00	; 0
    1302:	08 95       	ret
    1304:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    1306:	08 95       	ret

00001308 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1308:	e0 91 17 04 	lds	r30, 0x0417
    130c:	f0 91 18 04 	lds	r31, 0x0418
    1310:	80 81       	ld	r24, Z
    1312:	88 23       	and	r24, r24
    1314:	39 f4       	brne	.+14     	; 0x1324 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    1316:	8f ef       	ldi	r24, 0xFF	; 255
    1318:	9f ef       	ldi	r25, 0xFF	; 255
    131a:	90 93 0b 04 	sts	0x040B, r25
    131e:	80 93 0a 04 	sts	0x040A, r24
    1322:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1324:	e0 91 17 04 	lds	r30, 0x0417
    1328:	f0 91 18 04 	lds	r31, 0x0418
    132c:	05 80       	ldd	r0, Z+5	; 0x05
    132e:	f6 81       	ldd	r31, Z+6	; 0x06
    1330:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    1332:	06 80       	ldd	r0, Z+6	; 0x06
    1334:	f7 81       	ldd	r31, Z+7	; 0x07
    1336:	e0 2d       	mov	r30, r0
    1338:	82 81       	ldd	r24, Z+2	; 0x02
    133a:	93 81       	ldd	r25, Z+3	; 0x03
    133c:	90 93 0b 04 	sts	0x040B, r25
    1340:	80 93 0a 04 	sts	0x040A, r24
    1344:	08 95       	ret

00001346 <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    1346:	ef 92       	push	r14
    1348:	ff 92       	push	r15
    134a:	1f 93       	push	r17
    134c:	cf 93       	push	r28
    134e:	df 93       	push	r29
    1350:	ec 01       	movw	r28, r24
    1352:	16 2f       	mov	r17, r22
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    1354:	e0 90 11 04 	lds	r14, 0x0411
    1358:	f0 90 12 04 	lds	r15, 0x0412
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    135c:	80 91 07 04 	lds	r24, 0x0407
    1360:	90 91 08 04 	lds	r25, 0x0408
    1364:	02 96       	adiw	r24, 0x02	; 2
    1366:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    136a:	8f ef       	ldi	r24, 0xFF	; 255
    136c:	cf 3f       	cpi	r28, 0xFF	; 255
    136e:	d8 07       	cpc	r29, r24
    1370:	69 f4       	brne	.+26     	; 0x138c <prvAddCurrentTaskToDelayedList+0x46>
    1372:	11 23       	and	r17, r17
    1374:	59 f0       	breq	.+22     	; 0x138c <prvAddCurrentTaskToDelayedList+0x46>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    1376:	60 91 07 04 	lds	r22, 0x0407
    137a:	70 91 08 04 	lds	r23, 0x0408
    137e:	6e 5f       	subi	r22, 0xFE	; 254
    1380:	7f 4f       	sbci	r23, 0xFF	; 255
    1382:	8b e6       	ldi	r24, 0x6B	; 107
    1384:	94 e0       	ldi	r25, 0x04	; 4
    1386:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    138a:	2f c0       	rjmp	.+94     	; 0x13ea <prvAddCurrentTaskToDelayedList+0xa4>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    138c:	ce 0d       	add	r28, r14
    138e:	df 1d       	adc	r29, r15

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    1390:	e0 91 07 04 	lds	r30, 0x0407
    1394:	f0 91 08 04 	lds	r31, 0x0408
    1398:	d3 83       	std	Z+3, r29	; 0x03
    139a:	c2 83       	std	Z+2, r28	; 0x02

			if( xTimeToWake < xConstTickCount )
    139c:	ce 15       	cp	r28, r14
    139e:	df 05       	cpc	r29, r15
    13a0:	68 f4       	brcc	.+26     	; 0x13bc <prvAddCurrentTaskToDelayedList+0x76>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    13a2:	80 91 15 04 	lds	r24, 0x0415
    13a6:	90 91 16 04 	lds	r25, 0x0416
    13aa:	60 91 07 04 	lds	r22, 0x0407
    13ae:	70 91 08 04 	lds	r23, 0x0408
    13b2:	6e 5f       	subi	r22, 0xFE	; 254
    13b4:	7f 4f       	sbci	r23, 0xFF	; 255
    13b6:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsert>
    13ba:	17 c0       	rjmp	.+46     	; 0x13ea <prvAddCurrentTaskToDelayedList+0xa4>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    13bc:	80 91 17 04 	lds	r24, 0x0417
    13c0:	90 91 18 04 	lds	r25, 0x0418
    13c4:	60 91 07 04 	lds	r22, 0x0407
    13c8:	70 91 08 04 	lds	r23, 0x0408
    13cc:	6e 5f       	subi	r22, 0xFE	; 254
    13ce:	7f 4f       	sbci	r23, 0xFF	; 255
    13d0:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    13d4:	80 91 0a 04 	lds	r24, 0x040A
    13d8:	90 91 0b 04 	lds	r25, 0x040B
    13dc:	c8 17       	cp	r28, r24
    13de:	d9 07       	cpc	r29, r25
    13e0:	20 f4       	brcc	.+8      	; 0x13ea <prvAddCurrentTaskToDelayedList+0xa4>
				{
					xNextTaskUnblockTime = xTimeToWake;
    13e2:	d0 93 0b 04 	sts	0x040B, r29
    13e6:	c0 93 0a 04 	sts	0x040A, r28

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    13ea:	df 91       	pop	r29
    13ec:	cf 91       	pop	r28
    13ee:	1f 91       	pop	r17
    13f0:	ff 90       	pop	r15
    13f2:	ef 90       	pop	r14
    13f4:	08 95       	ret

000013f6 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    13f6:	cf 93       	push	r28
    13f8:	df 93       	push	r29
    13fa:	ec 01       	movw	r28, r24

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    13fc:	8f 89       	ldd	r24, Y+23	; 0x17
    13fe:	98 8d       	ldd	r25, Y+24	; 0x18
    1400:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vPortFree>
			vPortFree( pxTCB );
    1404:	ce 01       	movw	r24, r28
    1406:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    140a:	df 91       	pop	r29
    140c:	cf 91       	pop	r28
    140e:	08 95       	ret

00001410 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    1410:	2f 92       	push	r2
    1412:	3f 92       	push	r3
    1414:	4f 92       	push	r4
    1416:	5f 92       	push	r5
    1418:	6f 92       	push	r6
    141a:	7f 92       	push	r7
    141c:	8f 92       	push	r8
    141e:	9f 92       	push	r9
    1420:	af 92       	push	r10
    1422:	bf 92       	push	r11
    1424:	df 92       	push	r13
    1426:	ef 92       	push	r14
    1428:	ff 92       	push	r15
    142a:	0f 93       	push	r16
    142c:	1f 93       	push	r17
    142e:	cf 93       	push	r28
    1430:	df 93       	push	r29
    1432:	3c 01       	movw	r6, r24
    1434:	5b 01       	movw	r10, r22
    1436:	ea 01       	movw	r28, r20
    1438:	29 01       	movw	r4, r18
    143a:	d0 2e       	mov	r13, r16
    143c:	47 01       	movw	r8, r14
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    143e:	ca 01       	movw	r24, r20
    1440:	0e 94 5e 02 	call	0x4bc	; 0x4bc <pvPortMalloc>
    1444:	7c 01       	movw	r14, r24

			if( pxStack != NULL )
    1446:	00 97       	sbiw	r24, 0x00	; 0
    1448:	09 f4       	brne	.+2      	; 0x144c <xTaskCreate+0x3c>
    144a:	ed c0       	rjmp	.+474    	; 0x1626 <xTaskCreate+0x216>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
    144c:	8a e2       	ldi	r24, 0x2A	; 42
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	0e 94 5e 02 	call	0x4bc	; 0x4bc <pvPortMalloc>
    1454:	8c 01       	movw	r16, r24

				if( pxNewTCB != NULL )
    1456:	00 97       	sbiw	r24, 0x00	; 0
    1458:	81 f0       	breq	.+32     	; 0x147a <xTaskCreate+0x6a>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    145a:	fc 01       	movw	r30, r24
    145c:	f0 8e       	std	Z+24, r15	; 0x18
    145e:	e7 8a       	std	Z+23, r14	; 0x17
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    1460:	21 97       	sbiw	r28, 0x01	; 1
    1462:	17 01       	movw	r2, r14
    1464:	2c 0e       	add	r2, r28
    1466:	3d 1e       	adc	r3, r29
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1468:	f5 01       	movw	r30, r10
    146a:	80 81       	ld	r24, Z
    146c:	f8 01       	movw	r30, r16
    146e:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1470:	f5 01       	movw	r30, r10
    1472:	80 81       	ld	r24, Z
    1474:	88 23       	and	r24, r24
    1476:	31 f4       	brne	.+12     	; 0x1484 <xTaskCreate+0x74>
    1478:	13 c0       	rjmp	.+38     	; 0x14a0 <xTaskCreate+0x90>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    147a:	c7 01       	movw	r24, r14
    147c:	0e 94 fe 02 	call	0x5fc	; 0x5fc <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1480:	8f ef       	ldi	r24, 0xFF	; 255
    1482:	d6 c0       	rjmp	.+428    	; 0x1630 <xTaskCreate+0x220>
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    1484:	e8 01       	movw	r28, r16
    1486:	6a 96       	adiw	r28, 0x1a	; 26
    1488:	d5 01       	movw	r26, r10
    148a:	11 96       	adiw	r26, 0x01	; 1
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    148c:	81 e0       	ldi	r24, 0x01	; 1
#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
    148e:	fd 01       	movw	r30, r26
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    1490:	9d 91       	ld	r25, X+
    1492:	99 93       	st	Y+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
    1494:	90 81       	ld	r25, Z
    1496:	99 23       	and	r25, r25
    1498:	19 f0       	breq	.+6      	; 0x14a0 <xTaskCreate+0x90>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    149a:	8f 5f       	subi	r24, 0xFF	; 255
    149c:	8a 30       	cpi	r24, 0x0A	; 10
    149e:	b9 f7       	brne	.-18     	; 0x148e <xTaskCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    14a0:	f8 01       	movw	r30, r16
    14a2:	12 a2       	lds	r17, 0x92
    14a4:	cd 2d       	mov	r28, r13
    14a6:	c5 30       	cpi	r28, 0x05	; 5
    14a8:	08 f0       	brcs	.+2      	; 0x14ac <xTaskCreate+0x9c>
    14aa:	c4 e0       	ldi	r28, 0x04	; 4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    14ac:	f8 01       	movw	r30, r16
    14ae:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    14b0:	c3 a3       	lds	r28, 0x53
		pxNewTCB->uxMutexesHeld = 0;
    14b2:	14 a2       	lds	r17, 0x94
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    14b4:	ee 24       	eor	r14, r14
    14b6:	ff 24       	eor	r15, r15
    14b8:	68 94       	set
    14ba:	e1 f8       	bld	r14, 1
    14bc:	e0 0e       	add	r14, r16
    14be:	f1 1e       	adc	r15, r17
    14c0:	c7 01       	movw	r24, r14
    14c2:	0e 94 45 03 	call	0x68a	; 0x68a <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    14c6:	c8 01       	movw	r24, r16
    14c8:	0c 96       	adiw	r24, 0x0c	; 12
    14ca:	0e 94 45 03 	call	0x68a	; 0x68a <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    14ce:	f8 01       	movw	r30, r16
    14d0:	11 87       	std	Z+9, r17	; 0x09
    14d2:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    14d4:	85 e0       	ldi	r24, 0x05	; 5
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	8c 1b       	sub	r24, r28
    14da:	91 09       	sbc	r25, r1
    14dc:	95 87       	std	Z+13, r25	; 0x0d
    14de:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    14e0:	13 8b       	std	Z+19, r17	; 0x13
    14e2:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    14e4:	15 a2       	lds	r17, 0x95
    14e6:	16 a2       	lds	r17, 0x96
    14e8:	17 a2       	lds	r17, 0x97
    14ea:	10 a6       	lds	r17, 0xb0
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    14ec:	11 a6       	lds	r17, 0xb1
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    14ee:	c1 01       	movw	r24, r2
    14f0:	b3 01       	movw	r22, r6
    14f2:	a2 01       	movw	r20, r4
    14f4:	0e 94 c2 03 	call	0x784	; 0x784 <pxPortInitialiseStack>
    14f8:	f8 01       	movw	r30, r16
    14fa:	91 83       	std	Z+1, r25	; 0x01
    14fc:	80 83       	st	Z, r24
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
    14fe:	81 14       	cp	r8, r1
    1500:	91 04       	cpc	r9, r1
    1502:	19 f0       	breq	.+6      	; 0x150a <xTaskCreate+0xfa>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    1504:	f4 01       	movw	r30, r8
    1506:	11 83       	std	Z+1, r17	; 0x01
    1508:	00 83       	st	Z, r16

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    150a:	0f b6       	in	r0, 0x3f	; 63
    150c:	f8 94       	cli
    150e:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    1510:	80 91 13 04 	lds	r24, 0x0413
    1514:	8f 5f       	subi	r24, 0xFF	; 255
    1516:	80 93 13 04 	sts	0x0413, r24
		if( pxCurrentTCB == NULL )
    151a:	80 91 07 04 	lds	r24, 0x0407
    151e:	90 91 08 04 	lds	r25, 0x0408
    1522:	00 97       	sbiw	r24, 0x00	; 0
    1524:	09 f0       	breq	.+2      	; 0x1528 <xTaskCreate+0x118>
    1526:	3f c0       	rjmp	.+126    	; 0x15a6 <xTaskCreate+0x196>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    1528:	10 93 08 04 	sts	0x0408, r17
    152c:	00 93 07 04 	sts	0x0407, r16

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    1530:	80 91 13 04 	lds	r24, 0x0413
    1534:	81 30       	cpi	r24, 0x01	; 1
    1536:	09 f0       	breq	.+2      	; 0x153a <xTaskCreate+0x12a>
    1538:	47 c0       	rjmp	.+142    	; 0x15c8 <xTaskCreate+0x1b8>
    153a:	c0 e0       	ldi	r28, 0x00	; 0
    153c:	d0 e0       	ldi	r29, 0x00	; 0
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    153e:	ce 01       	movw	r24, r28
    1540:	88 0f       	add	r24, r24
    1542:	99 1f       	adc	r25, r25
    1544:	88 0f       	add	r24, r24
    1546:	99 1f       	adc	r25, r25
    1548:	88 0f       	add	r24, r24
    154a:	99 1f       	adc	r25, r25
    154c:	8c 0f       	add	r24, r28
    154e:	9d 1f       	adc	r25, r29
    1550:	86 5e       	subi	r24, 0xE6	; 230
    1552:	9b 4f       	sbci	r25, 0xFB	; 251
    1554:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
    1558:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    155a:	c5 30       	cpi	r28, 0x05	; 5
    155c:	d1 05       	cpc	r29, r1
    155e:	79 f7       	brne	.-34     	; 0x153e <xTaskCreate+0x12e>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    1560:	c7 e4       	ldi	r28, 0x47	; 71
    1562:	d4 e0       	ldi	r29, 0x04	; 4
    1564:	ce 01       	movw	r24, r28
    1566:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    156a:	0f 2e       	mov	r0, r31
    156c:	f0 e5       	ldi	r31, 0x50	; 80
    156e:	af 2e       	mov	r10, r31
    1570:	f4 e0       	ldi	r31, 0x04	; 4
    1572:	bf 2e       	mov	r11, r31
    1574:	f0 2d       	mov	r31, r0
    1576:	c5 01       	movw	r24, r10
    1578:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
	vListInitialise( &xPendingReadyList );
    157c:	89 e5       	ldi	r24, 0x59	; 89
    157e:	94 e0       	ldi	r25, 0x04	; 4
    1580:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    1584:	82 e6       	ldi	r24, 0x62	; 98
    1586:	94 e0       	ldi	r25, 0x04	; 4
    1588:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    158c:	8b e6       	ldi	r24, 0x6B	; 107
    158e:	94 e0       	ldi	r25, 0x04	; 4
    1590:	0e 94 37 03 	call	0x66e	; 0x66e <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1594:	d0 93 18 04 	sts	0x0418, r29
    1598:	c0 93 17 04 	sts	0x0417, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    159c:	b0 92 16 04 	sts	0x0416, r11
    15a0:	a0 92 15 04 	sts	0x0415, r10
    15a4:	11 c0       	rjmp	.+34     	; 0x15c8 <xTaskCreate+0x1b8>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    15a6:	80 91 0f 04 	lds	r24, 0x040F
    15aa:	88 23       	and	r24, r24
    15ac:	69 f4       	brne	.+26     	; 0x15c8 <xTaskCreate+0x1b8>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    15ae:	e0 91 07 04 	lds	r30, 0x0407
    15b2:	f0 91 08 04 	lds	r31, 0x0408
    15b6:	96 89       	ldd	r25, Z+22	; 0x16
    15b8:	f8 01       	movw	r30, r16
    15ba:	86 89       	ldd	r24, Z+22	; 0x16
    15bc:	89 17       	cp	r24, r25
    15be:	20 f0       	brcs	.+8      	; 0x15c8 <xTaskCreate+0x1b8>
				{
					pxCurrentTCB = pxNewTCB;
    15c0:	10 93 08 04 	sts	0x0408, r17
    15c4:	00 93 07 04 	sts	0x0407, r16
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    15c8:	80 91 19 04 	lds	r24, 0x0419
    15cc:	8f 5f       	subi	r24, 0xFF	; 255
    15ce:	80 93 19 04 	sts	0x0419, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    15d2:	f8 01       	movw	r30, r16
    15d4:	86 89       	ldd	r24, Z+22	; 0x16
    15d6:	90 91 10 04 	lds	r25, 0x0410
    15da:	98 17       	cp	r25, r24
    15dc:	10 f4       	brcc	.+4      	; 0x15e2 <xTaskCreate+0x1d2>
    15de:	80 93 10 04 	sts	0x0410, r24
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	9c 01       	movw	r18, r24
    15e6:	22 0f       	add	r18, r18
    15e8:	33 1f       	adc	r19, r19
    15ea:	22 0f       	add	r18, r18
    15ec:	33 1f       	adc	r19, r19
    15ee:	22 0f       	add	r18, r18
    15f0:	33 1f       	adc	r19, r19
    15f2:	82 0f       	add	r24, r18
    15f4:	93 1f       	adc	r25, r19
    15f6:	86 5e       	subi	r24, 0xE6	; 230
    15f8:	9b 4f       	sbci	r25, 0xFB	; 251
    15fa:	b7 01       	movw	r22, r14
    15fc:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    1600:	0f 90       	pop	r0
    1602:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    1604:	80 91 0f 04 	lds	r24, 0x040F
    1608:	88 23       	and	r24, r24
    160a:	79 f0       	breq	.+30     	; 0x162a <xTaskCreate+0x21a>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    160c:	e0 91 07 04 	lds	r30, 0x0407
    1610:	f0 91 08 04 	lds	r31, 0x0408
    1614:	96 89       	ldd	r25, Z+22	; 0x16
    1616:	f8 01       	movw	r30, r16
    1618:	86 89       	ldd	r24, Z+22	; 0x16
    161a:	98 17       	cp	r25, r24
    161c:	40 f4       	brcc	.+16     	; 0x162e <xTaskCreate+0x21e>
		{
			taskYIELD_IF_USING_PREEMPTION();
    161e:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    1622:	81 e0       	ldi	r24, 0x01	; 1
    1624:	05 c0       	rjmp	.+10     	; 0x1630 <xTaskCreate+0x220>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1626:	8f ef       	ldi	r24, 0xFF	; 255
    1628:	03 c0       	rjmp	.+6      	; 0x1630 <xTaskCreate+0x220>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
    162a:	81 e0       	ldi	r24, 0x01	; 1
    162c:	01 c0       	rjmp	.+2      	; 0x1630 <xTaskCreate+0x220>
    162e:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
		}

		return xReturn;
	}
    1630:	df 91       	pop	r29
    1632:	cf 91       	pop	r28
    1634:	1f 91       	pop	r17
    1636:	0f 91       	pop	r16
    1638:	ff 90       	pop	r15
    163a:	ef 90       	pop	r14
    163c:	df 90       	pop	r13
    163e:	bf 90       	pop	r11
    1640:	af 90       	pop	r10
    1642:	9f 90       	pop	r9
    1644:	8f 90       	pop	r8
    1646:	7f 90       	pop	r7
    1648:	6f 90       	pop	r6
    164a:	5f 90       	pop	r5
    164c:	4f 90       	pop	r4
    164e:	3f 90       	pop	r3
    1650:	2f 90       	pop	r2
    1652:	08 95       	ret

00001654 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    165c:	0f b6       	in	r0, 0x3f	; 63
    165e:	f8 94       	cli
    1660:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1662:	00 97       	sbiw	r24, 0x00	; 0
    1664:	29 f4       	brne	.+10     	; 0x1670 <vTaskDelete+0x1c>
    1666:	c0 91 07 04 	lds	r28, 0x0407
    166a:	d0 91 08 04 	lds	r29, 0x0408
    166e:	01 c0       	rjmp	.+2      	; 0x1672 <vTaskDelete+0x1e>
    1670:	ec 01       	movw	r28, r24

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1672:	8e 01       	movw	r16, r28
    1674:	0e 5f       	subi	r16, 0xFE	; 254
    1676:	1f 4f       	sbci	r17, 0xFF	; 255
    1678:	c8 01       	movw	r24, r16
    167a:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    167e:	8c 89       	ldd	r24, Y+20	; 0x14
    1680:	9d 89       	ldd	r25, Y+21	; 0x15
    1682:	00 97       	sbiw	r24, 0x00	; 0
    1684:	21 f0       	breq	.+8      	; 0x168e <vTaskDelete+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1686:	ce 01       	movw	r24, r28
    1688:	0c 96       	adiw	r24, 0x0c	; 12
    168a:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    168e:	80 91 19 04 	lds	r24, 0x0419
    1692:	8f 5f       	subi	r24, 0xFF	; 255
    1694:	80 93 19 04 	sts	0x0419, r24

			if( pxTCB == pxCurrentTCB )
    1698:	80 91 07 04 	lds	r24, 0x0407
    169c:	90 91 08 04 	lds	r25, 0x0408
    16a0:	c8 17       	cp	r28, r24
    16a2:	d9 07       	cpc	r29, r25
    16a4:	59 f4       	brne	.+22     	; 0x16bc <vTaskDelete+0x68>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    16a6:	82 e6       	ldi	r24, 0x62	; 98
    16a8:	94 e0       	ldi	r25, 0x04	; 4
    16aa:	b8 01       	movw	r22, r16
    16ac:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    16b0:	80 91 14 04 	lds	r24, 0x0414
    16b4:	8f 5f       	subi	r24, 0xFF	; 255
    16b6:	80 93 14 04 	sts	0x0414, r24
    16ba:	0a c0       	rjmp	.+20     	; 0x16d0 <vTaskDelete+0x7c>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    16bc:	80 91 13 04 	lds	r24, 0x0413
    16c0:	81 50       	subi	r24, 0x01	; 1
    16c2:	80 93 13 04 	sts	0x0413, r24
				prvDeleteTCB( pxTCB );
    16c6:	ce 01       	movw	r24, r28
    16c8:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    16cc:	0e 94 84 09 	call	0x1308	; 0x1308 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    16d0:	0f 90       	pop	r0
    16d2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    16d4:	80 91 0f 04 	lds	r24, 0x040F
    16d8:	88 23       	and	r24, r24
    16da:	49 f0       	breq	.+18     	; 0x16ee <vTaskDelete+0x9a>
		{
			if( pxTCB == pxCurrentTCB )
    16dc:	80 91 07 04 	lds	r24, 0x0407
    16e0:	90 91 08 04 	lds	r25, 0x0408
    16e4:	c8 17       	cp	r28, r24
    16e6:	d9 07       	cpc	r29, r25
    16e8:	11 f4       	brne	.+4      	; 0x16ee <vTaskDelete+0x9a>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    16ea:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    16ee:	df 91       	pop	r29
    16f0:	cf 91       	pop	r28
    16f2:	1f 91       	pop	r17
    16f4:	0f 91       	pop	r16
    16f6:	08 95       	ret

000016f8 <uxTaskPriorityGet>:
	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    16f8:	0f b6       	in	r0, 0x3f	; 63
    16fa:	f8 94       	cli
    16fc:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    16fe:	00 97       	sbiw	r24, 0x00	; 0
    1700:	29 f4       	brne	.+10     	; 0x170c <uxTaskPriorityGet+0x14>
    1702:	e0 91 07 04 	lds	r30, 0x0407
    1706:	f0 91 08 04 	lds	r31, 0x0408
    170a:	01 c0       	rjmp	.+2      	; 0x170e <uxTaskPriorityGet+0x16>
    170c:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();
    170e:	0f 90       	pop	r0
    1710:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
	}
    1712:	86 89       	ldd	r24, Z+22	; 0x16
    1714:	08 95       	ret

00001716 <uxTaskPriorityGetFromISR>:

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1716:	00 97       	sbiw	r24, 0x00	; 0
    1718:	29 f4       	brne	.+10     	; 0x1724 <uxTaskPriorityGetFromISR+0xe>
    171a:	e0 91 07 04 	lds	r30, 0x0407
    171e:	f0 91 08 04 	lds	r31, 0x0408
    1722:	01 c0       	rjmp	.+2      	; 0x1726 <uxTaskPriorityGetFromISR+0x10>
    1724:	fc 01       	movw	r30, r24
			uxReturn = pxTCB->uxPriority;
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
	}
    1726:	86 89       	ldd	r24, Z+22	; 0x16
    1728:	08 95       	ret

0000172a <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    172a:	ef 92       	push	r14
    172c:	ff 92       	push	r15
    172e:	1f 93       	push	r17
    1730:	cf 93       	push	r28
    1732:	df 93       	push	r29
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1734:	65 30       	cpi	r22, 0x05	; 5
    1736:	08 f0       	brcs	.+2      	; 0x173a <vTaskPrioritySet+0x10>
    1738:	64 e0       	ldi	r22, 0x04	; 4
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    173a:	0f b6       	in	r0, 0x3f	; 63
    173c:	f8 94       	cli
    173e:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    1740:	00 97       	sbiw	r24, 0x00	; 0
    1742:	29 f4       	brne	.+10     	; 0x174e <vTaskPrioritySet+0x24>
    1744:	c0 91 07 04 	lds	r28, 0x0407
    1748:	d0 91 08 04 	lds	r29, 0x0408
    174c:	01 c0       	rjmp	.+2      	; 0x1750 <vTaskPrioritySet+0x26>
    174e:	ec 01       	movw	r28, r24

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
    1750:	2b a1       	lds	r18, 0x4b
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    1752:	26 17       	cp	r18, r22
    1754:	09 f4       	brne	.+2      	; 0x1758 <vTaskPrioritySet+0x2e>
    1756:	61 c0       	rjmp	.+194    	; 0x181a <vTaskPrioritySet+0xf0>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    1758:	26 17       	cp	r18, r22
    175a:	88 f4       	brcc	.+34     	; 0x177e <vTaskPrioritySet+0x54>
				{
					if( pxTCB != pxCurrentTCB )
    175c:	80 91 07 04 	lds	r24, 0x0407
    1760:	90 91 08 04 	lds	r25, 0x0408
    1764:	c8 17       	cp	r28, r24
    1766:	d9 07       	cpc	r29, r25
    1768:	a1 f0       	breq	.+40     	; 0x1792 <vTaskPrioritySet+0x68>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    176a:	e0 91 07 04 	lds	r30, 0x0407
    176e:	f0 91 08 04 	lds	r31, 0x0408
						{
							xYieldRequired = pdTRUE;
    1772:	11 e0       	ldi	r17, 0x01	; 1
    1774:	86 89       	ldd	r24, Z+22	; 0x16
    1776:	68 17       	cp	r22, r24
    1778:	68 f4       	brcc	.+26     	; 0x1794 <vTaskPrioritySet+0x6a>
    177a:	10 e0       	ldi	r17, 0x00	; 0
    177c:	0b c0       	rjmp	.+22     	; 0x1794 <vTaskPrioritySet+0x6a>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    177e:	80 91 07 04 	lds	r24, 0x0407
    1782:	90 91 08 04 	lds	r25, 0x0408
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
    1786:	11 e0       	ldi	r17, 0x01	; 1
    1788:	c8 17       	cp	r28, r24
    178a:	d9 07       	cpc	r29, r25
    178c:	19 f0       	breq	.+6      	; 0x1794 <vTaskPrioritySet+0x6a>
    178e:	10 e0       	ldi	r17, 0x00	; 0
    1790:	01 c0       	rjmp	.+2      	; 0x1794 <vTaskPrioritySet+0x6a>

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    1792:	10 e0       	ldi	r17, 0x00	; 0
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    1794:	8e 89       	ldd	r24, Y+22	; 0x16

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
    1796:	28 17       	cp	r18, r24
    1798:	09 f4       	brne	.+2      	; 0x179c <vTaskPrioritySet+0x72>
					{
						pxTCB->uxPriority = uxNewPriority;
    179a:	6e 8b       	std	Y+22, r22	; 0x16
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
    179c:	6b a3       	lds	r22, 0x5b
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    179e:	2c 85       	ldd	r18, Y+12	; 0x0c
    17a0:	3d 85       	ldd	r19, Y+13	; 0x0d
    17a2:	33 23       	and	r19, r19
    17a4:	34 f0       	brlt	.+12     	; 0x17b2 <vTaskPrioritySet+0x88>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17a6:	25 e0       	ldi	r18, 0x05	; 5
    17a8:	30 e0       	ldi	r19, 0x00	; 0
    17aa:	26 1b       	sub	r18, r22
    17ac:	31 09       	sbc	r19, r1
    17ae:	3d 87       	std	Y+13, r19	; 0x0d
    17b0:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	9c 01       	movw	r18, r24
    17b6:	22 0f       	add	r18, r18
    17b8:	33 1f       	adc	r19, r19
    17ba:	22 0f       	add	r18, r18
    17bc:	33 1f       	adc	r19, r19
    17be:	22 0f       	add	r18, r18
    17c0:	33 1f       	adc	r19, r19
    17c2:	82 0f       	add	r24, r18
    17c4:	93 1f       	adc	r25, r19
    17c6:	86 5e       	subi	r24, 0xE6	; 230
    17c8:	9b 4f       	sbci	r25, 0xFB	; 251
    17ca:	2a 85       	ldd	r18, Y+10	; 0x0a
    17cc:	3b 85       	ldd	r19, Y+11	; 0x0b
    17ce:	28 17       	cp	r18, r24
    17d0:	39 07       	cpc	r19, r25
    17d2:	f9 f4       	brne	.+62     	; 0x1812 <vTaskPrioritySet+0xe8>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    17d4:	ee 24       	eor	r14, r14
    17d6:	ff 24       	eor	r15, r15
    17d8:	68 94       	set
    17da:	e1 f8       	bld	r14, 1
    17dc:	ec 0e       	add	r14, r28
    17de:	fd 1e       	adc	r15, r29
    17e0:	c7 01       	movw	r24, r14
    17e2:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    17e6:	8e 89       	ldd	r24, Y+22	; 0x16
    17e8:	90 91 10 04 	lds	r25, 0x0410
    17ec:	98 17       	cp	r25, r24
    17ee:	10 f4       	brcc	.+4      	; 0x17f4 <vTaskPrioritySet+0xca>
    17f0:	80 93 10 04 	sts	0x0410, r24
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	9c 01       	movw	r18, r24
    17f8:	22 0f       	add	r18, r18
    17fa:	33 1f       	adc	r19, r19
    17fc:	22 0f       	add	r18, r18
    17fe:	33 1f       	adc	r19, r19
    1800:	22 0f       	add	r18, r18
    1802:	33 1f       	adc	r19, r19
    1804:	82 0f       	add	r24, r18
    1806:	93 1f       	adc	r25, r19
    1808:	86 5e       	subi	r24, 0xE6	; 230
    180a:	9b 4f       	sbci	r25, 0xFB	; 251
    180c:	b7 01       	movw	r22, r14
    180e:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    1812:	11 23       	and	r17, r17
    1814:	11 f0       	breq	.+4      	; 0x181a <vTaskPrioritySet+0xf0>
				{
					taskYIELD_IF_USING_PREEMPTION();
    1816:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    181a:	0f 90       	pop	r0
    181c:	0f be       	out	0x3f, r0	; 63
	}
    181e:	df 91       	pop	r29
    1820:	cf 91       	pop	r28
    1822:	1f 91       	pop	r17
    1824:	ff 90       	pop	r15
    1826:	ef 90       	pop	r14
    1828:	08 95       	ret

0000182a <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    182a:	0f 93       	push	r16
    182c:	1f 93       	push	r17
    182e:	cf 93       	push	r28
    1830:	df 93       	push	r29
    1832:	ec 01       	movw	r28, r24
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    1834:	00 97       	sbiw	r24, 0x00	; 0
    1836:	b9 f1       	breq	.+110    	; 0x18a6 <vTaskResume+0x7c>
    1838:	80 91 07 04 	lds	r24, 0x0407
    183c:	90 91 08 04 	lds	r25, 0x0408
    1840:	c8 17       	cp	r28, r24
    1842:	d9 07       	cpc	r29, r25
    1844:	81 f1       	breq	.+96     	; 0x18a6 <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    1846:	0f b6       	in	r0, 0x3f	; 63
    1848:	f8 94       	cli
    184a:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    184c:	ce 01       	movw	r24, r28
    184e:	0e 94 6d 09 	call	0x12da	; 0x12da <prvTaskIsTaskSuspended>
    1852:	88 23       	and	r24, r24
    1854:	31 f1       	breq	.+76     	; 0x18a2 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    1856:	8e 01       	movw	r16, r28
    1858:	0e 5f       	subi	r16, 0xFE	; 254
    185a:	1f 4f       	sbci	r17, 0xFF	; 255
    185c:	c8 01       	movw	r24, r16
    185e:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1862:	8e 89       	ldd	r24, Y+22	; 0x16
    1864:	90 91 10 04 	lds	r25, 0x0410
    1868:	98 17       	cp	r25, r24
    186a:	10 f4       	brcc	.+4      	; 0x1870 <vTaskResume+0x46>
    186c:	80 93 10 04 	sts	0x0410, r24
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	9c 01       	movw	r18, r24
    1874:	22 0f       	add	r18, r18
    1876:	33 1f       	adc	r19, r19
    1878:	22 0f       	add	r18, r18
    187a:	33 1f       	adc	r19, r19
    187c:	22 0f       	add	r18, r18
    187e:	33 1f       	adc	r19, r19
    1880:	82 0f       	add	r24, r18
    1882:	93 1f       	adc	r25, r19
    1884:	86 5e       	subi	r24, 0xE6	; 230
    1886:	9b 4f       	sbci	r25, 0xFB	; 251
    1888:	b8 01       	movw	r22, r16
    188a:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    188e:	e0 91 07 04 	lds	r30, 0x0407
    1892:	f0 91 08 04 	lds	r31, 0x0408
    1896:	9e 89       	ldd	r25, Y+22	; 0x16
    1898:	86 89       	ldd	r24, Z+22	; 0x16
    189a:	98 17       	cp	r25, r24
    189c:	10 f0       	brcs	.+4      	; 0x18a2 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    189e:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    18a2:	0f 90       	pop	r0
    18a4:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    18a6:	df 91       	pop	r29
    18a8:	cf 91       	pop	r28
    18aa:	1f 91       	pop	r17
    18ac:	0f 91       	pop	r16
    18ae:	08 95       	ret

000018b0 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    18b0:	ef 92       	push	r14
    18b2:	ff 92       	push	r15
    18b4:	1f 93       	push	r17
    18b6:	cf 93       	push	r28
    18b8:	df 93       	push	r29
    18ba:	ec 01       	movw	r28, r24
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    18bc:	0e 94 6d 09 	call	0x12da	; 0x12da <prvTaskIsTaskSuspended>
    18c0:	88 23       	and	r24, r24
    18c2:	b9 f1       	breq	.+110    	; 0x1932 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    18c4:	80 91 09 04 	lds	r24, 0x0409
    18c8:	88 23       	and	r24, r24
    18ca:	51 f5       	brne	.+84     	; 0x1920 <xTaskResumeFromISR+0x70>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    18cc:	e0 91 07 04 	lds	r30, 0x0407
    18d0:	f0 91 08 04 	lds	r31, 0x0408

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    18d4:	11 e0       	ldi	r17, 0x01	; 1
    18d6:	9e 89       	ldd	r25, Y+22	; 0x16
    18d8:	86 89       	ldd	r24, Z+22	; 0x16
    18da:	98 17       	cp	r25, r24
    18dc:	08 f4       	brcc	.+2      	; 0x18e0 <xTaskResumeFromISR+0x30>
    18de:	10 e0       	ldi	r17, 0x00	; 0
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    18e0:	ee 24       	eor	r14, r14
    18e2:	ff 24       	eor	r15, r15
    18e4:	68 94       	set
    18e6:	e1 f8       	bld	r14, 1
    18e8:	ec 0e       	add	r14, r28
    18ea:	fd 1e       	adc	r15, r29
    18ec:	c7 01       	movw	r24, r14
    18ee:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    18f2:	8e 89       	ldd	r24, Y+22	; 0x16
    18f4:	90 91 10 04 	lds	r25, 0x0410
    18f8:	98 17       	cp	r25, r24
    18fa:	10 f4       	brcc	.+4      	; 0x1900 <xTaskResumeFromISR+0x50>
    18fc:	80 93 10 04 	sts	0x0410, r24
    1900:	90 e0       	ldi	r25, 0x00	; 0
    1902:	9c 01       	movw	r18, r24
    1904:	22 0f       	add	r18, r18
    1906:	33 1f       	adc	r19, r19
    1908:	22 0f       	add	r18, r18
    190a:	33 1f       	adc	r19, r19
    190c:	22 0f       	add	r18, r18
    190e:	33 1f       	adc	r19, r19
    1910:	82 0f       	add	r24, r18
    1912:	93 1f       	adc	r25, r19
    1914:	86 5e       	subi	r24, 0xE6	; 230
    1916:	9b 4f       	sbci	r25, 0xFB	; 251
    1918:	b7 01       	movw	r22, r14
    191a:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    191e:	0a c0       	rjmp	.+20     	; 0x1934 <xTaskResumeFromISR+0x84>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    1920:	be 01       	movw	r22, r28
    1922:	64 5f       	subi	r22, 0xF4	; 244
    1924:	7f 4f       	sbci	r23, 0xFF	; 255
    1926:	89 e5       	ldi	r24, 0x59	; 89
    1928:	94 e0       	ldi	r25, 0x04	; 4
    192a:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
    192e:	10 e0       	ldi	r17, 0x00	; 0
    1930:	01 c0       	rjmp	.+2      	; 0x1934 <xTaskResumeFromISR+0x84>
    1932:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    1934:	81 2f       	mov	r24, r17
    1936:	df 91       	pop	r29
    1938:	cf 91       	pop	r28
    193a:	1f 91       	pop	r17
    193c:	ff 90       	pop	r15
    193e:	ef 90       	pop	r14
    1940:	08 95       	ret

00001942 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1942:	ef 92       	push	r14
    1944:	ff 92       	push	r15
    1946:	0f 93       	push	r16
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    1948:	8f e2       	ldi	r24, 0x2F	; 47
    194a:	9e e0       	ldi	r25, 0x0E	; 14
    194c:	63 e7       	ldi	r22, 0x73	; 115
    194e:	70 e0       	ldi	r23, 0x00	; 0
    1950:	48 ec       	ldi	r20, 0xC8	; 200
    1952:	50 e0       	ldi	r21, 0x00	; 0
    1954:	20 e0       	ldi	r18, 0x00	; 0
    1956:	30 e0       	ldi	r19, 0x00	; 0
    1958:	00 e0       	ldi	r16, 0x00	; 0
    195a:	0f 2e       	mov	r0, r31
    195c:	f4 e7       	ldi	r31, 0x74	; 116
    195e:	ef 2e       	mov	r14, r31
    1960:	f4 e0       	ldi	r31, 0x04	; 4
    1962:	ff 2e       	mov	r15, r31
    1964:	f0 2d       	mov	r31, r0
    1966:	0e 94 08 0a 	call	0x1410	; 0x1410 <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    196a:	81 30       	cpi	r24, 0x01	; 1
    196c:	81 f4       	brne	.+32     	; 0x198e <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    196e:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    1970:	8f ef       	ldi	r24, 0xFF	; 255
    1972:	9f ef       	ldi	r25, 0xFF	; 255
    1974:	90 93 0b 04 	sts	0x040B, r25
    1978:	80 93 0a 04 	sts	0x040A, r24
		xSchedulerRunning = pdTRUE;
    197c:	81 e0       	ldi	r24, 0x01	; 1
    197e:	80 93 0f 04 	sts	0x040F, r24
		xTickCount = ( TickType_t ) 0U;
    1982:	10 92 12 04 	sts	0x0412, r1
    1986:	10 92 11 04 	sts	0x0411, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    198a:	0e 94 52 04 	call	0x8a4	; 0x8a4 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    198e:	0f 91       	pop	r16
    1990:	ff 90       	pop	r15
    1992:	ef 90       	pop	r14
    1994:	08 95       	ret

00001996 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1996:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1998:	10 92 0f 04 	sts	0x040F, r1
	vPortEndScheduler();
    199c:	0e 94 87 04 	call	0x90e	; 0x90e <vPortEndScheduler>
}
    19a0:	08 95       	ret

000019a2 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    19a2:	80 91 09 04 	lds	r24, 0x0409
    19a6:	8f 5f       	subi	r24, 0xFF	; 255
    19a8:	80 93 09 04 	sts	0x0409, r24
}
    19ac:	08 95       	ret

000019ae <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    19ae:	0f b6       	in	r0, 0x3f	; 63
    19b0:	f8 94       	cli
    19b2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    19b4:	80 91 11 04 	lds	r24, 0x0411
    19b8:	90 91 12 04 	lds	r25, 0x0412
	}
	portTICK_TYPE_EXIT_CRITICAL();
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    19c0:	08 95       	ret

000019c2 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
    19c2:	80 91 11 04 	lds	r24, 0x0411
    19c6:	90 91 12 04 	lds	r25, 0x0412
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    19ca:	08 95       	ret

000019cc <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    19cc:	80 91 13 04 	lds	r24, 0x0413
}
    19d0:	08 95       	ret

000019d2 <pcTaskGetName>:
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    19d2:	00 97       	sbiw	r24, 0x00	; 0
    19d4:	21 f4       	brne	.+8      	; 0x19de <pcTaskGetName+0xc>
    19d6:	80 91 07 04 	lds	r24, 0x0407
    19da:	90 91 08 04 	lds	r25, 0x0408
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    19de:	49 96       	adiw	r24, 0x19	; 25
}
    19e0:	08 95       	ret

000019e2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    19e2:	cf 92       	push	r12
    19e4:	df 92       	push	r13
    19e6:	ef 92       	push	r14
    19e8:	ff 92       	push	r15
    19ea:	0f 93       	push	r16
    19ec:	1f 93       	push	r17
    19ee:	cf 93       	push	r28
    19f0:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    19f2:	80 91 09 04 	lds	r24, 0x0409
    19f6:	88 23       	and	r24, r24
    19f8:	09 f0       	breq	.+2      	; 0x19fc <xTaskIncrementTick+0x1a>
    19fa:	98 c0       	rjmp	.+304    	; 0x1b2c <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
    19fc:	c0 90 11 04 	lds	r12, 0x0411
    1a00:	d0 90 12 04 	lds	r13, 0x0412
    1a04:	08 94       	sec
    1a06:	c1 1c       	adc	r12, r1
    1a08:	d1 1c       	adc	r13, r1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    1a0a:	d0 92 12 04 	sts	0x0412, r13
    1a0e:	c0 92 11 04 	sts	0x0411, r12

		if( xConstTickCount == ( TickType_t ) 0U )
    1a12:	c1 14       	cp	r12, r1
    1a14:	d1 04       	cpc	r13, r1
    1a16:	b9 f4       	brne	.+46     	; 0x1a46 <xTaskIncrementTick+0x64>
		{
			taskSWITCH_DELAYED_LISTS();
    1a18:	80 91 17 04 	lds	r24, 0x0417
    1a1c:	90 91 18 04 	lds	r25, 0x0418
    1a20:	20 91 15 04 	lds	r18, 0x0415
    1a24:	30 91 16 04 	lds	r19, 0x0416
    1a28:	30 93 18 04 	sts	0x0418, r19
    1a2c:	20 93 17 04 	sts	0x0417, r18
    1a30:	90 93 16 04 	sts	0x0416, r25
    1a34:	80 93 15 04 	sts	0x0415, r24
    1a38:	80 91 0c 04 	lds	r24, 0x040C
    1a3c:	8f 5f       	subi	r24, 0xFF	; 255
    1a3e:	80 93 0c 04 	sts	0x040C, r24
    1a42:	0e 94 84 09 	call	0x1308	; 0x1308 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1a46:	80 91 0a 04 	lds	r24, 0x040A
    1a4a:	90 91 0b 04 	lds	r25, 0x040B
    1a4e:	c8 16       	cp	r12, r24
    1a50:	d9 06       	cpc	r13, r25
    1a52:	20 f4       	brcc	.+8      	; 0x1a5c <xTaskIncrementTick+0x7a>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1a54:	ff 24       	eor	r15, r15
    1a56:	54 c0       	rjmp	.+168    	; 0x1b00 <xTaskIncrementTick+0x11e>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1a58:	fe 2c       	mov	r15, r14
    1a5a:	03 c0       	rjmp	.+6      	; 0x1a62 <xTaskIncrementTick+0x80>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    1a5c:	ff 24       	eor	r15, r15
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
    1a5e:	ee 24       	eor	r14, r14
    1a60:	e3 94       	inc	r14
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1a62:	e0 91 17 04 	lds	r30, 0x0417
    1a66:	f0 91 18 04 	lds	r31, 0x0418
    1a6a:	80 81       	ld	r24, Z
    1a6c:	88 23       	and	r24, r24
    1a6e:	39 f4       	brne	.+14     	; 0x1a7e <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1a70:	8f ef       	ldi	r24, 0xFF	; 255
    1a72:	9f ef       	ldi	r25, 0xFF	; 255
    1a74:	90 93 0b 04 	sts	0x040B, r25
    1a78:	80 93 0a 04 	sts	0x040A, r24
					break;
    1a7c:	41 c0       	rjmp	.+130    	; 0x1b00 <xTaskIncrementTick+0x11e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1a7e:	e0 91 17 04 	lds	r30, 0x0417
    1a82:	f0 91 18 04 	lds	r31, 0x0418
    1a86:	05 80       	ldd	r0, Z+5	; 0x05
    1a88:	f6 81       	ldd	r31, Z+6	; 0x06
    1a8a:	e0 2d       	mov	r30, r0
    1a8c:	c6 81       	ldd	r28, Z+6	; 0x06
    1a8e:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    1a90:	8a 81       	ldd	r24, Y+2	; 0x02
    1a92:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
    1a94:	c8 16       	cp	r12, r24
    1a96:	d9 06       	cpc	r13, r25
    1a98:	28 f4       	brcc	.+10     	; 0x1aa4 <xTaskIncrementTick+0xc2>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    1a9a:	90 93 0b 04 	sts	0x040B, r25
    1a9e:	80 93 0a 04 	sts	0x040A, r24
						break;
    1aa2:	2e c0       	rjmp	.+92     	; 0x1b00 <xTaskIncrementTick+0x11e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1aa4:	8e 01       	movw	r16, r28
    1aa6:	0e 5f       	subi	r16, 0xFE	; 254
    1aa8:	1f 4f       	sbci	r17, 0xFF	; 255
    1aaa:	c8 01       	movw	r24, r16
    1aac:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1ab0:	8c 89       	ldd	r24, Y+20	; 0x14
    1ab2:	9d 89       	ldd	r25, Y+21	; 0x15
    1ab4:	00 97       	sbiw	r24, 0x00	; 0
    1ab6:	21 f0       	breq	.+8      	; 0x1ac0 <xTaskIncrementTick+0xde>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1ab8:	ce 01       	movw	r24, r28
    1aba:	0c 96       	adiw	r24, 0x0c	; 12
    1abc:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    1ac0:	8e 89       	ldd	r24, Y+22	; 0x16
    1ac2:	90 91 10 04 	lds	r25, 0x0410
    1ac6:	98 17       	cp	r25, r24
    1ac8:	10 f4       	brcc	.+4      	; 0x1ace <xTaskIncrementTick+0xec>
    1aca:	80 93 10 04 	sts	0x0410, r24
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	9c 01       	movw	r18, r24
    1ad2:	22 0f       	add	r18, r18
    1ad4:	33 1f       	adc	r19, r19
    1ad6:	22 0f       	add	r18, r18
    1ad8:	33 1f       	adc	r19, r19
    1ada:	22 0f       	add	r18, r18
    1adc:	33 1f       	adc	r19, r19
    1ade:	82 0f       	add	r24, r18
    1ae0:	93 1f       	adc	r25, r19
    1ae2:	86 5e       	subi	r24, 0xE6	; 230
    1ae4:	9b 4f       	sbci	r25, 0xFB	; 251
    1ae6:	b8 01       	movw	r22, r16
    1ae8:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1aec:	e0 91 07 04 	lds	r30, 0x0407
    1af0:	f0 91 08 04 	lds	r31, 0x0408
    1af4:	9e 89       	ldd	r25, Y+22	; 0x16
    1af6:	86 89       	ldd	r24, Z+22	; 0x16
    1af8:	98 17       	cp	r25, r24
    1afa:	08 f0       	brcs	.+2      	; 0x1afe <xTaskIncrementTick+0x11c>
    1afc:	ad cf       	rjmp	.-166    	; 0x1a58 <xTaskIncrementTick+0x76>
    1afe:	b1 cf       	rjmp	.-158    	; 0x1a62 <xTaskIncrementTick+0x80>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1b00:	e0 91 07 04 	lds	r30, 0x0407
    1b04:	f0 91 08 04 	lds	r31, 0x0408
    1b08:	86 89       	ldd	r24, Z+22	; 0x16
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	ee 0f       	add	r30, r30
    1b10:	ff 1f       	adc	r31, r31
    1b12:	ee 0f       	add	r30, r30
    1b14:	ff 1f       	adc	r31, r31
    1b16:	ee 0f       	add	r30, r30
    1b18:	ff 1f       	adc	r31, r31
    1b1a:	8e 0f       	add	r24, r30
    1b1c:	9f 1f       	adc	r25, r31
    1b1e:	fc 01       	movw	r30, r24
    1b20:	e6 5e       	subi	r30, 0xE6	; 230
    1b22:	fb 4f       	sbci	r31, 0xFB	; 251
    1b24:	80 81       	ld	r24, Z
    1b26:	82 30       	cpi	r24, 0x02	; 2
    1b28:	40 f4       	brcc	.+16     	; 0x1b3a <xTaskIncrementTick+0x158>
    1b2a:	09 c0       	rjmp	.+18     	; 0x1b3e <xTaskIncrementTick+0x15c>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1b2c:	80 91 0e 04 	lds	r24, 0x040E
    1b30:	8f 5f       	subi	r24, 0xFF	; 255
    1b32:	80 93 0e 04 	sts	0x040E, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1b36:	ff 24       	eor	r15, r15
    1b38:	02 c0       	rjmp	.+4      	; 0x1b3e <xTaskIncrementTick+0x15c>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
    1b3a:	ff 24       	eor	r15, r15
    1b3c:	f3 94       	inc	r15
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1b3e:	80 91 0d 04 	lds	r24, 0x040D
    1b42:	88 23       	and	r24, r24
    1b44:	11 f0       	breq	.+4      	; 0x1b4a <xTaskIncrementTick+0x168>
		{
			xSwitchRequired = pdTRUE;
    1b46:	ff 24       	eor	r15, r15
    1b48:	f3 94       	inc	r15
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1b4a:	8f 2d       	mov	r24, r15
    1b4c:	df 91       	pop	r29
    1b4e:	cf 91       	pop	r28
    1b50:	1f 91       	pop	r17
    1b52:	0f 91       	pop	r16
    1b54:	ff 90       	pop	r15
    1b56:	ef 90       	pop	r14
    1b58:	df 90       	pop	r13
    1b5a:	cf 90       	pop	r12
    1b5c:	08 95       	ret

00001b5e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1b5e:	df 92       	push	r13
    1b60:	ef 92       	push	r14
    1b62:	ff 92       	push	r15
    1b64:	0f 93       	push	r16
    1b66:	1f 93       	push	r17
    1b68:	cf 93       	push	r28
    1b6a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1b6c:	0f b6       	in	r0, 0x3f	; 63
    1b6e:	f8 94       	cli
    1b70:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1b72:	80 91 09 04 	lds	r24, 0x0409
    1b76:	81 50       	subi	r24, 0x01	; 1
    1b78:	80 93 09 04 	sts	0x0409, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1b7c:	80 91 09 04 	lds	r24, 0x0409
    1b80:	88 23       	and	r24, r24
    1b82:	09 f0       	breq	.+2      	; 0x1b86 <xTaskResumeAll+0x28>
    1b84:	5f c0       	rjmp	.+190    	; 0x1c44 <xTaskResumeAll+0xe6>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1b86:	80 91 13 04 	lds	r24, 0x0413
    1b8a:	88 23       	and	r24, r24
    1b8c:	91 f5       	brne	.+100    	; 0x1bf2 <xTaskResumeAll+0x94>
    1b8e:	5d c0       	rjmp	.+186    	; 0x1c4a <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1b90:	e0 91 5e 04 	lds	r30, 0x045E
    1b94:	f0 91 5f 04 	lds	r31, 0x045F
    1b98:	c6 81       	ldd	r28, Z+6	; 0x06
    1b9a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1b9c:	ce 01       	movw	r24, r28
    1b9e:	0c 96       	adiw	r24, 0x0c	; 12
    1ba0:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1ba4:	8e 01       	movw	r16, r28
    1ba6:	0e 5f       	subi	r16, 0xFE	; 254
    1ba8:	1f 4f       	sbci	r17, 0xFF	; 255
    1baa:	c8 01       	movw	r24, r16
    1bac:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1bb0:	8e 89       	ldd	r24, Y+22	; 0x16
    1bb2:	90 91 10 04 	lds	r25, 0x0410
    1bb6:	98 17       	cp	r25, r24
    1bb8:	10 f4       	brcc	.+4      	; 0x1bbe <xTaskResumeAll+0x60>
    1bba:	80 93 10 04 	sts	0x0410, r24
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	9c 01       	movw	r18, r24
    1bc2:	22 0f       	add	r18, r18
    1bc4:	33 1f       	adc	r19, r19
    1bc6:	22 0f       	add	r18, r18
    1bc8:	33 1f       	adc	r19, r19
    1bca:	22 0f       	add	r18, r18
    1bcc:	33 1f       	adc	r19, r19
    1bce:	82 0f       	add	r24, r18
    1bd0:	93 1f       	adc	r25, r19
    1bd2:	86 5e       	subi	r24, 0xE6	; 230
    1bd4:	9b 4f       	sbci	r25, 0xFB	; 251
    1bd6:	b8 01       	movw	r22, r16
    1bd8:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1bdc:	e0 91 07 04 	lds	r30, 0x0407
    1be0:	f0 91 08 04 	lds	r31, 0x0408
    1be4:	9e 89       	ldd	r25, Y+22	; 0x16
    1be6:	86 89       	ldd	r24, Z+22	; 0x16
    1be8:	98 17       	cp	r25, r24
    1bea:	68 f0       	brcs	.+26     	; 0x1c06 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
    1bec:	d0 92 0d 04 	sts	0x040D, r13
    1bf0:	0a c0       	rjmp	.+20     	; 0x1c06 <xTaskResumeAll+0xa8>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1bf2:	c0 e0       	ldi	r28, 0x00	; 0
    1bf4:	d0 e0       	ldi	r29, 0x00	; 0
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1bf6:	0f 2e       	mov	r0, r31
    1bf8:	f9 e5       	ldi	r31, 0x59	; 89
    1bfa:	ef 2e       	mov	r14, r31
    1bfc:	f4 e0       	ldi	r31, 0x04	; 4
    1bfe:	ff 2e       	mov	r15, r31
    1c00:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    1c02:	dd 24       	eor	r13, r13
    1c04:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1c06:	f7 01       	movw	r30, r14
    1c08:	80 81       	ld	r24, Z
    1c0a:	88 23       	and	r24, r24
    1c0c:	09 f6       	brne	.-126    	; 0x1b90 <xTaskResumeAll+0x32>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    1c0e:	20 97       	sbiw	r28, 0x00	; 0
    1c10:	11 f0       	breq	.+4      	; 0x1c16 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    1c12:	0e 94 84 09 	call	0x1308	; 0x1308 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    1c16:	c0 91 0e 04 	lds	r28, 0x040E

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    1c1a:	cc 23       	and	r28, r28
    1c1c:	59 f0       	breq	.+22     	; 0x1c34 <xTaskResumeAll+0xd6>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
    1c1e:	01 e0       	ldi	r16, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    1c20:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <xTaskIncrementTick>
    1c24:	88 23       	and	r24, r24
    1c26:	11 f0       	breq	.+4      	; 0x1c2c <xTaskResumeAll+0xce>
							{
								xYieldPending = pdTRUE;
    1c28:	00 93 0d 04 	sts	0x040D, r16
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    1c2c:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    1c2e:	c1 f7       	brne	.-16     	; 0x1c20 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
    1c30:	10 92 0e 04 	sts	0x040E, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    1c34:	80 91 0d 04 	lds	r24, 0x040D
    1c38:	88 23       	and	r24, r24
    1c3a:	31 f0       	breq	.+12     	; 0x1c48 <xTaskResumeAll+0xea>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1c3c:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1c40:	81 e0       	ldi	r24, 0x01	; 1
    1c42:	03 c0       	rjmp	.+6      	; 0x1c4a <xTaskResumeAll+0xec>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
    1c44:	80 e0       	ldi	r24, 0x00	; 0
    1c46:	01 c0       	rjmp	.+2      	; 0x1c4a <xTaskResumeAll+0xec>
    1c48:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1c4a:	0f 90       	pop	r0
    1c4c:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1c4e:	df 91       	pop	r29
    1c50:	cf 91       	pop	r28
    1c52:	1f 91       	pop	r17
    1c54:	0f 91       	pop	r16
    1c56:	ff 90       	pop	r15
    1c58:	ef 90       	pop	r14
    1c5a:	df 90       	pop	r13
    1c5c:	08 95       	ret

00001c5e <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1c5e:	02 e6       	ldi	r16, 0x62	; 98
    1c60:	14 e0       	ldi	r17, 0x04	; 4

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1c62:	0f 2e       	mov	r0, r31
    1c64:	fa e1       	ldi	r31, 0x1A	; 26
    1c66:	ef 2e       	mov	r14, r31
    1c68:	f4 e0       	ldi	r31, 0x04	; 4
    1c6a:	ff 2e       	mov	r15, r31
    1c6c:	f0 2d       	mov	r31, r0
    1c6e:	24 c0       	rjmp	.+72     	; 0x1cb8 <prvIdleTask+0x5a>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    1c70:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1c74:	f8 01       	movw	r30, r16
    1c76:	c0 81       	ld	r28, Z
			}
			( void ) xTaskResumeAll();
    1c78:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1c7c:	cc 23       	and	r28, r28
    1c7e:	e1 f0       	breq	.+56     	; 0x1cb8 <prvIdleTask+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1c80:	0f b6       	in	r0, 0x3f	; 63
    1c82:	f8 94       	cli
    1c84:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1c86:	e0 91 67 04 	lds	r30, 0x0467
    1c8a:	f0 91 68 04 	lds	r31, 0x0468
    1c8e:	c6 81       	ldd	r28, Z+6	; 0x06
    1c90:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    1c92:	ce 01       	movw	r24, r28
    1c94:	02 96       	adiw	r24, 0x02	; 2
    1c96:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1c9a:	80 91 13 04 	lds	r24, 0x0413
    1c9e:	81 50       	subi	r24, 0x01	; 1
    1ca0:	80 93 13 04 	sts	0x0413, r24
					--uxDeletedTasksWaitingCleanUp;
    1ca4:	80 91 14 04 	lds	r24, 0x0414
    1ca8:	81 50       	subi	r24, 0x01	; 1
    1caa:	80 93 14 04 	sts	0x0414, r24
				}
				taskEXIT_CRITICAL();
    1cae:	0f 90       	pop	r0
    1cb0:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    1cb2:	ce 01       	movw	r24, r28
    1cb4:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    1cb8:	80 91 14 04 	lds	r24, 0x0414
    1cbc:	88 23       	and	r24, r24
    1cbe:	c1 f6       	brne	.-80     	; 0x1c70 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1cc0:	f7 01       	movw	r30, r14
    1cc2:	80 81       	ld	r24, Z
    1cc4:	82 30       	cpi	r24, 0x02	; 2
    1cc6:	c0 f3       	brcs	.-16     	; 0x1cb8 <prvIdleTask+0x5a>
			{
				taskYIELD();
    1cc8:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
    1ccc:	f5 cf       	rjmp	.-22     	; 0x1cb8 <prvIdleTask+0x5a>

00001cce <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1cce:	cf 93       	push	r28
    1cd0:	df 93       	push	r29
    1cd2:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    1cd4:	00 97       	sbiw	r24, 0x00	; 0
    1cd6:	51 f0       	breq	.+20     	; 0x1cec <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1cd8:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    1cdc:	ce 01       	movw	r24, r28
    1cde:	60 e0       	ldi	r22, 0x00	; 0
    1ce0:	0e 94 a3 09 	call	0x1346	; 0x1346 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1ce4:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1ce8:	88 23       	and	r24, r24
    1cea:	11 f4       	brne	.+4      	; 0x1cf0 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
    1cec:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	08 95       	ret

00001cf6 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    1cf6:	0f 93       	push	r16
    1cf8:	1f 93       	push	r17
    1cfa:	cf 93       	push	r28
    1cfc:	df 93       	push	r29
    1cfe:	8c 01       	movw	r16, r24
    1d00:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1d02:	0e 94 d1 0c 	call	0x19a2	; 0x19a2 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1d06:	80 91 11 04 	lds	r24, 0x0411
    1d0a:	90 91 12 04 	lds	r25, 0x0412

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1d0e:	f8 01       	movw	r30, r16
    1d10:	20 81       	ld	r18, Z
    1d12:	31 81       	ldd	r19, Z+1	; 0x01
    1d14:	c2 0f       	add	r28, r18
    1d16:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    1d18:	82 17       	cp	r24, r18
    1d1a:	93 07       	cpc	r25, r19
    1d1c:	48 f4       	brcc	.+18     	; 0x1d30 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1d1e:	c2 17       	cp	r28, r18
    1d20:	d3 07       	cpc	r29, r19
    1d22:	f8 f4       	brcc	.+62     	; 0x1d62 <vTaskDelayUntil+0x6c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d24:	d1 83       	std	Z+1, r29	; 0x01
    1d26:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    1d28:	8c 17       	cp	r24, r28
    1d2a:	9d 07       	cpc	r25, r29
    1d2c:	78 f4       	brcc	.+30     	; 0x1d4c <vTaskDelayUntil+0x56>
    1d2e:	07 c0       	rjmp	.+14     	; 0x1d3e <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1d30:	c2 17       	cp	r28, r18
    1d32:	d3 07       	cpc	r29, r19
    1d34:	90 f0       	brcs	.+36     	; 0x1d5a <vTaskDelayUntil+0x64>
    1d36:	8c 17       	cp	r24, r28
    1d38:	9d 07       	cpc	r25, r29
    1d3a:	78 f0       	brcs	.+30     	; 0x1d5a <vTaskDelayUntil+0x64>
    1d3c:	12 c0       	rjmp	.+36     	; 0x1d62 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    1d3e:	9e 01       	movw	r18, r28
    1d40:	28 1b       	sub	r18, r24
    1d42:	39 0b       	sbc	r19, r25
    1d44:	c9 01       	movw	r24, r18
    1d46:	60 e0       	ldi	r22, 0x00	; 0
    1d48:	0e 94 a3 09 	call	0x1346	; 0x1346 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1d4c:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1d50:	88 23       	and	r24, r24
    1d52:	59 f4       	brne	.+22     	; 0x1d6a <vTaskDelayUntil+0x74>
		{
			portYIELD_WITHIN_API();
    1d54:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
    1d58:	08 c0       	rjmp	.+16     	; 0x1d6a <vTaskDelayUntil+0x74>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1d5a:	f8 01       	movw	r30, r16
    1d5c:	d1 83       	std	Z+1, r29	; 0x01
    1d5e:	c0 83       	st	Z, r28
    1d60:	ee cf       	rjmp	.-36     	; 0x1d3e <vTaskDelayUntil+0x48>
    1d62:	f8 01       	movw	r30, r16
    1d64:	d1 83       	std	Z+1, r29	; 0x01
    1d66:	c0 83       	st	Z, r28
    1d68:	f1 cf       	rjmp	.-30     	; 0x1d4c <vTaskDelayUntil+0x56>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1d6a:	df 91       	pop	r29
    1d6c:	cf 91       	pop	r28
    1d6e:	1f 91       	pop	r17
    1d70:	0f 91       	pop	r16
    1d72:	08 95       	ret

00001d74 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    1d74:	80 91 09 04 	lds	r24, 0x0409
    1d78:	88 23       	and	r24, r24
    1d7a:	21 f0       	breq	.+8      	; 0x1d84 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	80 93 0d 04 	sts	0x040D, r24
    1d82:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    1d84:	10 92 0d 04 	sts	0x040D, r1
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1d88:	20 91 10 04 	lds	r18, 0x0410
    1d8c:	82 2f       	mov	r24, r18
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	fc 01       	movw	r30, r24
    1d92:	ee 0f       	add	r30, r30
    1d94:	ff 1f       	adc	r31, r31
    1d96:	ee 0f       	add	r30, r30
    1d98:	ff 1f       	adc	r31, r31
    1d9a:	ee 0f       	add	r30, r30
    1d9c:	ff 1f       	adc	r31, r31
    1d9e:	e8 0f       	add	r30, r24
    1da0:	f9 1f       	adc	r31, r25
    1da2:	e6 5e       	subi	r30, 0xE6	; 230
    1da4:	fb 4f       	sbci	r31, 0xFB	; 251
    1da6:	30 81       	ld	r19, Z
    1da8:	33 23       	and	r19, r19
    1daa:	89 f4       	brne	.+34     	; 0x1dce <vTaskSwitchContext+0x5a>
    1dac:	21 50       	subi	r18, 0x01	; 1
    1dae:	82 2f       	mov	r24, r18
    1db0:	90 e0       	ldi	r25, 0x00	; 0
    1db2:	fc 01       	movw	r30, r24
    1db4:	ee 0f       	add	r30, r30
    1db6:	ff 1f       	adc	r31, r31
    1db8:	ee 0f       	add	r30, r30
    1dba:	ff 1f       	adc	r31, r31
    1dbc:	ee 0f       	add	r30, r30
    1dbe:	ff 1f       	adc	r31, r31
    1dc0:	e8 0f       	add	r30, r24
    1dc2:	f9 1f       	adc	r31, r25
    1dc4:	e6 5e       	subi	r30, 0xE6	; 230
    1dc6:	fb 4f       	sbci	r31, 0xFB	; 251
    1dc8:	30 81       	ld	r19, Z
    1dca:	33 23       	and	r19, r19
    1dcc:	79 f3       	breq	.-34     	; 0x1dac <vTaskSwitchContext+0x38>
    1dce:	dc 01       	movw	r26, r24
    1dd0:	aa 0f       	add	r26, r26
    1dd2:	bb 1f       	adc	r27, r27
    1dd4:	aa 0f       	add	r26, r26
    1dd6:	bb 1f       	adc	r27, r27
    1dd8:	aa 0f       	add	r26, r26
    1dda:	bb 1f       	adc	r27, r27
    1ddc:	8a 0f       	add	r24, r26
    1dde:	9b 1f       	adc	r25, r27
    1de0:	dc 01       	movw	r26, r24
    1de2:	a6 5e       	subi	r26, 0xE6	; 230
    1de4:	bb 4f       	sbci	r27, 0xFB	; 251
    1de6:	11 96       	adiw	r26, 0x01	; 1
    1de8:	ed 91       	ld	r30, X+
    1dea:	fc 91       	ld	r31, X
    1dec:	12 97       	sbiw	r26, 0x02	; 2
    1dee:	02 80       	ldd	r0, Z+2	; 0x02
    1df0:	f3 81       	ldd	r31, Z+3	; 0x03
    1df2:	e0 2d       	mov	r30, r0
    1df4:	12 96       	adiw	r26, 0x02	; 2
    1df6:	fc 93       	st	X, r31
    1df8:	ee 93       	st	-X, r30
    1dfa:	11 97       	sbiw	r26, 0x01	; 1
    1dfc:	cd 01       	movw	r24, r26
    1dfe:	03 96       	adiw	r24, 0x03	; 3
    1e00:	e8 17       	cp	r30, r24
    1e02:	f9 07       	cpc	r31, r25
    1e04:	31 f4       	brne	.+12     	; 0x1e12 <vTaskSwitchContext+0x9e>
    1e06:	82 81       	ldd	r24, Z+2	; 0x02
    1e08:	93 81       	ldd	r25, Z+3	; 0x03
    1e0a:	12 96       	adiw	r26, 0x02	; 2
    1e0c:	9c 93       	st	X, r25
    1e0e:	8e 93       	st	-X, r24
    1e10:	11 97       	sbiw	r26, 0x01	; 1
    1e12:	11 96       	adiw	r26, 0x01	; 1
    1e14:	ed 91       	ld	r30, X+
    1e16:	fc 91       	ld	r31, X
    1e18:	12 97       	sbiw	r26, 0x02	; 2
    1e1a:	86 81       	ldd	r24, Z+6	; 0x06
    1e1c:	97 81       	ldd	r25, Z+7	; 0x07
    1e1e:	90 93 08 04 	sts	0x0408, r25
    1e22:	80 93 07 04 	sts	0x0407, r24
    1e26:	20 93 10 04 	sts	0x0410, r18
    1e2a:	08 95       	ret

00001e2c <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    1e2c:	0f 93       	push	r16
    1e2e:	1f 93       	push	r17
    1e30:	cf 93       	push	r28
    1e32:	df 93       	push	r29
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    1e34:	0f b6       	in	r0, 0x3f	; 63
    1e36:	f8 94       	cli
    1e38:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    1e3a:	00 97       	sbiw	r24, 0x00	; 0
    1e3c:	29 f4       	brne	.+10     	; 0x1e48 <vTaskSuspend+0x1c>
    1e3e:	00 91 07 04 	lds	r16, 0x0407
    1e42:	10 91 08 04 	lds	r17, 0x0408
    1e46:	01 c0       	rjmp	.+2      	; 0x1e4a <vTaskSuspend+0x1e>
    1e48:	8c 01       	movw	r16, r24

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    1e4a:	e8 01       	movw	r28, r16
    1e4c:	22 96       	adiw	r28, 0x02	; 2
    1e4e:	ce 01       	movw	r24, r28
    1e50:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    1e54:	f8 01       	movw	r30, r16
    1e56:	84 89       	ldd	r24, Z+20	; 0x14
    1e58:	95 89       	ldd	r25, Z+21	; 0x15
    1e5a:	00 97       	sbiw	r24, 0x00	; 0
    1e5c:	21 f0       	breq	.+8      	; 0x1e66 <vTaskSuspend+0x3a>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1e5e:	c8 01       	movw	r24, r16
    1e60:	0c 96       	adiw	r24, 0x0c	; 12
    1e62:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    1e66:	8b e6       	ldi	r24, 0x6B	; 107
    1e68:	94 e0       	ldi	r25, 0x04	; 4
    1e6a:	be 01       	movw	r22, r28
    1e6c:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    1e70:	0f 90       	pop	r0
    1e72:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    1e74:	80 91 0f 04 	lds	r24, 0x040F
    1e78:	88 23       	and	r24, r24
    1e7a:	39 f0       	breq	.+14     	; 0x1e8a <vTaskSuspend+0x5e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    1e7c:	0f b6       	in	r0, 0x3f	; 63
    1e7e:	f8 94       	cli
    1e80:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    1e82:	0e 94 84 09 	call	0x1308	; 0x1308 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    1e86:	0f 90       	pop	r0
    1e88:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    1e8a:	80 91 07 04 	lds	r24, 0x0407
    1e8e:	90 91 08 04 	lds	r25, 0x0408
    1e92:	08 17       	cp	r16, r24
    1e94:	19 07       	cpc	r17, r25
    1e96:	a1 f4       	brne	.+40     	; 0x1ec0 <vTaskSuspend+0x94>
		{
			if( xSchedulerRunning != pdFALSE )
    1e98:	80 91 0f 04 	lds	r24, 0x040F
    1e9c:	88 23       	and	r24, r24
    1e9e:	19 f0       	breq	.+6      	; 0x1ea6 <vTaskSuspend+0x7a>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    1ea0:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
    1ea4:	0d c0       	rjmp	.+26     	; 0x1ec0 <vTaskSuspend+0x94>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    1ea6:	80 91 13 04 	lds	r24, 0x0413
    1eaa:	90 91 6b 04 	lds	r25, 0x046B
    1eae:	98 17       	cp	r25, r24
    1eb0:	29 f4       	brne	.+10     	; 0x1ebc <vTaskSuspend+0x90>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    1eb2:	10 92 08 04 	sts	0x0408, r1
    1eb6:	10 92 07 04 	sts	0x0407, r1
    1eba:	02 c0       	rjmp	.+4      	; 0x1ec0 <vTaskSuspend+0x94>
				}
				else
				{
					vTaskSwitchContext();
    1ebc:	0e 94 ba 0e 	call	0x1d74	; 0x1d74 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1ec0:	df 91       	pop	r29
    1ec2:	cf 91       	pop	r28
    1ec4:	1f 91       	pop	r17
    1ec6:	0f 91       	pop	r16
    1ec8:	08 95       	ret

00001eca <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1eca:	cf 93       	push	r28
    1ecc:	df 93       	push	r29
    1ece:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1ed0:	60 91 07 04 	lds	r22, 0x0407
    1ed4:	70 91 08 04 	lds	r23, 0x0408
    1ed8:	64 5f       	subi	r22, 0xF4	; 244
    1eda:	7f 4f       	sbci	r23, 0xFF	; 255
    1edc:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1ee0:	ce 01       	movw	r24, r28
    1ee2:	61 e0       	ldi	r22, 0x01	; 1
    1ee4:	0e 94 a3 09 	call	0x1346	; 0x1346 <prvAddCurrentTaskToDelayedList>
}
    1ee8:	df 91       	pop	r29
    1eea:	cf 91       	pop	r28
    1eec:	08 95       	ret

00001eee <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    1eee:	cf 93       	push	r28
    1ef0:	df 93       	push	r29
    1ef2:	ea 01       	movw	r28, r20
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1ef4:	e0 91 07 04 	lds	r30, 0x0407
    1ef8:	f0 91 08 04 	lds	r31, 0x0408
    1efc:	70 68       	ori	r23, 0x80	; 128
    1efe:	75 87       	std	Z+13, r23	; 0x0d
    1f00:	64 87       	std	Z+12, r22	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1f02:	60 91 07 04 	lds	r22, 0x0407
    1f06:	70 91 08 04 	lds	r23, 0x0408
    1f0a:	64 5f       	subi	r22, 0xF4	; 244
    1f0c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0e:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    1f12:	ce 01       	movw	r24, r28
    1f14:	61 e0       	ldi	r22, 0x01	; 1
    1f16:	0e 94 a3 09 	call	0x1346	; 0x1346 <prvAddCurrentTaskToDelayedList>
}
    1f1a:	df 91       	pop	r29
    1f1c:	cf 91       	pop	r28
    1f1e:	08 95       	ret

00001f20 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1f20:	0f 93       	push	r16
    1f22:	1f 93       	push	r17
    1f24:	cf 93       	push	r28
    1f26:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1f28:	dc 01       	movw	r26, r24
    1f2a:	15 96       	adiw	r26, 0x05	; 5
    1f2c:	ed 91       	ld	r30, X+
    1f2e:	fc 91       	ld	r31, X
    1f30:	16 97       	sbiw	r26, 0x06	; 6
    1f32:	06 81       	ldd	r16, Z+6	; 0x06
    1f34:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1f36:	e8 01       	movw	r28, r16
    1f38:	2c 96       	adiw	r28, 0x0c	; 12
    1f3a:	ce 01       	movw	r24, r28
    1f3c:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1f40:	80 91 09 04 	lds	r24, 0x0409
    1f44:	88 23       	and	r24, r24
    1f46:	e9 f4       	brne	.+58     	; 0x1f82 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1f48:	e8 01       	movw	r28, r16
    1f4a:	22 96       	adiw	r28, 0x02	; 2
    1f4c:	ce 01       	movw	r24, r28
    1f4e:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1f52:	f8 01       	movw	r30, r16
    1f54:	86 89       	ldd	r24, Z+22	; 0x16
    1f56:	90 91 10 04 	lds	r25, 0x0410
    1f5a:	98 17       	cp	r25, r24
    1f5c:	10 f4       	brcc	.+4      	; 0x1f62 <xTaskRemoveFromEventList+0x42>
    1f5e:	80 93 10 04 	sts	0x0410, r24
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	9c 01       	movw	r18, r24
    1f66:	22 0f       	add	r18, r18
    1f68:	33 1f       	adc	r19, r19
    1f6a:	22 0f       	add	r18, r18
    1f6c:	33 1f       	adc	r19, r19
    1f6e:	22 0f       	add	r18, r18
    1f70:	33 1f       	adc	r19, r19
    1f72:	82 0f       	add	r24, r18
    1f74:	93 1f       	adc	r25, r19
    1f76:	86 5e       	subi	r24, 0xE6	; 230
    1f78:	9b 4f       	sbci	r25, 0xFB	; 251
    1f7a:	be 01       	movw	r22, r28
    1f7c:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    1f80:	05 c0       	rjmp	.+10     	; 0x1f8c <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1f82:	89 e5       	ldi	r24, 0x59	; 89
    1f84:	94 e0       	ldi	r25, 0x04	; 4
    1f86:	be 01       	movw	r22, r28
    1f88:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1f8c:	e0 91 07 04 	lds	r30, 0x0407
    1f90:	f0 91 08 04 	lds	r31, 0x0408
    1f94:	d8 01       	movw	r26, r16
    1f96:	56 96       	adiw	r26, 0x16	; 22
    1f98:	9c 91       	ld	r25, X
    1f9a:	56 97       	sbiw	r26, 0x16	; 22
    1f9c:	86 89       	ldd	r24, Z+22	; 0x16
    1f9e:	89 17       	cp	r24, r25
    1fa0:	20 f4       	brcc	.+8      	; 0x1faa <xTaskRemoveFromEventList+0x8a>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	80 93 0d 04 	sts	0x040D, r24
    1fa8:	01 c0       	rjmp	.+2      	; 0x1fac <xTaskRemoveFromEventList+0x8c>
	}
	else
	{
		xReturn = pdFALSE;
    1faa:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1fac:	df 91       	pop	r29
    1fae:	cf 91       	pop	r28
    1fb0:	1f 91       	pop	r17
    1fb2:	0f 91       	pop	r16
    1fb4:	08 95       	ret

00001fb6 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    1fb6:	0f 93       	push	r16
    1fb8:	1f 93       	push	r17
    1fba:	cf 93       	push	r28
    1fbc:	df 93       	push	r29
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    1fbe:	70 68       	ori	r23, 0x80	; 128
    1fc0:	fc 01       	movw	r30, r24
    1fc2:	71 83       	std	Z+1, r23	; 0x01
    1fc4:	60 83       	st	Z, r22

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
    1fc6:	c6 81       	ldd	r28, Z+6	; 0x06
    1fc8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    1fca:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    1fce:	8e 01       	movw	r16, r28
    1fd0:	0e 5f       	subi	r16, 0xFE	; 254
    1fd2:	1f 4f       	sbci	r17, 0xFF	; 255
    1fd4:	c8 01       	movw	r24, r16
    1fd6:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    1fda:	8e 89       	ldd	r24, Y+22	; 0x16
    1fdc:	90 91 10 04 	lds	r25, 0x0410
    1fe0:	98 17       	cp	r25, r24
    1fe2:	10 f4       	brcc	.+4      	; 0x1fe8 <xTaskRemoveFromUnorderedEventList+0x32>
    1fe4:	80 93 10 04 	sts	0x0410, r24
    1fe8:	90 e0       	ldi	r25, 0x00	; 0
    1fea:	9c 01       	movw	r18, r24
    1fec:	22 0f       	add	r18, r18
    1fee:	33 1f       	adc	r19, r19
    1ff0:	22 0f       	add	r18, r18
    1ff2:	33 1f       	adc	r19, r19
    1ff4:	22 0f       	add	r18, r18
    1ff6:	33 1f       	adc	r19, r19
    1ff8:	82 0f       	add	r24, r18
    1ffa:	93 1f       	adc	r25, r19
    1ffc:	86 5e       	subi	r24, 0xE6	; 230
    1ffe:	9b 4f       	sbci	r25, 0xFB	; 251
    2000:	b8 01       	movw	r22, r16
    2002:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    2006:	e0 91 07 04 	lds	r30, 0x0407
    200a:	f0 91 08 04 	lds	r31, 0x0408
    200e:	9e 89       	ldd	r25, Y+22	; 0x16
    2010:	86 89       	ldd	r24, Z+22	; 0x16
    2012:	89 17       	cp	r24, r25
    2014:	20 f4       	brcc	.+8      	; 0x201e <xTaskRemoveFromUnorderedEventList+0x68>
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	80 93 0d 04 	sts	0x040D, r24
    201c:	01 c0       	rjmp	.+2      	; 0x2020 <xTaskRemoveFromUnorderedEventList+0x6a>
	}
	else
	{
		xReturn = pdFALSE;
    201e:	80 e0       	ldi	r24, 0x00	; 0
	}

	return xReturn;
}
    2020:	df 91       	pop	r29
    2022:	cf 91       	pop	r28
    2024:	1f 91       	pop	r17
    2026:	0f 91       	pop	r16
    2028:	08 95       	ret

0000202a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    202a:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    202c:	80 91 0c 04 	lds	r24, 0x040C
    2030:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2032:	80 91 11 04 	lds	r24, 0x0411
    2036:	90 91 12 04 	lds	r25, 0x0412
    203a:	92 83       	std	Z+2, r25	; 0x02
    203c:	81 83       	std	Z+1, r24	; 0x01
}
    203e:	08 95       	ret

00002040 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2040:	fc 01       	movw	r30, r24
    2042:	db 01       	movw	r26, r22
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2044:	0f b6       	in	r0, 0x3f	; 63
    2046:	f8 94       	cli
    2048:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    204a:	60 91 11 04 	lds	r22, 0x0411
    204e:	70 91 12 04 	lds	r23, 0x0412
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    2052:	4d 91       	ld	r20, X+
    2054:	5c 91       	ld	r21, X
    2056:	11 97       	sbiw	r26, 0x01	; 1
    2058:	8f ef       	ldi	r24, 0xFF	; 255
    205a:	4f 3f       	cpi	r20, 0xFF	; 255
    205c:	58 07       	cpc	r21, r24
    205e:	e9 f0       	breq	.+58     	; 0x209a <xTaskCheckForTimeOut+0x5a>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2060:	80 91 0c 04 	lds	r24, 0x040C
    2064:	90 81       	ld	r25, Z
    2066:	98 17       	cp	r25, r24
    2068:	29 f0       	breq	.+10     	; 0x2074 <xTaskCheckForTimeOut+0x34>
    206a:	81 81       	ldd	r24, Z+1	; 0x01
    206c:	92 81       	ldd	r25, Z+2	; 0x02
    206e:	68 17       	cp	r22, r24
    2070:	79 07       	cpc	r23, r25
    2072:	a8 f4       	brcc	.+42     	; 0x209e <xTaskCheckForTimeOut+0x5e>
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    2074:	81 81       	ldd	r24, Z+1	; 0x01
    2076:	92 81       	ldd	r25, Z+2	; 0x02
    2078:	9b 01       	movw	r18, r22
    207a:	28 1b       	sub	r18, r24
    207c:	39 0b       	sbc	r19, r25
    207e:	24 17       	cp	r18, r20
    2080:	35 07       	cpc	r19, r21
    2082:	78 f4       	brcc	.+30     	; 0x20a2 <xTaskCheckForTimeOut+0x62>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
    2084:	86 1b       	sub	r24, r22
    2086:	97 0b       	sbc	r25, r23
    2088:	84 0f       	add	r24, r20
    208a:	95 1f       	adc	r25, r21
    208c:	8d 93       	st	X+, r24
    208e:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    2090:	cf 01       	movw	r24, r30
    2092:	0e 94 15 10 	call	0x202a	; 0x202a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2096:	80 e0       	ldi	r24, 0x00	; 0
    2098:	05 c0       	rjmp	.+10     	; 0x20a4 <xTaskCheckForTimeOut+0x64>
			if( *pxTicksToWait == portMAX_DELAY )
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    209a:	80 e0       	ldi	r24, 0x00	; 0
    209c:	03 c0       	rjmp	.+6      	; 0x20a4 <xTaskCheckForTimeOut+0x64>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    209e:	81 e0       	ldi	r24, 0x01	; 1
    20a0:	01 c0       	rjmp	.+2      	; 0x20a4 <xTaskCheckForTimeOut+0x64>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    20a2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    20a4:	0f 90       	pop	r0
    20a6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    20a8:	08 95       	ret

000020aa <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    20aa:	81 e0       	ldi	r24, 0x01	; 1
    20ac:	80 93 0d 04 	sts	0x040D, r24
}
    20b0:	08 95       	ret

000020b2 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    20b2:	80 91 07 04 	lds	r24, 0x0407
    20b6:	90 91 08 04 	lds	r25, 0x0408

		return xReturn;
	}
    20ba:	08 95       	ret

000020bc <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    20bc:	0f 93       	push	r16
    20be:	1f 93       	push	r17
    20c0:	cf 93       	push	r28
    20c2:	df 93       	push	r29
    20c4:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    20c6:	00 97       	sbiw	r24, 0x00	; 0
    20c8:	09 f4       	brne	.+2      	; 0x20cc <vTaskPriorityInherit+0x10>
    20ca:	51 c0       	rjmp	.+162    	; 0x216e <vTaskPriorityInherit+0xb2>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    20cc:	8e 89       	ldd	r24, Y+22	; 0x16
    20ce:	e0 91 07 04 	lds	r30, 0x0407
    20d2:	f0 91 08 04 	lds	r31, 0x0408
    20d6:	96 89       	ldd	r25, Z+22	; 0x16
    20d8:	89 17       	cp	r24, r25
    20da:	08 f0       	brcs	.+2      	; 0x20de <vTaskPriorityInherit+0x22>
    20dc:	48 c0       	rjmp	.+144    	; 0x216e <vTaskPriorityInherit+0xb2>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    20de:	2c 85       	ldd	r18, Y+12	; 0x0c
    20e0:	3d 85       	ldd	r19, Y+13	; 0x0d
    20e2:	33 23       	and	r19, r19
    20e4:	5c f0       	brlt	.+22     	; 0x20fc <vTaskPriorityInherit+0x40>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    20e6:	e0 91 07 04 	lds	r30, 0x0407
    20ea:	f0 91 08 04 	lds	r31, 0x0408
    20ee:	96 89       	ldd	r25, Z+22	; 0x16
    20f0:	25 e0       	ldi	r18, 0x05	; 5
    20f2:	30 e0       	ldi	r19, 0x00	; 0
    20f4:	29 1b       	sub	r18, r25
    20f6:	31 09       	sbc	r19, r1
    20f8:	3d 87       	std	Y+13, r19	; 0x0d
    20fa:	2c 87       	std	Y+12, r18	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    20fc:	90 e0       	ldi	r25, 0x00	; 0
    20fe:	9c 01       	movw	r18, r24
    2100:	22 0f       	add	r18, r18
    2102:	33 1f       	adc	r19, r19
    2104:	22 0f       	add	r18, r18
    2106:	33 1f       	adc	r19, r19
    2108:	22 0f       	add	r18, r18
    210a:	33 1f       	adc	r19, r19
    210c:	82 0f       	add	r24, r18
    210e:	93 1f       	adc	r25, r19
    2110:	86 5e       	subi	r24, 0xE6	; 230
    2112:	9b 4f       	sbci	r25, 0xFB	; 251
    2114:	2a 85       	ldd	r18, Y+10	; 0x0a
    2116:	3b 85       	ldd	r19, Y+11	; 0x0b
    2118:	28 17       	cp	r18, r24
    211a:	39 07       	cpc	r19, r25
    211c:	11 f5       	brne	.+68     	; 0x2162 <vTaskPriorityInherit+0xa6>
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    211e:	8e 01       	movw	r16, r28
    2120:	0e 5f       	subi	r16, 0xFE	; 254
    2122:	1f 4f       	sbci	r17, 0xFF	; 255
    2124:	c8 01       	movw	r24, r16
    2126:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    212a:	e0 91 07 04 	lds	r30, 0x0407
    212e:	f0 91 08 04 	lds	r31, 0x0408
    2132:	86 89       	ldd	r24, Z+22	; 0x16
    2134:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyList( pxTCB );
    2136:	90 91 10 04 	lds	r25, 0x0410
    213a:	98 17       	cp	r25, r24
    213c:	10 f4       	brcc	.+4      	; 0x2142 <vTaskPriorityInherit+0x86>
    213e:	80 93 10 04 	sts	0x0410, r24
    2142:	90 e0       	ldi	r25, 0x00	; 0
    2144:	9c 01       	movw	r18, r24
    2146:	22 0f       	add	r18, r18
    2148:	33 1f       	adc	r19, r19
    214a:	22 0f       	add	r18, r18
    214c:	33 1f       	adc	r19, r19
    214e:	22 0f       	add	r18, r18
    2150:	33 1f       	adc	r19, r19
    2152:	82 0f       	add	r24, r18
    2154:	93 1f       	adc	r25, r19
    2156:	86 5e       	subi	r24, 0xE6	; 230
    2158:	9b 4f       	sbci	r25, 0xFB	; 251
    215a:	b8 01       	movw	r22, r16
    215c:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    2160:	06 c0       	rjmp	.+12     	; 0x216e <vTaskPriorityInherit+0xb2>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    2162:	e0 91 07 04 	lds	r30, 0x0407
    2166:	f0 91 08 04 	lds	r31, 0x0408
    216a:	86 89       	ldd	r24, Z+22	; 0x16
    216c:	8e 8b       	std	Y+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    216e:	df 91       	pop	r29
    2170:	cf 91       	pop	r28
    2172:	1f 91       	pop	r17
    2174:	0f 91       	pop	r16
    2176:	08 95       	ret

00002178 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    2178:	0f 93       	push	r16
    217a:	1f 93       	push	r17
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	ec 01       	movw	r28, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    2182:	00 97       	sbiw	r24, 0x00	; 0
    2184:	81 f1       	breq	.+96     	; 0x21e6 <xTaskPriorityDisinherit+0x6e>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    2186:	8c a1       	lds	r24, 0x4c
    2188:	81 50       	subi	r24, 0x01	; 1
    218a:	8c a3       	lds	r24, 0x5c

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    218c:	2e 89       	ldd	r18, Y+22	; 0x16
    218e:	9b a1       	lds	r25, 0x4b
    2190:	29 17       	cp	r18, r25
    2192:	59 f1       	breq	.+86     	; 0x21ea <xTaskPriorityDisinherit+0x72>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    2194:	88 23       	and	r24, r24
    2196:	59 f5       	brne	.+86     	; 0x21ee <xTaskPriorityDisinherit+0x76>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2198:	8e 01       	movw	r16, r28
    219a:	0e 5f       	subi	r16, 0xFE	; 254
    219c:	1f 4f       	sbci	r17, 0xFF	; 255
    219e:	c8 01       	movw	r24, r16
    21a0:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    21a4:	4b a1       	lds	r20, 0x4b
    21a6:	4e 8b       	std	Y+22, r20	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    21a8:	24 2f       	mov	r18, r20
    21aa:	30 e0       	ldi	r19, 0x00	; 0
    21ac:	85 e0       	ldi	r24, 0x05	; 5
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	82 1b       	sub	r24, r18
    21b2:	93 0b       	sbc	r25, r19
    21b4:	9d 87       	std	Y+13, r25	; 0x0d
    21b6:	8c 87       	std	Y+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    21b8:	80 91 10 04 	lds	r24, 0x0410
    21bc:	84 17       	cp	r24, r20
    21be:	10 f4       	brcc	.+4      	; 0x21c4 <xTaskPriorityDisinherit+0x4c>
    21c0:	40 93 10 04 	sts	0x0410, r20
    21c4:	c9 01       	movw	r24, r18
    21c6:	88 0f       	add	r24, r24
    21c8:	99 1f       	adc	r25, r25
    21ca:	88 0f       	add	r24, r24
    21cc:	99 1f       	adc	r25, r25
    21ce:	88 0f       	add	r24, r24
    21d0:	99 1f       	adc	r25, r25
    21d2:	28 0f       	add	r18, r24
    21d4:	39 1f       	adc	r19, r25
    21d6:	c9 01       	movw	r24, r18
    21d8:	86 5e       	subi	r24, 0xE6	; 230
    21da:	9b 4f       	sbci	r25, 0xFB	; 251
    21dc:	b8 01       	movw	r22, r16
    21de:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    21e2:	81 e0       	ldi	r24, 0x01	; 1
    21e4:	05 c0       	rjmp	.+10     	; 0x21f0 <xTaskPriorityDisinherit+0x78>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    21e6:	80 e0       	ldi	r24, 0x00	; 0
    21e8:	03 c0       	rjmp	.+6      	; 0x21f0 <xTaskPriorityDisinherit+0x78>
    21ea:	80 e0       	ldi	r24, 0x00	; 0
    21ec:	01 c0       	rjmp	.+2      	; 0x21f0 <xTaskPriorityDisinherit+0x78>
    21ee:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    21f0:	df 91       	pop	r29
    21f2:	cf 91       	pop	r28
    21f4:	1f 91       	pop	r17
    21f6:	0f 91       	pop	r16
    21f8:	08 95       	ret

000021fa <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    21fa:	e0 91 07 04 	lds	r30, 0x0407
    21fe:	f0 91 08 04 	lds	r31, 0x0408
    2202:	84 85       	ldd	r24, Z+12	; 0x0c
    2204:	95 85       	ldd	r25, Z+13	; 0x0d

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2206:	e0 91 07 04 	lds	r30, 0x0407
    220a:	f0 91 08 04 	lds	r31, 0x0408
    220e:	a0 91 07 04 	lds	r26, 0x0407
    2212:	b0 91 08 04 	lds	r27, 0x0408
    2216:	56 96       	adiw	r26, 0x16	; 22
    2218:	4c 91       	ld	r20, X
    221a:	56 97       	sbiw	r26, 0x16	; 22
    221c:	25 e0       	ldi	r18, 0x05	; 5
    221e:	30 e0       	ldi	r19, 0x00	; 0
    2220:	24 1b       	sub	r18, r20
    2222:	31 09       	sbc	r19, r1
    2224:	35 87       	std	Z+13, r19	; 0x0d
    2226:	24 87       	std	Z+12, r18	; 0x0c

	return uxReturn;
}
    2228:	08 95       	ret

0000222a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    222a:	80 91 07 04 	lds	r24, 0x0407
    222e:	90 91 08 04 	lds	r25, 0x0408
    2232:	00 97       	sbiw	r24, 0x00	; 0
    2234:	39 f0       	breq	.+14     	; 0x2244 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2236:	e0 91 07 04 	lds	r30, 0x0407
    223a:	f0 91 08 04 	lds	r31, 0x0408
    223e:	84 a1       	lds	r24, 0x44
    2240:	8f 5f       	subi	r24, 0xFF	; 255
    2242:	84 a3       	lds	r24, 0x54
		}

		return pxCurrentTCB;
    2244:	80 91 07 04 	lds	r24, 0x0407
    2248:	90 91 08 04 	lds	r25, 0x0408
	}
    224c:	08 95       	ret

0000224e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    224e:	0f 93       	push	r16
    2250:	1f 93       	push	r17
    2252:	cf 93       	push	r28
    2254:	c8 2f       	mov	r28, r24
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    2256:	0f b6       	in	r0, 0x3f	; 63
    2258:	f8 94       	cli
    225a:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    225c:	e0 91 07 04 	lds	r30, 0x0407
    2260:	f0 91 08 04 	lds	r31, 0x0408
    2264:	85 a1       	lds	r24, 0x45
    2266:	96 a1       	lds	r25, 0x46
    2268:	a7 a1       	lds	r26, 0x47
    226a:	b0 a5       	lds	r27, 0x60
    226c:	00 97       	sbiw	r24, 0x00	; 0
    226e:	a1 05       	cpc	r26, r1
    2270:	b1 05       	cpc	r27, r1
    2272:	79 f4       	brne	.+30     	; 0x2292 <ulTaskNotifyTake+0x44>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2274:	e0 91 07 04 	lds	r30, 0x0407
    2278:	f0 91 08 04 	lds	r31, 0x0408
    227c:	81 e0       	ldi	r24, 0x01	; 1
    227e:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2280:	61 15       	cp	r22, r1
    2282:	71 05       	cpc	r23, r1
    2284:	31 f0       	breq	.+12     	; 0x2292 <ulTaskNotifyTake+0x44>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    2286:	cb 01       	movw	r24, r22
    2288:	61 e0       	ldi	r22, 0x01	; 1
    228a:	0e 94 a3 09 	call	0x1346	; 0x1346 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    228e:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2292:	0f 90       	pop	r0
    2294:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    229c:	e0 91 07 04 	lds	r30, 0x0407
    22a0:	f0 91 08 04 	lds	r31, 0x0408
    22a4:	05 a1       	lds	r16, 0x45
    22a6:	16 a1       	lds	r17, 0x46
    22a8:	27 a1       	lds	r18, 0x47
    22aa:	30 a5       	lds	r19, 0x60

			if( ulReturn != 0UL )
    22ac:	01 15       	cp	r16, r1
    22ae:	11 05       	cpc	r17, r1
    22b0:	21 05       	cpc	r18, r1
    22b2:	31 05       	cpc	r19, r1
    22b4:	c1 f0       	breq	.+48     	; 0x22e6 <ulTaskNotifyTake+0x98>
			{
				if( xClearCountOnExit != pdFALSE )
    22b6:	cc 23       	and	r28, r28
    22b8:	49 f0       	breq	.+18     	; 0x22cc <ulTaskNotifyTake+0x7e>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    22ba:	e0 91 07 04 	lds	r30, 0x0407
    22be:	f0 91 08 04 	lds	r31, 0x0408
    22c2:	15 a2       	lds	r17, 0x95
    22c4:	16 a2       	lds	r17, 0x96
    22c6:	17 a2       	lds	r17, 0x97
    22c8:	10 a6       	lds	r17, 0xb0
    22ca:	0d c0       	rjmp	.+26     	; 0x22e6 <ulTaskNotifyTake+0x98>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
    22cc:	e0 91 07 04 	lds	r30, 0x0407
    22d0:	f0 91 08 04 	lds	r31, 0x0408
    22d4:	d9 01       	movw	r26, r18
    22d6:	c8 01       	movw	r24, r16
    22d8:	01 97       	sbiw	r24, 0x01	; 1
    22da:	a1 09       	sbc	r26, r1
    22dc:	b1 09       	sbc	r27, r1
    22de:	85 a3       	lds	r24, 0x55
    22e0:	96 a3       	lds	r25, 0x56
    22e2:	a7 a3       	lds	r26, 0x57
    22e4:	b0 a7       	lds	r27, 0x70
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    22e6:	e0 91 07 04 	lds	r30, 0x0407
    22ea:	f0 91 08 04 	lds	r31, 0x0408
    22ee:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    22f0:	0f 90       	pop	r0
    22f2:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
	}
    22f4:	60 2f       	mov	r22, r16
    22f6:	71 2f       	mov	r23, r17
    22f8:	82 2f       	mov	r24, r18
    22fa:	93 2f       	mov	r25, r19
    22fc:	cf 91       	pop	r28
    22fe:	1f 91       	pop	r17
    2300:	0f 91       	pop	r16
    2302:	08 95       	ret

00002304 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    2304:	8f 92       	push	r8
    2306:	9f 92       	push	r9
    2308:	af 92       	push	r10
    230a:	bf 92       	push	r11
    230c:	ef 92       	push	r14
    230e:	ff 92       	push	r15
    2310:	0f 93       	push	r16
    2312:	1f 93       	push	r17
    2314:	dc 01       	movw	r26, r24
    2316:	cb 01       	movw	r24, r22
    2318:	49 01       	movw	r8, r18
    231a:	5a 01       	movw	r10, r20
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    231c:	0f b6       	in	r0, 0x3f	; 63
    231e:	f8 94       	cli
    2320:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    2322:	e0 91 07 04 	lds	r30, 0x0407
    2326:	f0 91 08 04 	lds	r31, 0x0408
    232a:	21 a5       	lds	r18, 0x61
    232c:	22 30       	cpi	r18, 0x02	; 2
    232e:	19 f1       	breq	.+70     	; 0x2376 <xTaskNotifyWait+0x72>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    2330:	e0 91 07 04 	lds	r30, 0x0407
    2334:	f0 91 08 04 	lds	r31, 0x0408
    2338:	45 a1       	lds	r20, 0x45
    233a:	56 a1       	lds	r21, 0x46
    233c:	67 a1       	lds	r22, 0x47
    233e:	70 a5       	lds	r23, 0x60
    2340:	80 95       	com	r24
    2342:	90 95       	com	r25
    2344:	a0 95       	com	r26
    2346:	b0 95       	com	r27
    2348:	84 23       	and	r24, r20
    234a:	95 23       	and	r25, r21
    234c:	a6 23       	and	r26, r22
    234e:	b7 23       	and	r27, r23
    2350:	85 a3       	lds	r24, 0x55
    2352:	96 a3       	lds	r25, 0x56
    2354:	a7 a3       	lds	r26, 0x57
    2356:	b0 a7       	lds	r27, 0x70

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    2358:	e0 91 07 04 	lds	r30, 0x0407
    235c:	f0 91 08 04 	lds	r31, 0x0408
    2360:	81 e0       	ldi	r24, 0x01	; 1
    2362:	81 a7       	lds	r24, 0x71

				if( xTicksToWait > ( TickType_t ) 0 )
    2364:	e1 14       	cp	r14, r1
    2366:	f1 04       	cpc	r15, r1
    2368:	31 f0       	breq	.+12     	; 0x2376 <xTaskNotifyWait+0x72>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    236a:	c7 01       	movw	r24, r14
    236c:	61 e0       	ldi	r22, 0x01	; 1
    236e:	0e 94 a3 09 	call	0x1346	; 0x1346 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    2372:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2376:	0f 90       	pop	r0
    2378:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    237a:	0f b6       	in	r0, 0x3f	; 63
    237c:	f8 94       	cli
    237e:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    2380:	01 15       	cp	r16, r1
    2382:	11 05       	cpc	r17, r1
    2384:	69 f0       	breq	.+26     	; 0x23a0 <xTaskNotifyWait+0x9c>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    2386:	e0 91 07 04 	lds	r30, 0x0407
    238a:	f0 91 08 04 	lds	r31, 0x0408
    238e:	85 a1       	lds	r24, 0x45
    2390:	96 a1       	lds	r25, 0x46
    2392:	a7 a1       	lds	r26, 0x47
    2394:	b0 a5       	lds	r27, 0x60
    2396:	f8 01       	movw	r30, r16
    2398:	80 83       	st	Z, r24
    239a:	91 83       	std	Z+1, r25	; 0x01
    239c:	a2 83       	std	Z+2, r26	; 0x02
    239e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    23a0:	e0 91 07 04 	lds	r30, 0x0407
    23a4:	f0 91 08 04 	lds	r31, 0x0408
    23a8:	81 a5       	lds	r24, 0x61
    23aa:	81 30       	cpi	r24, 0x01	; 1
    23ac:	b1 f0       	breq	.+44     	; 0x23da <xTaskNotifyWait+0xd6>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    23ae:	e0 91 07 04 	lds	r30, 0x0407
    23b2:	f0 91 08 04 	lds	r31, 0x0408
    23b6:	85 a1       	lds	r24, 0x45
    23b8:	96 a1       	lds	r25, 0x46
    23ba:	a7 a1       	lds	r26, 0x47
    23bc:	b0 a5       	lds	r27, 0x60
    23be:	80 94       	com	r8
    23c0:	90 94       	com	r9
    23c2:	a0 94       	com	r10
    23c4:	b0 94       	com	r11
    23c6:	88 22       	and	r8, r24
    23c8:	99 22       	and	r9, r25
    23ca:	aa 22       	and	r10, r26
    23cc:	bb 22       	and	r11, r27
    23ce:	85 a2       	lds	r24, 0x95
    23d0:	96 a2       	lds	r25, 0x96
    23d2:	a7 a2       	lds	r26, 0x97
    23d4:	b0 a6       	lds	r27, 0xb0
				xReturn = pdTRUE;
    23d6:	81 e0       	ldi	r24, 0x01	; 1
    23d8:	01 c0       	rjmp	.+2      	; 0x23dc <xTaskNotifyWait+0xd8>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    23da:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    23dc:	e0 91 07 04 	lds	r30, 0x0407
    23e0:	f0 91 08 04 	lds	r31, 0x0408
    23e4:	11 a6       	lds	r17, 0xb1
		}
		taskEXIT_CRITICAL();
    23e6:	0f 90       	pop	r0
    23e8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    23ea:	1f 91       	pop	r17
    23ec:	0f 91       	pop	r16
    23ee:	ff 90       	pop	r15
    23f0:	ef 90       	pop	r14
    23f2:	bf 90       	pop	r11
    23f4:	af 90       	pop	r10
    23f6:	9f 90       	pop	r9
    23f8:	8f 90       	pop	r8
    23fa:	08 95       	ret

000023fc <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    23fc:	0f 93       	push	r16
    23fe:	1f 93       	push	r17
    2400:	cf 93       	push	r28
    2402:	df 93       	push	r29
    2404:	ec 01       	movw	r28, r24
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    2406:	0f b6       	in	r0, 0x3f	; 63
    2408:	f8 94       	cli
    240a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    240c:	01 15       	cp	r16, r1
    240e:	11 05       	cpc	r17, r1
    2410:	49 f0       	breq	.+18     	; 0x2424 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    2412:	8d a1       	lds	r24, 0x4d
    2414:	9e a1       	lds	r25, 0x4e
    2416:	af a1       	lds	r26, 0x4f
    2418:	b8 a5       	lds	r27, 0x68
    241a:	f8 01       	movw	r30, r16
    241c:	80 83       	st	Z, r24
    241e:	91 83       	std	Z+1, r25	; 0x01
    2420:	a2 83       	std	Z+2, r26	; 0x02
    2422:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2424:	39 a5       	lds	r19, 0x69

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2426:	82 e0       	ldi	r24, 0x02	; 2
    2428:	89 a7       	lds	r24, 0x79

			switch( eAction )
    242a:	22 30       	cpi	r18, 0x02	; 2
    242c:	b9 f0       	breq	.+46     	; 0x245c <xTaskGenericNotify+0x60>
    242e:	23 30       	cpi	r18, 0x03	; 3
    2430:	18 f4       	brcc	.+6      	; 0x2438 <xTaskGenericNotify+0x3c>
    2432:	21 30       	cpi	r18, 0x01	; 1
    2434:	51 f5       	brne	.+84     	; 0x248a <xTaskGenericNotify+0x8e>
    2436:	05 c0       	rjmp	.+10     	; 0x2442 <xTaskGenericNotify+0x46>
    2438:	23 30       	cpi	r18, 0x03	; 3
    243a:	e1 f0       	breq	.+56     	; 0x2474 <xTaskGenericNotify+0x78>
    243c:	24 30       	cpi	r18, 0x04	; 4
    243e:	29 f5       	brne	.+74     	; 0x248a <xTaskGenericNotify+0x8e>
    2440:	1e c0       	rjmp	.+60     	; 0x247e <xTaskGenericNotify+0x82>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    2442:	8d a1       	lds	r24, 0x4d
    2444:	9e a1       	lds	r25, 0x4e
    2446:	af a1       	lds	r26, 0x4f
    2448:	b8 a5       	lds	r27, 0x68
    244a:	48 2b       	or	r20, r24
    244c:	59 2b       	or	r21, r25
    244e:	6a 2b       	or	r22, r26
    2450:	7b 2b       	or	r23, r27
    2452:	4d a3       	lds	r20, 0x5d
    2454:	5e a3       	lds	r21, 0x5e
    2456:	6f a3       	lds	r22, 0x5f
    2458:	78 a7       	lds	r23, 0x78
					break;
    245a:	17 c0       	rjmp	.+46     	; 0x248a <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    245c:	8d a1       	lds	r24, 0x4d
    245e:	9e a1       	lds	r25, 0x4e
    2460:	af a1       	lds	r26, 0x4f
    2462:	b8 a5       	lds	r27, 0x68
    2464:	01 96       	adiw	r24, 0x01	; 1
    2466:	a1 1d       	adc	r26, r1
    2468:	b1 1d       	adc	r27, r1
    246a:	8d a3       	lds	r24, 0x5d
    246c:	9e a3       	lds	r25, 0x5e
    246e:	af a3       	lds	r26, 0x5f
    2470:	b8 a7       	lds	r27, 0x78
					break;
    2472:	0b c0       	rjmp	.+22     	; 0x248a <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    2474:	4d a3       	lds	r20, 0x5d
    2476:	5e a3       	lds	r21, 0x5e
    2478:	6f a3       	lds	r22, 0x5f
    247a:	78 a7       	lds	r23, 0x78
					break;
    247c:	06 c0       	rjmp	.+12     	; 0x248a <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    247e:	32 30       	cpi	r19, 0x02	; 2
    2480:	71 f1       	breq	.+92     	; 0x24de <xTaskGenericNotify+0xe2>
					{
						pxTCB->ulNotifiedValue = ulValue;
    2482:	4d a3       	lds	r20, 0x5d
    2484:	5e a3       	lds	r21, 0x5e
    2486:	6f a3       	lds	r22, 0x5f
    2488:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    248a:	31 30       	cpi	r19, 0x01	; 1
    248c:	51 f5       	brne	.+84     	; 0x24e2 <xTaskGenericNotify+0xe6>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    248e:	8e 01       	movw	r16, r28
    2490:	0e 5f       	subi	r16, 0xFE	; 254
    2492:	1f 4f       	sbci	r17, 0xFF	; 255
    2494:	c8 01       	movw	r24, r16
    2496:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    249a:	8e 89       	ldd	r24, Y+22	; 0x16
    249c:	90 91 10 04 	lds	r25, 0x0410
    24a0:	98 17       	cp	r25, r24
    24a2:	10 f4       	brcc	.+4      	; 0x24a8 <xTaskGenericNotify+0xac>
    24a4:	80 93 10 04 	sts	0x0410, r24
    24a8:	90 e0       	ldi	r25, 0x00	; 0
    24aa:	9c 01       	movw	r18, r24
    24ac:	22 0f       	add	r18, r18
    24ae:	33 1f       	adc	r19, r19
    24b0:	22 0f       	add	r18, r18
    24b2:	33 1f       	adc	r19, r19
    24b4:	22 0f       	add	r18, r18
    24b6:	33 1f       	adc	r19, r19
    24b8:	82 0f       	add	r24, r18
    24ba:	93 1f       	adc	r25, r19
    24bc:	86 5e       	subi	r24, 0xE6	; 230
    24be:	9b 4f       	sbci	r25, 0xFB	; 251
    24c0:	b8 01       	movw	r22, r16
    24c2:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    24c6:	e0 91 07 04 	lds	r30, 0x0407
    24ca:	f0 91 08 04 	lds	r31, 0x0408
    24ce:	9e 89       	ldd	r25, Y+22	; 0x16
    24d0:	86 89       	ldd	r24, Z+22	; 0x16
    24d2:	89 17       	cp	r24, r25
    24d4:	40 f4       	brcc	.+16     	; 0x24e6 <xTaskGenericNotify+0xea>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    24d6:	0e 94 88 04 	call	0x910	; 0x910 <vPortYield>
    24da:	81 e0       	ldi	r24, 0x01	; 1
    24dc:	05 c0       	rjmp	.+10     	; 0x24e8 <xTaskGenericNotify+0xec>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    24de:	80 e0       	ldi	r24, 0x00	; 0
    24e0:	03 c0       	rjmp	.+6      	; 0x24e8 <xTaskGenericNotify+0xec>

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    24e2:	81 e0       	ldi	r24, 0x01	; 1
    24e4:	01 c0       	rjmp	.+2      	; 0x24e8 <xTaskGenericNotify+0xec>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    24e6:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    24e8:	0f 90       	pop	r0
    24ea:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    24ec:	df 91       	pop	r29
    24ee:	cf 91       	pop	r28
    24f0:	1f 91       	pop	r17
    24f2:	0f 91       	pop	r16
    24f4:	08 95       	ret

000024f6 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    24f6:	ef 92       	push	r14
    24f8:	ff 92       	push	r15
    24fa:	0f 93       	push	r16
    24fc:	1f 93       	push	r17
    24fe:	cf 93       	push	r28
    2500:	df 93       	push	r29
    2502:	ec 01       	movw	r28, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    2504:	01 15       	cp	r16, r1
    2506:	11 05       	cpc	r17, r1
    2508:	49 f0       	breq	.+18     	; 0x251c <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    250a:	8d a1       	lds	r24, 0x4d
    250c:	9e a1       	lds	r25, 0x4e
    250e:	af a1       	lds	r26, 0x4f
    2510:	b8 a5       	lds	r27, 0x68
    2512:	f8 01       	movw	r30, r16
    2514:	80 83       	st	Z, r24
    2516:	91 83       	std	Z+1, r25	; 0x01
    2518:	a2 83       	std	Z+2, r26	; 0x02
    251a:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    251c:	39 a5       	lds	r19, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    251e:	82 e0       	ldi	r24, 0x02	; 2
    2520:	89 a7       	lds	r24, 0x79

			switch( eAction )
    2522:	22 30       	cpi	r18, 0x02	; 2
    2524:	b9 f0       	breq	.+46     	; 0x2554 <xTaskGenericNotifyFromISR+0x5e>
    2526:	23 30       	cpi	r18, 0x03	; 3
    2528:	18 f4       	brcc	.+6      	; 0x2530 <xTaskGenericNotifyFromISR+0x3a>
    252a:	21 30       	cpi	r18, 0x01	; 1
    252c:	59 f5       	brne	.+86     	; 0x2584 <xTaskGenericNotifyFromISR+0x8e>
    252e:	05 c0       	rjmp	.+10     	; 0x253a <xTaskGenericNotifyFromISR+0x44>
    2530:	23 30       	cpi	r18, 0x03	; 3
    2532:	e1 f0       	breq	.+56     	; 0x256c <xTaskGenericNotifyFromISR+0x76>
    2534:	24 30       	cpi	r18, 0x04	; 4
    2536:	31 f5       	brne	.+76     	; 0x2584 <xTaskGenericNotifyFromISR+0x8e>
    2538:	1e c0       	rjmp	.+60     	; 0x2576 <xTaskGenericNotifyFromISR+0x80>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    253a:	8d a1       	lds	r24, 0x4d
    253c:	9e a1       	lds	r25, 0x4e
    253e:	af a1       	lds	r26, 0x4f
    2540:	b8 a5       	lds	r27, 0x68
    2542:	84 2b       	or	r24, r20
    2544:	95 2b       	or	r25, r21
    2546:	a6 2b       	or	r26, r22
    2548:	b7 2b       	or	r27, r23
    254a:	8d a3       	lds	r24, 0x5d
    254c:	9e a3       	lds	r25, 0x5e
    254e:	af a3       	lds	r26, 0x5f
    2550:	b8 a7       	lds	r27, 0x78
					break;
    2552:	18 c0       	rjmp	.+48     	; 0x2584 <xTaskGenericNotifyFromISR+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    2554:	8d a1       	lds	r24, 0x4d
    2556:	9e a1       	lds	r25, 0x4e
    2558:	af a1       	lds	r26, 0x4f
    255a:	b8 a5       	lds	r27, 0x68
    255c:	01 96       	adiw	r24, 0x01	; 1
    255e:	a1 1d       	adc	r26, r1
    2560:	b1 1d       	adc	r27, r1
    2562:	8d a3       	lds	r24, 0x5d
    2564:	9e a3       	lds	r25, 0x5e
    2566:	af a3       	lds	r26, 0x5f
    2568:	b8 a7       	lds	r27, 0x78
					break;
    256a:	0c c0       	rjmp	.+24     	; 0x2584 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    256c:	4d a3       	lds	r20, 0x5d
    256e:	5e a3       	lds	r21, 0x5e
    2570:	6f a3       	lds	r22, 0x5f
    2572:	78 a7       	lds	r23, 0x78
					break;
    2574:	07 c0       	rjmp	.+14     	; 0x2584 <xTaskGenericNotifyFromISR+0x8e>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    2576:	32 30       	cpi	r19, 0x02	; 2
    2578:	09 f4       	brne	.+2      	; 0x257c <xTaskGenericNotifyFromISR+0x86>
    257a:	41 c0       	rjmp	.+130    	; 0x25fe <xTaskGenericNotifyFromISR+0x108>
					{
						pxTCB->ulNotifiedValue = ulValue;
    257c:	4d a3       	lds	r20, 0x5d
    257e:	5e a3       	lds	r21, 0x5e
    2580:	6f a3       	lds	r22, 0x5f
    2582:	78 a7       	lds	r23, 0x78

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2584:	31 30       	cpi	r19, 0x01	; 1
    2586:	e9 f5       	brne	.+122    	; 0x2602 <xTaskGenericNotifyFromISR+0x10c>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2588:	80 91 09 04 	lds	r24, 0x0409
    258c:	88 23       	and	r24, r24
    258e:	e9 f4       	brne	.+58     	; 0x25ca <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    2590:	8e 01       	movw	r16, r28
    2592:	0e 5f       	subi	r16, 0xFE	; 254
    2594:	1f 4f       	sbci	r17, 0xFF	; 255
    2596:	c8 01       	movw	r24, r16
    2598:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    259c:	8e 89       	ldd	r24, Y+22	; 0x16
    259e:	90 91 10 04 	lds	r25, 0x0410
    25a2:	98 17       	cp	r25, r24
    25a4:	10 f4       	brcc	.+4      	; 0x25aa <xTaskGenericNotifyFromISR+0xb4>
    25a6:	80 93 10 04 	sts	0x0410, r24
    25aa:	90 e0       	ldi	r25, 0x00	; 0
    25ac:	9c 01       	movw	r18, r24
    25ae:	22 0f       	add	r18, r18
    25b0:	33 1f       	adc	r19, r19
    25b2:	22 0f       	add	r18, r18
    25b4:	33 1f       	adc	r19, r19
    25b6:	22 0f       	add	r18, r18
    25b8:	33 1f       	adc	r19, r19
    25ba:	82 0f       	add	r24, r18
    25bc:	93 1f       	adc	r25, r19
    25be:	86 5e       	subi	r24, 0xE6	; 230
    25c0:	9b 4f       	sbci	r25, 0xFB	; 251
    25c2:	b8 01       	movw	r22, r16
    25c4:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    25c8:	07 c0       	rjmp	.+14     	; 0x25d8 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    25ca:	be 01       	movw	r22, r28
    25cc:	64 5f       	subi	r22, 0xF4	; 244
    25ce:	7f 4f       	sbci	r23, 0xFF	; 255
    25d0:	89 e5       	ldi	r24, 0x59	; 89
    25d2:	94 e0       	ldi	r25, 0x04	; 4
    25d4:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    25d8:	e0 91 07 04 	lds	r30, 0x0407
    25dc:	f0 91 08 04 	lds	r31, 0x0408
    25e0:	9e 89       	ldd	r25, Y+22	; 0x16
    25e2:	86 89       	ldd	r24, Z+22	; 0x16
    25e4:	89 17       	cp	r24, r25
    25e6:	78 f4       	brcc	.+30     	; 0x2606 <xTaskGenericNotifyFromISR+0x110>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    25e8:	e1 14       	cp	r14, r1
    25ea:	f1 04       	cpc	r15, r1
    25ec:	21 f0       	breq	.+8      	; 0x25f6 <xTaskGenericNotifyFromISR+0x100>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	f7 01       	movw	r30, r14
    25f2:	80 83       	st	Z, r24
    25f4:	09 c0       	rjmp	.+18     	; 0x2608 <xTaskGenericNotifyFromISR+0x112>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	80 93 0d 04 	sts	0x040D, r24
    25fc:	05 c0       	rjmp	.+10     	; 0x2608 <xTaskGenericNotifyFromISR+0x112>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    25fe:	80 e0       	ldi	r24, 0x00	; 0
    2600:	03 c0       	rjmp	.+6      	; 0x2608 <xTaskGenericNotifyFromISR+0x112>

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2602:	81 e0       	ldi	r24, 0x01	; 1
    2604:	01 c0       	rjmp	.+2      	; 0x2608 <xTaskGenericNotifyFromISR+0x112>
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    2606:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    2608:	df 91       	pop	r29
    260a:	cf 91       	pop	r28
    260c:	1f 91       	pop	r17
    260e:	0f 91       	pop	r16
    2610:	ff 90       	pop	r15
    2612:	ef 90       	pop	r14
    2614:	08 95       	ret

00002616 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    2616:	ef 92       	push	r14
    2618:	ff 92       	push	r15
    261a:	0f 93       	push	r16
    261c:	1f 93       	push	r17
    261e:	cf 93       	push	r28
    2620:	df 93       	push	r29
    2622:	ec 01       	movw	r28, r24
    2624:	8b 01       	movw	r16, r22

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    2626:	29 a5       	lds	r18, 0x69
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    2628:	82 e0       	ldi	r24, 0x02	; 2
    262a:	89 a7       	lds	r24, 0x79

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    262c:	8d a1       	lds	r24, 0x4d
    262e:	9e a1       	lds	r25, 0x4e
    2630:	af a1       	lds	r26, 0x4f
    2632:	b8 a5       	lds	r27, 0x68
    2634:	01 96       	adiw	r24, 0x01	; 1
    2636:	a1 1d       	adc	r26, r1
    2638:	b1 1d       	adc	r27, r1
    263a:	8d a3       	lds	r24, 0x5d
    263c:	9e a3       	lds	r25, 0x5e
    263e:	af a3       	lds	r26, 0x5f
    2640:	b8 a7       	lds	r27, 0x78

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    2642:	21 30       	cpi	r18, 0x01	; 1
    2644:	e9 f5       	brne	.+122    	; 0x26c0 <vTaskNotifyGiveFromISR+0xaa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2646:	80 91 09 04 	lds	r24, 0x0409
    264a:	88 23       	and	r24, r24
    264c:	01 f5       	brne	.+64     	; 0x268e <vTaskNotifyGiveFromISR+0x78>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    264e:	ee 24       	eor	r14, r14
    2650:	ff 24       	eor	r15, r15
    2652:	68 94       	set
    2654:	e1 f8       	bld	r14, 1
    2656:	ec 0e       	add	r14, r28
    2658:	fd 1e       	adc	r15, r29
    265a:	c7 01       	movw	r24, r14
    265c:	0e 94 9a 03 	call	0x734	; 0x734 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    2660:	8e 89       	ldd	r24, Y+22	; 0x16
    2662:	90 91 10 04 	lds	r25, 0x0410
    2666:	98 17       	cp	r25, r24
    2668:	10 f4       	brcc	.+4      	; 0x266e <vTaskNotifyGiveFromISR+0x58>
    266a:	80 93 10 04 	sts	0x0410, r24
    266e:	90 e0       	ldi	r25, 0x00	; 0
    2670:	9c 01       	movw	r18, r24
    2672:	22 0f       	add	r18, r18
    2674:	33 1f       	adc	r19, r19
    2676:	22 0f       	add	r18, r18
    2678:	33 1f       	adc	r19, r19
    267a:	22 0f       	add	r18, r18
    267c:	33 1f       	adc	r19, r19
    267e:	82 0f       	add	r24, r18
    2680:	93 1f       	adc	r25, r19
    2682:	86 5e       	subi	r24, 0xE6	; 230
    2684:	9b 4f       	sbci	r25, 0xFB	; 251
    2686:	b7 01       	movw	r22, r14
    2688:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
    268c:	07 c0       	rjmp	.+14     	; 0x269c <vTaskNotifyGiveFromISR+0x86>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    268e:	be 01       	movw	r22, r28
    2690:	64 5f       	subi	r22, 0xF4	; 244
    2692:	7f 4f       	sbci	r23, 0xFF	; 255
    2694:	89 e5       	ldi	r24, 0x59	; 89
    2696:	94 e0       	ldi	r25, 0x04	; 4
    2698:	0e 94 49 03 	call	0x692	; 0x692 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    269c:	e0 91 07 04 	lds	r30, 0x0407
    26a0:	f0 91 08 04 	lds	r31, 0x0408
    26a4:	9e 89       	ldd	r25, Y+22	; 0x16
    26a6:	86 89       	ldd	r24, Z+22	; 0x16
    26a8:	89 17       	cp	r24, r25
    26aa:	50 f4       	brcc	.+20     	; 0x26c0 <vTaskNotifyGiveFromISR+0xaa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    26ac:	01 15       	cp	r16, r1
    26ae:	11 05       	cpc	r17, r1
    26b0:	21 f0       	breq	.+8      	; 0x26ba <vTaskNotifyGiveFromISR+0xa4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    26b2:	81 e0       	ldi	r24, 0x01	; 1
    26b4:	f8 01       	movw	r30, r16
    26b6:	80 83       	st	Z, r24
    26b8:	03 c0       	rjmp	.+6      	; 0x26c0 <vTaskNotifyGiveFromISR+0xaa>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
    26ba:	81 e0       	ldi	r24, 0x01	; 1
    26bc:	80 93 0d 04 	sts	0x040D, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    26c0:	df 91       	pop	r29
    26c2:	cf 91       	pop	r28
    26c4:	1f 91       	pop	r17
    26c6:	0f 91       	pop	r16
    26c8:	ff 90       	pop	r15
    26ca:	ef 90       	pop	r14
    26cc:	08 95       	ret

000026ce <xTaskNotifyStateClear>:
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    26ce:	00 97       	sbiw	r24, 0x00	; 0
    26d0:	29 f4       	brne	.+10     	; 0x26dc <xTaskNotifyStateClear+0xe>
    26d2:	e0 91 07 04 	lds	r30, 0x0407
    26d6:	f0 91 08 04 	lds	r31, 0x0408
    26da:	01 c0       	rjmp	.+2      	; 0x26de <xTaskNotifyStateClear+0x10>
    26dc:	fc 01       	movw	r30, r24

		taskENTER_CRITICAL();
    26de:	0f b6       	in	r0, 0x3f	; 63
    26e0:	f8 94       	cli
    26e2:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    26e4:	81 a5       	lds	r24, 0x61
    26e6:	82 30       	cpi	r24, 0x02	; 2
    26e8:	19 f4       	brne	.+6      	; 0x26f0 <xTaskNotifyStateClear+0x22>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    26ea:	11 a6       	lds	r17, 0xb1
				xReturn = pdPASS;
    26ec:	81 e0       	ldi	r24, 0x01	; 1
    26ee:	01 c0       	rjmp	.+2      	; 0x26f2 <xTaskNotifyStateClear+0x24>
			}
			else
			{
				xReturn = pdFAIL;
    26f0:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    26f2:	0f 90       	pop	r0
    26f4:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    26f6:	08 95       	ret

000026f8 <memcpy>:
    26f8:	fb 01       	movw	r30, r22
    26fa:	dc 01       	movw	r26, r24
    26fc:	02 c0       	rjmp	.+4      	; 0x2702 <memcpy+0xa>
    26fe:	01 90       	ld	r0, Z+
    2700:	0d 92       	st	X+, r0
    2702:	41 50       	subi	r20, 0x01	; 1
    2704:	50 40       	sbci	r21, 0x00	; 0
    2706:	d8 f7       	brcc	.-10     	; 0x26fe <memcpy+0x6>
    2708:	08 95       	ret

0000270a <_exit>:
    270a:	f8 94       	cli

0000270c <__stop_program>:
    270c:	ff cf       	rjmp	.-2      	; 0x270c <__stop_program>
