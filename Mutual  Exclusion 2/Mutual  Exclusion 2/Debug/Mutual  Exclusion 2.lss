
Mutual  Exclusion 2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000db6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  00000db6  00000e4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000039c  0080006c  0080006c  00000e56  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e56  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000e88  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000250  00000000  00000000  00000ec4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002d88  00000000  00000000  00001114  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d2e  00000000  00000000  00003e9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001a22  00000000  00000000  00004bca  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006c4  00000000  00000000  000065ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000109e  00000000  00000000  00006cb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002837  00000000  00000000  00007d4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000278  00000000  00000000  0000a585  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 45 03 	jmp	0x68a	; 0x68a <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 eb       	ldi	r30, 0xB6	; 182
  68:	fd e0       	ldi	r31, 0x0D	; 13
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	ac 36       	cpi	r26, 0x6C	; 108
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	24 e0       	ldi	r18, 0x04	; 4
  78:	ac e6       	ldi	r26, 0x6C	; 108
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a8 30       	cpi	r26, 0x08	; 8
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <main>
  8a:	0c 94 d9 06 	jmp	0xdb2	; 0xdb2 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  92:	0f 93       	push	r16
  94:	1f 93       	push	r17
  96:	cf 93       	push	r28
  98:	df 93       	push	r29
  9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
  9c:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
  a0:	80 91 6c 00 	lds	r24, 0x006C	; 0x80006c <__data_end>
  a4:	81 11       	cpse	r24, r1
  a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
  a8:	e1 e7       	ldi	r30, 0x71	; 113
  aa:	f0 e0       	ldi	r31, 0x00	; 0
  ac:	86 e7       	ldi	r24, 0x76	; 118
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	91 83       	std	Z+1, r25	; 0x01
  b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
  b4:	13 82       	std	Z+3, r1	; 0x03
  b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
  b8:	ed e6       	ldi	r30, 0x6D	; 109
  ba:	f0 e0       	ldi	r31, 0x00	; 0
  bc:	8f e1       	ldi	r24, 0x1F	; 31
  be:	93 e0       	ldi	r25, 0x03	; 3
  c0:	93 83       	std	Z+3, r25	; 0x03
  c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
  c4:	11 82       	std	Z+1, r1	; 0x01
  c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
  c8:	a5 e7       	ldi	r26, 0x75	; 117
  ca:	b0 e0       	ldi	r27, 0x00	; 0
  cc:	14 96       	adiw	r26, 0x04	; 4
  ce:	9c 93       	st	X, r25
  d0:	8e 93       	st	-X, r24
  d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
  d4:	12 96       	adiw	r26, 0x02	; 2
  d6:	fc 93       	st	X, r31
  d8:	ee 93       	st	-X, r30
  da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
  dc:	81 e0       	ldi	r24, 0x01	; 1
  de:	80 93 6c 00 	sts	0x006C, r24	; 0x80006c <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  e2:	20 97       	sbiw	r28, 0x00	; 0
  e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
  e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
  e8:	9e 01       	movw	r18, r28
  ea:	2c 5f       	subi	r18, 0xFC	; 252
  ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
  ee:	23 96       	adiw	r28, 0x03	; 3
  f0:	ce 31       	cpi	r28, 0x1E	; 30
  f2:	d3 40       	sbci	r29, 0x03	; 3
  f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
  f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
  f8:	e0 91 71 00 	lds	r30, 0x0071	; 0x800071 <xStart>
  fc:	f0 91 72 00 	lds	r31, 0x0072	; 0x800072 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 100:	a1 e7       	ldi	r26, 0x71	; 113
 102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
 106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 10a:	82 81       	ldd	r24, Z+2	; 0x02
 10c:	93 81       	ldd	r25, Z+3	; 0x03
 10e:	82 17       	cp	r24, r18
 110:	93 07       	cpc	r25, r19
 112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
 114:	80 81       	ld	r24, Z
 116:	91 81       	ldd	r25, Z+1	; 0x01
 118:	00 97       	sbiw	r24, 0x00	; 0
 11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 11c:	c0 e0       	ldi	r28, 0x00	; 0
 11e:	ed 36       	cpi	r30, 0x6D	; 109
 120:	fc 07       	cpc	r31, r28
 122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
 124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 126:	cd 91       	ld	r28, X+
 128:	dc 91       	ld	r29, X
 12a:	11 97       	sbiw	r26, 0x01	; 1
 12c:	8e 01       	movw	r16, r28
 12e:	0c 5f       	subi	r16, 0xFC	; 252
 130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 132:	80 81       	ld	r24, Z
 134:	91 81       	ldd	r25, Z+1	; 0x01
 136:	8d 93       	st	X+, r24
 138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 13a:	82 81       	ldd	r24, Z+2	; 0x02
 13c:	93 81       	ldd	r25, Z+3	; 0x03
 13e:	82 1b       	sub	r24, r18
 140:	93 0b       	sbc	r25, r19
 142:	89 30       	cpi	r24, 0x09	; 9
 144:	91 05       	cpc	r25, r1
 146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 148:	bf 01       	movw	r22, r30
 14a:	62 0f       	add	r22, r18
 14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 14e:	db 01       	movw	r26, r22
 150:	13 96       	adiw	r26, 0x03	; 3
 152:	9c 93       	st	X, r25
 154:	8e 93       	st	-X, r24
 156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 158:	33 83       	std	Z+3, r19	; 0x03
 15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 15c:	12 96       	adiw	r26, 0x02	; 2
 15e:	4d 91       	ld	r20, X+
 160:	5c 91       	ld	r21, X
 162:	13 97       	sbiw	r26, 0x03	; 3
 164:	81 e7       	ldi	r24, 0x71	; 113
 166:	90 e0       	ldi	r25, 0x00	; 0
 168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
 16a:	cd 01       	movw	r24, r26
 16c:	ec 01       	movw	r28, r24
 16e:	a8 81       	ld	r26, Y
 170:	b9 81       	ldd	r27, Y+1	; 0x01
 172:	12 96       	adiw	r26, 0x02	; 2
 174:	2d 91       	ld	r18, X+
 176:	3c 91       	ld	r19, X
 178:	13 97       	sbiw	r26, 0x03	; 3
 17a:	24 17       	cp	r18, r20
 17c:	35 07       	cpc	r19, r21
 17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
 180:	eb 01       	movw	r28, r22
 182:	b9 83       	std	Y+1, r27	; 0x01
 184:	a8 83       	st	Y, r26
 186:	dc 01       	movw	r26, r24
 188:	6d 93       	st	X+, r22
 18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 194:	22 81       	ldd	r18, Z+2	; 0x02
 196:	33 81       	ldd	r19, Z+3	; 0x03
 198:	82 1b       	sub	r24, r18
 19a:	93 0b       	sbc	r25, r19
 19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 1a6:	00 e0       	ldi	r16, 0x00	; 0
 1a8:	10 e0       	ldi	r17, 0x00	; 0
 1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
 1ac:	00 e0       	ldi	r16, 0x00	; 0
 1ae:	10 e0       	ldi	r17, 0x00	; 0
 1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
 1b2:	00 e0       	ldi	r16, 0x00	; 0
 1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 1b6:	0e 94 a3 05 	call	0xb46	; 0xb46 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 1ba:	c8 01       	movw	r24, r16
 1bc:	df 91       	pop	r29
 1be:	cf 91       	pop	r28
 1c0:	1f 91       	pop	r17
 1c2:	0f 91       	pop	r16
 1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 1c6:	0f 93       	push	r16
 1c8:	1f 93       	push	r17
 1ca:	cf 93       	push	r28
 1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 1ce:	00 97       	sbiw	r24, 0x00	; 0
 1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
 1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 1d4:	8c 01       	movw	r16, r24
 1d6:	04 50       	subi	r16, 0x04	; 4
 1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 1da:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 1de:	f8 01       	movw	r30, r16
 1e0:	42 81       	ldd	r20, Z+2	; 0x02
 1e2:	53 81       	ldd	r21, Z+3	; 0x03
 1e4:	a1 e7       	ldi	r26, 0x71	; 113
 1e6:	b0 e0       	ldi	r27, 0x00	; 0
 1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
 1ea:	df 01       	movw	r26, r30
 1ec:	ed 91       	ld	r30, X+
 1ee:	fc 91       	ld	r31, X
 1f0:	11 97       	sbiw	r26, 0x01	; 1
 1f2:	22 81       	ldd	r18, Z+2	; 0x02
 1f4:	33 81       	ldd	r19, Z+3	; 0x03
 1f6:	24 17       	cp	r18, r20
 1f8:	35 07       	cpc	r19, r21
 1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
 1fc:	24 97       	sbiw	r28, 0x04	; 4
 1fe:	f9 83       	std	Y+1, r31	; 0x01
 200:	e8 83       	st	Y, r30
 202:	0d 93       	st	X+, r16
 204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
 20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
 20e:	8a 81       	ldd	r24, Y+2	; 0x02
 210:	9b 81       	ldd	r25, Y+3	; 0x03
 212:	82 0f       	add	r24, r18
 214:	93 1f       	adc	r25, r19
 216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 21e:	0e 94 a3 05 	call	0xb46	; 0xb46 <xTaskResumeAll>
	}
}
 222:	df 91       	pop	r29
 224:	cf 91       	pop	r28
 226:	1f 91       	pop	r17
 228:	0f 91       	pop	r16
 22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 22e:	03 96       	adiw	r24, 0x03	; 3
 230:	92 83       	std	Z+2, r25	; 0x02
 232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 234:	2f ef       	ldi	r18, 0xFF	; 255
 236:	3f ef       	ldi	r19, 0xFF	; 255
 238:	34 83       	std	Z+4, r19	; 0x04
 23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 23c:	96 83       	std	Z+6, r25	; 0x06
 23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 240:	90 87       	std	Z+8, r25	; 0x08
 242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 244:	10 82       	st	Z, r1
 246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 248:	fc 01       	movw	r30, r24
 24a:	11 86       	std	Z+9, r1	; 0x09
 24c:	10 86       	std	Z+8, r1	; 0x08
 24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 250:	cf 93       	push	r28
 252:	df 93       	push	r29
 254:	9c 01       	movw	r18, r24
 256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 258:	dc 01       	movw	r26, r24
 25a:	11 96       	adiw	r26, 0x01	; 1
 25c:	cd 91       	ld	r28, X+
 25e:	dc 91       	ld	r29, X
 260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 262:	d3 83       	std	Z+3, r29	; 0x03
 264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 266:	8c 81       	ldd	r24, Y+4	; 0x04
 268:	9d 81       	ldd	r25, Y+5	; 0x05
 26a:	95 83       	std	Z+5, r25	; 0x05
 26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 26e:	8c 81       	ldd	r24, Y+4	; 0x04
 270:	9d 81       	ldd	r25, Y+5	; 0x05
 272:	dc 01       	movw	r26, r24
 274:	13 96       	adiw	r26, 0x03	; 3
 276:	7c 93       	st	X, r23
 278:	6e 93       	st	-X, r22
 27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 27c:	7d 83       	std	Y+5, r23	; 0x05
 27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 280:	31 87       	std	Z+9, r19	; 0x09
 282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 284:	f9 01       	movw	r30, r18
 286:	80 81       	ld	r24, Z
 288:	8f 5f       	subi	r24, 0xFF	; 255
 28a:	80 83       	st	Z, r24
}
 28c:	df 91       	pop	r29
 28e:	cf 91       	pop	r28
 290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 292:	cf 93       	push	r28
 294:	df 93       	push	r29
 296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 298:	48 81       	ld	r20, Y
 29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 29c:	4f 3f       	cpi	r20, 0xFF	; 255
 29e:	2f ef       	ldi	r18, 0xFF	; 255
 2a0:	52 07       	cpc	r21, r18
 2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 2a4:	fc 01       	movw	r30, r24
 2a6:	a7 81       	ldd	r26, Z+7	; 0x07
 2a8:	b0 85       	ldd	r27, Z+8	; 0x08
 2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 2ac:	dc 01       	movw	r26, r24
 2ae:	13 96       	adiw	r26, 0x03	; 3
 2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
 2b2:	df 01       	movw	r26, r30
 2b4:	12 96       	adiw	r26, 0x02	; 2
 2b6:	ed 91       	ld	r30, X+
 2b8:	fc 91       	ld	r31, X
 2ba:	13 97       	sbiw	r26, 0x03	; 3
 2bc:	20 81       	ld	r18, Z
 2be:	31 81       	ldd	r19, Z+1	; 0x01
 2c0:	42 17       	cp	r20, r18
 2c2:	53 07       	cpc	r21, r19
 2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 2c6:	12 96       	adiw	r26, 0x02	; 2
 2c8:	ed 91       	ld	r30, X+
 2ca:	fc 91       	ld	r31, X
 2cc:	13 97       	sbiw	r26, 0x03	; 3
 2ce:	fb 83       	std	Y+3, r31	; 0x03
 2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 2d2:	d5 83       	std	Z+5, r29	; 0x05
 2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 2d6:	bd 83       	std	Y+5, r27	; 0x05
 2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 2da:	13 96       	adiw	r26, 0x03	; 3
 2dc:	dc 93       	st	X, r29
 2de:	ce 93       	st	-X, r28
 2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 2e2:	99 87       	std	Y+9, r25	; 0x09
 2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 2e6:	fc 01       	movw	r30, r24
 2e8:	20 81       	ld	r18, Z
 2ea:	2f 5f       	subi	r18, 0xFF	; 255
 2ec:	20 83       	st	Z, r18
}
 2ee:	df 91       	pop	r29
 2f0:	cf 91       	pop	r28
 2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 2f4:	cf 93       	push	r28
 2f6:	df 93       	push	r29
 2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 2fa:	a0 85       	ldd	r26, Z+8	; 0x08
 2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 2fe:	c2 81       	ldd	r28, Z+2	; 0x02
 300:	d3 81       	ldd	r29, Z+3	; 0x03
 302:	84 81       	ldd	r24, Z+4	; 0x04
 304:	95 81       	ldd	r25, Z+5	; 0x05
 306:	9d 83       	std	Y+5, r25	; 0x05
 308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 30a:	c4 81       	ldd	r28, Z+4	; 0x04
 30c:	d5 81       	ldd	r29, Z+5	; 0x05
 30e:	82 81       	ldd	r24, Z+2	; 0x02
 310:	93 81       	ldd	r25, Z+3	; 0x03
 312:	9b 83       	std	Y+3, r25	; 0x03
 314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 316:	11 96       	adiw	r26, 0x01	; 1
 318:	8d 91       	ld	r24, X+
 31a:	9c 91       	ld	r25, X
 31c:	12 97       	sbiw	r26, 0x02	; 2
 31e:	e8 17       	cp	r30, r24
 320:	f9 07       	cpc	r31, r25
 322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 324:	84 81       	ldd	r24, Z+4	; 0x04
 326:	95 81       	ldd	r25, Z+5	; 0x05
 328:	12 96       	adiw	r26, 0x02	; 2
 32a:	9c 93       	st	X, r25
 32c:	8e 93       	st	-X, r24
 32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 330:	11 86       	std	Z+9, r1	; 0x09
 332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 334:	8c 91       	ld	r24, X
 336:	81 50       	subi	r24, 0x01	; 1
 338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 33a:	df 91       	pop	r29
 33c:	cf 91       	pop	r28
 33e:	08 95       	ret

00000340 <task1>:
		
	}
}
void task1(void *pv)
{
	DDRD|=(1<<7);
 340:	8f 9a       	sbi	0x11, 7	; 17
	while(1)
	{
		if(x==y)
 342:	20 91 04 04 	lds	r18, 0x0404	; 0x800404 <x>
 346:	30 91 05 04 	lds	r19, 0x0405	; 0x800405 <x+0x1>
 34a:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <y>
 34e:	90 91 07 04 	lds	r25, 0x0407	; 0x800407 <y+0x1>
 352:	28 17       	cp	r18, r24
 354:	39 07       	cpc	r19, r25
 356:	19 f4       	brne	.+6      	; 0x35e <task1+0x1e>
		{
			PORTD^=(1<<7);
 358:	82 b3       	in	r24, 0x12	; 18
 35a:	80 58       	subi	r24, 0x80	; 128
 35c:	82 bb       	out	0x12, r24	; 18
		}
		vTaskDelay(100);
 35e:	84 e6       	ldi	r24, 0x64	; 100
 360:	90 e0       	ldi	r25, 0x00	; 0
 362:	0e 94 22 06 	call	0xc44	; 0xc44 <vTaskDelay>
	}
 366:	ed cf       	rjmp	.-38     	; 0x342 <task1+0x2>

00000368 <task2>:

void task2(void *pv)
{
	while(1)
	{
		vTaskSuspendAll();
 368:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <vTaskSuspendAll>
		++x;
 36c:	80 91 04 04 	lds	r24, 0x0404	; 0x800404 <x>
 370:	90 91 05 04 	lds	r25, 0x0405	; 0x800405 <x+0x1>
 374:	01 96       	adiw	r24, 0x01	; 1
 376:	90 93 05 04 	sts	0x0405, r25	; 0x800405 <x+0x1>
 37a:	80 93 04 04 	sts	0x0404, r24	; 0x800404 <x>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 37e:	2f ef       	ldi	r18, 0xFF	; 255
 380:	81 ee       	ldi	r24, 0xE1	; 225
 382:	94 e0       	ldi	r25, 0x04	; 4
 384:	21 50       	subi	r18, 0x01	; 1
 386:	80 40       	sbci	r24, 0x00	; 0
 388:	90 40       	sbci	r25, 0x00	; 0
 38a:	e1 f7       	brne	.-8      	; 0x384 <task2+0x1c>
 38c:	00 c0       	rjmp	.+0      	; 0x38e <task2+0x26>
 38e:	00 00       	nop
		_delay_ms(200);
		++y;
 390:	80 91 06 04 	lds	r24, 0x0406	; 0x800406 <y>
 394:	90 91 07 04 	lds	r25, 0x0407	; 0x800407 <y+0x1>
 398:	01 96       	adiw	r24, 0x01	; 1
 39a:	90 93 07 04 	sts	0x0407, r25	; 0x800407 <y+0x1>
 39e:	80 93 06 04 	sts	0x0406, r24	; 0x800406 <y>
		xTaskResumeAll();
 3a2:	0e 94 a3 05 	call	0xb46	; 0xb46 <xTaskResumeAll>
 3a6:	e0 cf       	rjmp	.-64     	; 0x368 <task2>

000003a8 <main>:
void task1(void *pv);
void task2 (void *pv);
int main(void)
{
	/* create the tasks */
	xTaskCreate(task1,"M",100,NULL,2,NULL);
 3a8:	e1 2c       	mov	r14, r1
 3aa:	f1 2c       	mov	r15, r1
 3ac:	02 e0       	ldi	r16, 0x02	; 2
 3ae:	20 e0       	ldi	r18, 0x00	; 0
 3b0:	30 e0       	ldi	r19, 0x00	; 0
 3b2:	44 e6       	ldi	r20, 0x64	; 100
 3b4:	50 e0       	ldi	r21, 0x00	; 0
 3b6:	62 e6       	ldi	r22, 0x62	; 98
 3b8:	70 e0       	ldi	r23, 0x00	; 0
 3ba:	80 ea       	ldi	r24, 0xA0	; 160
 3bc:	91 e0       	ldi	r25, 0x01	; 1
 3be:	0e 94 bf 03 	call	0x77e	; 0x77e <xTaskCreate>
	xTaskCreate(task2,"N",100,NULL,1,NULL);
 3c2:	01 e0       	ldi	r16, 0x01	; 1
 3c4:	20 e0       	ldi	r18, 0x00	; 0
 3c6:	30 e0       	ldi	r19, 0x00	; 0
 3c8:	44 e6       	ldi	r20, 0x64	; 100
 3ca:	50 e0       	ldi	r21, 0x00	; 0
 3cc:	64 e6       	ldi	r22, 0x64	; 100
 3ce:	70 e0       	ldi	r23, 0x00	; 0
 3d0:	84 eb       	ldi	r24, 0xB4	; 180
 3d2:	91 e0       	ldi	r25, 0x01	; 1
 3d4:	0e 94 bf 03 	call	0x77e	; 0x77e <xTaskCreate>
	/* start os*/
	vTaskStartScheduler();
 3d8:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <vTaskStartScheduler>
 3dc:	ff cf       	rjmp	.-2      	; 0x3dc <main+0x34>

000003de <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 3de:	31 e1       	ldi	r19, 0x11	; 17
 3e0:	fc 01       	movw	r30, r24
 3e2:	30 83       	st	Z, r19
 3e4:	31 97       	sbiw	r30, 0x01	; 1
 3e6:	22 e2       	ldi	r18, 0x22	; 34
 3e8:	20 83       	st	Z, r18
 3ea:	31 97       	sbiw	r30, 0x01	; 1
 3ec:	a3 e3       	ldi	r26, 0x33	; 51
 3ee:	a0 83       	st	Z, r26
 3f0:	31 97       	sbiw	r30, 0x01	; 1
 3f2:	60 83       	st	Z, r22
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	70 83       	st	Z, r23
 3f8:	31 97       	sbiw	r30, 0x01	; 1
 3fa:	10 82       	st	Z, r1
 3fc:	31 97       	sbiw	r30, 0x01	; 1
 3fe:	60 e8       	ldi	r22, 0x80	; 128
 400:	60 83       	st	Z, r22
 402:	31 97       	sbiw	r30, 0x01	; 1
 404:	10 82       	st	Z, r1
 406:	31 97       	sbiw	r30, 0x01	; 1
 408:	62 e0       	ldi	r22, 0x02	; 2
 40a:	60 83       	st	Z, r22
 40c:	31 97       	sbiw	r30, 0x01	; 1
 40e:	63 e0       	ldi	r22, 0x03	; 3
 410:	60 83       	st	Z, r22
 412:	31 97       	sbiw	r30, 0x01	; 1
 414:	64 e0       	ldi	r22, 0x04	; 4
 416:	60 83       	st	Z, r22
 418:	31 97       	sbiw	r30, 0x01	; 1
 41a:	65 e0       	ldi	r22, 0x05	; 5
 41c:	60 83       	st	Z, r22
 41e:	31 97       	sbiw	r30, 0x01	; 1
 420:	66 e0       	ldi	r22, 0x06	; 6
 422:	60 83       	st	Z, r22
 424:	31 97       	sbiw	r30, 0x01	; 1
 426:	67 e0       	ldi	r22, 0x07	; 7
 428:	60 83       	st	Z, r22
 42a:	31 97       	sbiw	r30, 0x01	; 1
 42c:	68 e0       	ldi	r22, 0x08	; 8
 42e:	60 83       	st	Z, r22
 430:	31 97       	sbiw	r30, 0x01	; 1
 432:	69 e0       	ldi	r22, 0x09	; 9
 434:	60 83       	st	Z, r22
 436:	31 97       	sbiw	r30, 0x01	; 1
 438:	60 e1       	ldi	r22, 0x10	; 16
 43a:	60 83       	st	Z, r22
 43c:	31 97       	sbiw	r30, 0x01	; 1
 43e:	30 83       	st	Z, r19
 440:	31 97       	sbiw	r30, 0x01	; 1
 442:	32 e1       	ldi	r19, 0x12	; 18
 444:	30 83       	st	Z, r19
 446:	31 97       	sbiw	r30, 0x01	; 1
 448:	33 e1       	ldi	r19, 0x13	; 19
 44a:	30 83       	st	Z, r19
 44c:	31 97       	sbiw	r30, 0x01	; 1
 44e:	34 e1       	ldi	r19, 0x14	; 20
 450:	30 83       	st	Z, r19
 452:	31 97       	sbiw	r30, 0x01	; 1
 454:	35 e1       	ldi	r19, 0x15	; 21
 456:	30 83       	st	Z, r19
 458:	31 97       	sbiw	r30, 0x01	; 1
 45a:	36 e1       	ldi	r19, 0x16	; 22
 45c:	30 83       	st	Z, r19
 45e:	31 97       	sbiw	r30, 0x01	; 1
 460:	37 e1       	ldi	r19, 0x17	; 23
 462:	30 83       	st	Z, r19
 464:	31 97       	sbiw	r30, 0x01	; 1
 466:	38 e1       	ldi	r19, 0x18	; 24
 468:	30 83       	st	Z, r19
 46a:	31 97       	sbiw	r30, 0x01	; 1
 46c:	39 e1       	ldi	r19, 0x19	; 25
 46e:	30 83       	st	Z, r19
 470:	31 97       	sbiw	r30, 0x01	; 1
 472:	30 e2       	ldi	r19, 0x20	; 32
 474:	30 83       	st	Z, r19
 476:	31 97       	sbiw	r30, 0x01	; 1
 478:	31 e2       	ldi	r19, 0x21	; 33
 47a:	30 83       	st	Z, r19
 47c:	31 97       	sbiw	r30, 0x01	; 1
 47e:	20 83       	st	Z, r18
 480:	31 97       	sbiw	r30, 0x01	; 1
 482:	23 e2       	ldi	r18, 0x23	; 35
 484:	20 83       	st	Z, r18
 486:	31 97       	sbiw	r30, 0x01	; 1
 488:	40 83       	st	Z, r20
 48a:	31 97       	sbiw	r30, 0x01	; 1
 48c:	50 83       	st	Z, r21
 48e:	31 97       	sbiw	r30, 0x01	; 1
 490:	26 e2       	ldi	r18, 0x26	; 38
 492:	20 83       	st	Z, r18
 494:	31 97       	sbiw	r30, 0x01	; 1
 496:	27 e2       	ldi	r18, 0x27	; 39
 498:	20 83       	st	Z, r18
 49a:	31 97       	sbiw	r30, 0x01	; 1
 49c:	28 e2       	ldi	r18, 0x28	; 40
 49e:	20 83       	st	Z, r18
 4a0:	31 97       	sbiw	r30, 0x01	; 1
 4a2:	29 e2       	ldi	r18, 0x29	; 41
 4a4:	20 83       	st	Z, r18
 4a6:	31 97       	sbiw	r30, 0x01	; 1
 4a8:	20 e3       	ldi	r18, 0x30	; 48
 4aa:	20 83       	st	Z, r18
 4ac:	31 97       	sbiw	r30, 0x01	; 1
 4ae:	21 e3       	ldi	r18, 0x31	; 49
 4b0:	20 83       	st	Z, r18
 4b2:	86 97       	sbiw	r24, 0x26	; 38
 4b4:	08 95       	ret

000004b6 <xPortStartScheduler>:
 4b6:	1b bc       	out	0x2b, r1	; 43
 4b8:	8c e7       	ldi	r24, 0x7C	; 124
 4ba:	8a bd       	out	0x2a, r24	; 42
 4bc:	8b e0       	ldi	r24, 0x0B	; 11
 4be:	8e bd       	out	0x2e, r24	; 46
 4c0:	89 b7       	in	r24, 0x39	; 57
 4c2:	80 61       	ori	r24, 0x10	; 16
 4c4:	89 bf       	out	0x39, r24	; 57
 4c6:	a0 91 02 04 	lds	r26, 0x0402	; 0x800402 <pxCurrentTCB>
 4ca:	b0 91 03 04 	lds	r27, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 4ce:	cd 91       	ld	r28, X+
 4d0:	cd bf       	out	0x3d, r28	; 61
 4d2:	dd 91       	ld	r29, X+
 4d4:	de bf       	out	0x3e, r29	; 62
 4d6:	ff 91       	pop	r31
 4d8:	ef 91       	pop	r30
 4da:	df 91       	pop	r29
 4dc:	cf 91       	pop	r28
 4de:	bf 91       	pop	r27
 4e0:	af 91       	pop	r26
 4e2:	9f 91       	pop	r25
 4e4:	8f 91       	pop	r24
 4e6:	7f 91       	pop	r23
 4e8:	6f 91       	pop	r22
 4ea:	5f 91       	pop	r21
 4ec:	4f 91       	pop	r20
 4ee:	3f 91       	pop	r19
 4f0:	2f 91       	pop	r18
 4f2:	1f 91       	pop	r17
 4f4:	0f 91       	pop	r16
 4f6:	ff 90       	pop	r15
 4f8:	ef 90       	pop	r14
 4fa:	df 90       	pop	r13
 4fc:	cf 90       	pop	r12
 4fe:	bf 90       	pop	r11
 500:	af 90       	pop	r10
 502:	9f 90       	pop	r9
 504:	8f 90       	pop	r8
 506:	7f 90       	pop	r7
 508:	6f 90       	pop	r6
 50a:	5f 90       	pop	r5
 50c:	4f 90       	pop	r4
 50e:	3f 90       	pop	r3
 510:	2f 90       	pop	r2
 512:	1f 90       	pop	r1
 514:	0f 90       	pop	r0
 516:	0f be       	out	0x3f, r0	; 63
 518:	0f 90       	pop	r0
 51a:	08 95       	ret
 51c:	81 e0       	ldi	r24, 0x01	; 1
 51e:	08 95       	ret

00000520 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 520:	0f 92       	push	r0
 522:	0f b6       	in	r0, 0x3f	; 63
 524:	f8 94       	cli
 526:	0f 92       	push	r0
 528:	1f 92       	push	r1
 52a:	11 24       	eor	r1, r1
 52c:	2f 92       	push	r2
 52e:	3f 92       	push	r3
 530:	4f 92       	push	r4
 532:	5f 92       	push	r5
 534:	6f 92       	push	r6
 536:	7f 92       	push	r7
 538:	8f 92       	push	r8
 53a:	9f 92       	push	r9
 53c:	af 92       	push	r10
 53e:	bf 92       	push	r11
 540:	cf 92       	push	r12
 542:	df 92       	push	r13
 544:	ef 92       	push	r14
 546:	ff 92       	push	r15
 548:	0f 93       	push	r16
 54a:	1f 93       	push	r17
 54c:	2f 93       	push	r18
 54e:	3f 93       	push	r19
 550:	4f 93       	push	r20
 552:	5f 93       	push	r21
 554:	6f 93       	push	r22
 556:	7f 93       	push	r23
 558:	8f 93       	push	r24
 55a:	9f 93       	push	r25
 55c:	af 93       	push	r26
 55e:	bf 93       	push	r27
 560:	cf 93       	push	r28
 562:	df 93       	push	r29
 564:	ef 93       	push	r30
 566:	ff 93       	push	r31
 568:	a0 91 02 04 	lds	r26, 0x0402	; 0x800402 <pxCurrentTCB>
 56c:	b0 91 03 04 	lds	r27, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 570:	0d b6       	in	r0, 0x3d	; 61
 572:	0d 92       	st	X+, r0
 574:	0e b6       	in	r0, 0x3e	; 62
 576:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 578:	0e 94 73 06 	call	0xce6	; 0xce6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 57c:	a0 91 02 04 	lds	r26, 0x0402	; 0x800402 <pxCurrentTCB>
 580:	b0 91 03 04 	lds	r27, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 584:	cd 91       	ld	r28, X+
 586:	cd bf       	out	0x3d, r28	; 61
 588:	dd 91       	ld	r29, X+
 58a:	de bf       	out	0x3e, r29	; 62
 58c:	ff 91       	pop	r31
 58e:	ef 91       	pop	r30
 590:	df 91       	pop	r29
 592:	cf 91       	pop	r28
 594:	bf 91       	pop	r27
 596:	af 91       	pop	r26
 598:	9f 91       	pop	r25
 59a:	8f 91       	pop	r24
 59c:	7f 91       	pop	r23
 59e:	6f 91       	pop	r22
 5a0:	5f 91       	pop	r21
 5a2:	4f 91       	pop	r20
 5a4:	3f 91       	pop	r19
 5a6:	2f 91       	pop	r18
 5a8:	1f 91       	pop	r17
 5aa:	0f 91       	pop	r16
 5ac:	ff 90       	pop	r15
 5ae:	ef 90       	pop	r14
 5b0:	df 90       	pop	r13
 5b2:	cf 90       	pop	r12
 5b4:	bf 90       	pop	r11
 5b6:	af 90       	pop	r10
 5b8:	9f 90       	pop	r9
 5ba:	8f 90       	pop	r8
 5bc:	7f 90       	pop	r7
 5be:	6f 90       	pop	r6
 5c0:	5f 90       	pop	r5
 5c2:	4f 90       	pop	r4
 5c4:	3f 90       	pop	r3
 5c6:	2f 90       	pop	r2
 5c8:	1f 90       	pop	r1
 5ca:	0f 90       	pop	r0
 5cc:	0f be       	out	0x3f, r0	; 63
 5ce:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5d0:	08 95       	ret

000005d2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 5d2:	0f 92       	push	r0
 5d4:	0f b6       	in	r0, 0x3f	; 63
 5d6:	f8 94       	cli
 5d8:	0f 92       	push	r0
 5da:	1f 92       	push	r1
 5dc:	11 24       	eor	r1, r1
 5de:	2f 92       	push	r2
 5e0:	3f 92       	push	r3
 5e2:	4f 92       	push	r4
 5e4:	5f 92       	push	r5
 5e6:	6f 92       	push	r6
 5e8:	7f 92       	push	r7
 5ea:	8f 92       	push	r8
 5ec:	9f 92       	push	r9
 5ee:	af 92       	push	r10
 5f0:	bf 92       	push	r11
 5f2:	cf 92       	push	r12
 5f4:	df 92       	push	r13
 5f6:	ef 92       	push	r14
 5f8:	ff 92       	push	r15
 5fa:	0f 93       	push	r16
 5fc:	1f 93       	push	r17
 5fe:	2f 93       	push	r18
 600:	3f 93       	push	r19
 602:	4f 93       	push	r20
 604:	5f 93       	push	r21
 606:	6f 93       	push	r22
 608:	7f 93       	push	r23
 60a:	8f 93       	push	r24
 60c:	9f 93       	push	r25
 60e:	af 93       	push	r26
 610:	bf 93       	push	r27
 612:	cf 93       	push	r28
 614:	df 93       	push	r29
 616:	ef 93       	push	r30
 618:	ff 93       	push	r31
 61a:	a0 91 02 04 	lds	r26, 0x0402	; 0x800402 <pxCurrentTCB>
 61e:	b0 91 03 04 	lds	r27, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 622:	0d b6       	in	r0, 0x3d	; 61
 624:	0d 92       	st	X+, r0
 626:	0e b6       	in	r0, 0x3e	; 62
 628:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 62a:	0e 94 00 05 	call	0xa00	; 0xa00 <xTaskIncrementTick>
 62e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 630:	0e 94 73 06 	call	0xce6	; 0xce6 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 634:	a0 91 02 04 	lds	r26, 0x0402	; 0x800402 <pxCurrentTCB>
 638:	b0 91 03 04 	lds	r27, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 63c:	cd 91       	ld	r28, X+
 63e:	cd bf       	out	0x3d, r28	; 61
 640:	dd 91       	ld	r29, X+
 642:	de bf       	out	0x3e, r29	; 62
 644:	ff 91       	pop	r31
 646:	ef 91       	pop	r30
 648:	df 91       	pop	r29
 64a:	cf 91       	pop	r28
 64c:	bf 91       	pop	r27
 64e:	af 91       	pop	r26
 650:	9f 91       	pop	r25
 652:	8f 91       	pop	r24
 654:	7f 91       	pop	r23
 656:	6f 91       	pop	r22
 658:	5f 91       	pop	r21
 65a:	4f 91       	pop	r20
 65c:	3f 91       	pop	r19
 65e:	2f 91       	pop	r18
 660:	1f 91       	pop	r17
 662:	0f 91       	pop	r16
 664:	ff 90       	pop	r15
 666:	ef 90       	pop	r14
 668:	df 90       	pop	r13
 66a:	cf 90       	pop	r12
 66c:	bf 90       	pop	r11
 66e:	af 90       	pop	r10
 670:	9f 90       	pop	r9
 672:	8f 90       	pop	r8
 674:	7f 90       	pop	r7
 676:	6f 90       	pop	r6
 678:	5f 90       	pop	r5
 67a:	4f 90       	pop	r4
 67c:	3f 90       	pop	r3
 67e:	2f 90       	pop	r2
 680:	1f 90       	pop	r1
 682:	0f 90       	pop	r0
 684:	0f be       	out	0x3f, r0	; 63
 686:	0f 90       	pop	r0

	asm volatile ( "ret" );
 688:	08 95       	ret

0000068a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 68a:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <vPortYieldFromTick>
		asm volatile ( "reti" );
 68e:	18 95       	reti

00000690 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 690:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxDelayedTaskList>
 694:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxDelayedTaskList+0x1>
 698:	80 81       	ld	r24, Z
 69a:	81 11       	cpse	r24, r1
 69c:	07 c0       	rjmp	.+14     	; 0x6ac <prvResetNextTaskUnblockTime+0x1c>
 69e:	8f ef       	ldi	r24, 0xFF	; 255
 6a0:	9f ef       	ldi	r25, 0xFF	; 255
 6a2:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <xNextTaskUnblockTime+0x1>
 6a6:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <xNextTaskUnblockTime>
 6aa:	08 95       	ret
 6ac:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxDelayedTaskList>
 6b0:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxDelayedTaskList+0x1>
 6b4:	05 80       	ldd	r0, Z+5	; 0x05
 6b6:	f6 81       	ldd	r31, Z+6	; 0x06
 6b8:	e0 2d       	mov	r30, r0
 6ba:	06 80       	ldd	r0, Z+6	; 0x06
 6bc:	f7 81       	ldd	r31, Z+7	; 0x07
 6be:	e0 2d       	mov	r30, r0
 6c0:	82 81       	ldd	r24, Z+2	; 0x02
 6c2:	93 81       	ldd	r25, Z+3	; 0x03
 6c4:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <xNextTaskUnblockTime+0x1>
 6c8:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <xNextTaskUnblockTime>
 6cc:	08 95       	ret

000006ce <prvAddCurrentTaskToDelayedList>:
 6ce:	ff 92       	push	r15
 6d0:	0f 93       	push	r16
 6d2:	1f 93       	push	r17
 6d4:	cf 93       	push	r28
 6d6:	df 93       	push	r29
 6d8:	ec 01       	movw	r28, r24
 6da:	f6 2e       	mov	r15, r22
 6dc:	00 91 a0 03 	lds	r16, 0x03A0	; 0x8003a0 <xTickCount>
 6e0:	10 91 a1 03 	lds	r17, 0x03A1	; 0x8003a1 <xTickCount+0x1>
 6e4:	80 91 02 04 	lds	r24, 0x0402	; 0x800402 <pxCurrentTCB>
 6e8:	90 91 03 04 	lds	r25, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 6ec:	02 96       	adiw	r24, 0x02	; 2
 6ee:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 6f2:	cf 3f       	cpi	r28, 0xFF	; 255
 6f4:	8f ef       	ldi	r24, 0xFF	; 255
 6f6:	d8 07       	cpc	r29, r24
 6f8:	69 f4       	brne	.+26     	; 0x714 <prvAddCurrentTaskToDelayedList+0x46>
 6fa:	ff 20       	and	r15, r15
 6fc:	59 f0       	breq	.+22     	; 0x714 <prvAddCurrentTaskToDelayedList+0x46>
 6fe:	60 91 02 04 	lds	r22, 0x0402	; 0x800402 <pxCurrentTCB>
 702:	70 91 03 04 	lds	r23, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 706:	6e 5f       	subi	r22, 0xFE	; 254
 708:	7f 4f       	sbci	r23, 0xFF	; 255
 70a:	83 ea       	ldi	r24, 0xA3	; 163
 70c:	93 e0       	ldi	r25, 0x03	; 3
 70e:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
 712:	2f c0       	rjmp	.+94     	; 0x772 <prvAddCurrentTaskToDelayedList+0xa4>
 714:	c0 0f       	add	r28, r16
 716:	d1 1f       	adc	r29, r17
 718:	e0 91 02 04 	lds	r30, 0x0402	; 0x800402 <pxCurrentTCB>
 71c:	f0 91 03 04 	lds	r31, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 720:	d3 83       	std	Z+3, r29	; 0x03
 722:	c2 83       	std	Z+2, r28	; 0x02
 724:	c0 17       	cp	r28, r16
 726:	d1 07       	cpc	r29, r17
 728:	68 f4       	brcc	.+26     	; 0x744 <prvAddCurrentTaskToDelayedList+0x76>
 72a:	60 91 02 04 	lds	r22, 0x0402	; 0x800402 <pxCurrentTCB>
 72e:	70 91 03 04 	lds	r23, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 732:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <pxOverflowDelayedTaskList>
 736:	90 91 c0 03 	lds	r25, 0x03C0	; 0x8003c0 <pxOverflowDelayedTaskList+0x1>
 73a:	6e 5f       	subi	r22, 0xFE	; 254
 73c:	7f 4f       	sbci	r23, 0xFF	; 255
 73e:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
 742:	17 c0       	rjmp	.+46     	; 0x772 <prvAddCurrentTaskToDelayedList+0xa4>
 744:	60 91 02 04 	lds	r22, 0x0402	; 0x800402 <pxCurrentTCB>
 748:	70 91 03 04 	lds	r23, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 74c:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <pxDelayedTaskList>
 750:	90 91 c2 03 	lds	r25, 0x03C2	; 0x8003c2 <pxDelayedTaskList+0x1>
 754:	6e 5f       	subi	r22, 0xFE	; 254
 756:	7f 4f       	sbci	r23, 0xFF	; 255
 758:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
 75c:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <xNextTaskUnblockTime>
 760:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <xNextTaskUnblockTime+0x1>
 764:	c8 17       	cp	r28, r24
 766:	d9 07       	cpc	r29, r25
 768:	20 f4       	brcc	.+8      	; 0x772 <prvAddCurrentTaskToDelayedList+0xa4>
 76a:	d0 93 99 03 	sts	0x0399, r29	; 0x800399 <xNextTaskUnblockTime+0x1>
 76e:	c0 93 98 03 	sts	0x0398, r28	; 0x800398 <xNextTaskUnblockTime>
 772:	df 91       	pop	r29
 774:	cf 91       	pop	r28
 776:	1f 91       	pop	r17
 778:	0f 91       	pop	r16
 77a:	ff 90       	pop	r15
 77c:	08 95       	ret

0000077e <xTaskCreate>:
 77e:	4f 92       	push	r4
 780:	5f 92       	push	r5
 782:	6f 92       	push	r6
 784:	7f 92       	push	r7
 786:	8f 92       	push	r8
 788:	9f 92       	push	r9
 78a:	af 92       	push	r10
 78c:	bf 92       	push	r11
 78e:	cf 92       	push	r12
 790:	df 92       	push	r13
 792:	ef 92       	push	r14
 794:	ff 92       	push	r15
 796:	0f 93       	push	r16
 798:	1f 93       	push	r17
 79a:	cf 93       	push	r28
 79c:	df 93       	push	r29
 79e:	4c 01       	movw	r8, r24
 7a0:	6b 01       	movw	r12, r22
 7a2:	5a 01       	movw	r10, r20
 7a4:	29 01       	movw	r4, r18
 7a6:	ca 01       	movw	r24, r20
 7a8:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 7ac:	3c 01       	movw	r6, r24
 7ae:	89 2b       	or	r24, r25
 7b0:	09 f4       	brne	.+2      	; 0x7b4 <xTaskCreate+0x36>
 7b2:	e4 c0       	rjmp	.+456    	; 0x97c <__stack+0x11d>
 7b4:	8a e2       	ldi	r24, 0x2A	; 42
 7b6:	90 e0       	ldi	r25, 0x00	; 0
 7b8:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
 7bc:	ec 01       	movw	r28, r24
 7be:	89 2b       	or	r24, r25
 7c0:	71 f0       	breq	.+28     	; 0x7de <xTaskCreate+0x60>
 7c2:	78 8e       	std	Y+24, r7	; 0x18
 7c4:	6f 8a       	std	Y+23, r6	; 0x17
 7c6:	81 e0       	ldi	r24, 0x01	; 1
 7c8:	a8 1a       	sub	r10, r24
 7ca:	b1 08       	sbc	r11, r1
 7cc:	6a 0c       	add	r6, r10
 7ce:	7b 1c       	adc	r7, r11
 7d0:	d6 01       	movw	r26, r12
 7d2:	8c 91       	ld	r24, X
 7d4:	89 8f       	std	Y+25, r24	; 0x19
 7d6:	8c 91       	ld	r24, X
 7d8:	81 11       	cpse	r24, r1
 7da:	05 c0       	rjmp	.+10     	; 0x7e6 <xTaskCreate+0x68>
 7dc:	18 c0       	rjmp	.+48     	; 0x80e <xTaskCreate+0x90>
 7de:	c3 01       	movw	r24, r6
 7e0:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
 7e4:	cb c0       	rjmp	.+406    	; 0x97c <__stack+0x11d>
 7e6:	ae 01       	movw	r20, r28
 7e8:	46 5e       	subi	r20, 0xE6	; 230
 7ea:	5f 4f       	sbci	r21, 0xFF	; 255
 7ec:	f6 01       	movw	r30, r12
 7ee:	31 96       	adiw	r30, 0x01	; 1
 7f0:	ba e0       	ldi	r27, 0x0A	; 10
 7f2:	cb 0e       	add	r12, r27
 7f4:	d1 1c       	adc	r13, r1
 7f6:	cf 01       	movw	r24, r30
 7f8:	21 91       	ld	r18, Z+
 7fa:	da 01       	movw	r26, r20
 7fc:	2d 93       	st	X+, r18
 7fe:	ad 01       	movw	r20, r26
 800:	dc 01       	movw	r26, r24
 802:	8c 91       	ld	r24, X
 804:	88 23       	and	r24, r24
 806:	19 f0       	breq	.+6      	; 0x80e <xTaskCreate+0x90>
 808:	ce 16       	cp	r12, r30
 80a:	df 06       	cpc	r13, r31
 80c:	a1 f7       	brne	.-24     	; 0x7f6 <xTaskCreate+0x78>
 80e:	1a a2       	std	Y+34, r1	; 0x22
 810:	05 30       	cpi	r16, 0x05	; 5
 812:	08 f0       	brcs	.+2      	; 0x816 <xTaskCreate+0x98>
 814:	04 e0       	ldi	r16, 0x04	; 4
 816:	0e 8b       	std	Y+22, r16	; 0x16
 818:	0b a3       	std	Y+35, r16	; 0x23
 81a:	1c a2       	std	Y+36, r1	; 0x24
 81c:	6e 01       	movw	r12, r28
 81e:	b2 e0       	ldi	r27, 0x02	; 2
 820:	cb 0e       	add	r12, r27
 822:	d1 1c       	adc	r13, r1
 824:	c6 01       	movw	r24, r12
 826:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
 82a:	ce 01       	movw	r24, r28
 82c:	0c 96       	adiw	r24, 0x0c	; 12
 82e:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
 832:	d9 87       	std	Y+9, r29	; 0x09
 834:	c8 87       	std	Y+8, r28	; 0x08
 836:	85 e0       	ldi	r24, 0x05	; 5
 838:	90 e0       	ldi	r25, 0x00	; 0
 83a:	80 1b       	sub	r24, r16
 83c:	91 09       	sbc	r25, r1
 83e:	9d 87       	std	Y+13, r25	; 0x0d
 840:	8c 87       	std	Y+12, r24	; 0x0c
 842:	db 8b       	std	Y+19, r29	; 0x13
 844:	ca 8b       	std	Y+18, r28	; 0x12
 846:	1d a2       	std	Y+37, r1	; 0x25
 848:	1e a2       	std	Y+38, r1	; 0x26
 84a:	1f a2       	std	Y+39, r1	; 0x27
 84c:	18 a6       	std	Y+40, r1	; 0x28
 84e:	19 a6       	std	Y+41, r1	; 0x29
 850:	a2 01       	movw	r20, r4
 852:	b4 01       	movw	r22, r8
 854:	c3 01       	movw	r24, r6
 856:	0e 94 ef 01 	call	0x3de	; 0x3de <pxPortInitialiseStack>
 85a:	99 83       	std	Y+1, r25	; 0x01
 85c:	88 83       	st	Y, r24
 85e:	e1 14       	cp	r14, r1
 860:	f1 04       	cpc	r15, r1
 862:	19 f0       	breq	.+6      	; 0x86a <__stack+0xb>
 864:	f7 01       	movw	r30, r14
 866:	d1 83       	std	Z+1, r29	; 0x01
 868:	c0 83       	st	Z, r28
 86a:	0f b6       	in	r0, 0x3f	; 63
 86c:	f8 94       	cli
 86e:	0f 92       	push	r0
 870:	80 91 a2 03 	lds	r24, 0x03A2	; 0x8003a2 <uxCurrentNumberOfTasks>
 874:	8f 5f       	subi	r24, 0xFF	; 255
 876:	80 93 a2 03 	sts	0x03A2, r24	; 0x8003a2 <uxCurrentNumberOfTasks>
 87a:	80 91 02 04 	lds	r24, 0x0402	; 0x800402 <pxCurrentTCB>
 87e:	90 91 03 04 	lds	r25, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 882:	89 2b       	or	r24, r25
 884:	d1 f5       	brne	.+116    	; 0x8fa <__stack+0x9b>
 886:	d0 93 03 04 	sts	0x0403, r29	; 0x800403 <pxCurrentTCB+0x1>
 88a:	c0 93 02 04 	sts	0x0402, r28	; 0x800402 <pxCurrentTCB>
 88e:	80 91 a2 03 	lds	r24, 0x03A2	; 0x8003a2 <uxCurrentNumberOfTasks>
 892:	81 30       	cpi	r24, 0x01	; 1
 894:	09 f0       	breq	.+2      	; 0x898 <__stack+0x39>
 896:	41 c0       	rjmp	.+130    	; 0x91a <__stack+0xbb>
 898:	05 ed       	ldi	r16, 0xD5	; 213
 89a:	13 e0       	ldi	r17, 0x03	; 3
 89c:	0f 2e       	mov	r0, r31
 89e:	f2 e0       	ldi	r31, 0x02	; 2
 8a0:	ef 2e       	mov	r14, r31
 8a2:	f4 e0       	ldi	r31, 0x04	; 4
 8a4:	ff 2e       	mov	r15, r31
 8a6:	f0 2d       	mov	r31, r0
 8a8:	c8 01       	movw	r24, r16
 8aa:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 8ae:	07 5f       	subi	r16, 0xF7	; 247
 8b0:	1f 4f       	sbci	r17, 0xFF	; 255
 8b2:	0e 15       	cp	r16, r14
 8b4:	1f 05       	cpc	r17, r15
 8b6:	c1 f7       	brne	.-16     	; 0x8a8 <__stack+0x49>
 8b8:	8c ec       	ldi	r24, 0xCC	; 204
 8ba:	93 e0       	ldi	r25, 0x03	; 3
 8bc:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 8c0:	83 ec       	ldi	r24, 0xC3	; 195
 8c2:	93 e0       	ldi	r25, 0x03	; 3
 8c4:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 8c8:	86 eb       	ldi	r24, 0xB6	; 182
 8ca:	93 e0       	ldi	r25, 0x03	; 3
 8cc:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 8d0:	8d ea       	ldi	r24, 0xAD	; 173
 8d2:	93 e0       	ldi	r25, 0x03	; 3
 8d4:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 8d8:	83 ea       	ldi	r24, 0xA3	; 163
 8da:	93 e0       	ldi	r25, 0x03	; 3
 8dc:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
 8e0:	8c ec       	ldi	r24, 0xCC	; 204
 8e2:	93 e0       	ldi	r25, 0x03	; 3
 8e4:	90 93 c2 03 	sts	0x03C2, r25	; 0x8003c2 <pxDelayedTaskList+0x1>
 8e8:	80 93 c1 03 	sts	0x03C1, r24	; 0x8003c1 <pxDelayedTaskList>
 8ec:	83 ec       	ldi	r24, 0xC3	; 195
 8ee:	93 e0       	ldi	r25, 0x03	; 3
 8f0:	90 93 c0 03 	sts	0x03C0, r25	; 0x8003c0 <pxOverflowDelayedTaskList+0x1>
 8f4:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <pxOverflowDelayedTaskList>
 8f8:	10 c0       	rjmp	.+32     	; 0x91a <__stack+0xbb>
 8fa:	80 91 9e 03 	lds	r24, 0x039E	; 0x80039e <xSchedulerRunning>
 8fe:	81 11       	cpse	r24, r1
 900:	0c c0       	rjmp	.+24     	; 0x91a <__stack+0xbb>
 902:	e0 91 02 04 	lds	r30, 0x0402	; 0x800402 <pxCurrentTCB>
 906:	f0 91 03 04 	lds	r31, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 90a:	96 89       	ldd	r25, Z+22	; 0x16
 90c:	8e 89       	ldd	r24, Y+22	; 0x16
 90e:	89 17       	cp	r24, r25
 910:	20 f0       	brcs	.+8      	; 0x91a <__stack+0xbb>
 912:	d0 93 03 04 	sts	0x0403, r29	; 0x800403 <pxCurrentTCB+0x1>
 916:	c0 93 02 04 	sts	0x0402, r28	; 0x800402 <pxCurrentTCB>
 91a:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <uxTaskNumber>
 91e:	8f 5f       	subi	r24, 0xFF	; 255
 920:	80 93 9a 03 	sts	0x039A, r24	; 0x80039a <uxTaskNumber>
 924:	8e 89       	ldd	r24, Y+22	; 0x16
 926:	90 91 9f 03 	lds	r25, 0x039F	; 0x80039f <uxTopReadyPriority>
 92a:	98 17       	cp	r25, r24
 92c:	10 f4       	brcc	.+4      	; 0x932 <__stack+0xd3>
 92e:	80 93 9f 03 	sts	0x039F, r24	; 0x80039f <uxTopReadyPriority>
 932:	90 e0       	ldi	r25, 0x00	; 0
 934:	9c 01       	movw	r18, r24
 936:	22 0f       	add	r18, r18
 938:	33 1f       	adc	r19, r19
 93a:	22 0f       	add	r18, r18
 93c:	33 1f       	adc	r19, r19
 93e:	22 0f       	add	r18, r18
 940:	33 1f       	adc	r19, r19
 942:	82 0f       	add	r24, r18
 944:	93 1f       	adc	r25, r19
 946:	b6 01       	movw	r22, r12
 948:	8b 52       	subi	r24, 0x2B	; 43
 94a:	9c 4f       	sbci	r25, 0xFC	; 252
 94c:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
 950:	0f 90       	pop	r0
 952:	0f be       	out	0x3f, r0	; 63
 954:	80 91 9e 03 	lds	r24, 0x039E	; 0x80039e <xSchedulerRunning>
 958:	88 23       	and	r24, r24
 95a:	61 f0       	breq	.+24     	; 0x974 <__stack+0x115>
 95c:	e0 91 02 04 	lds	r30, 0x0402	; 0x800402 <pxCurrentTCB>
 960:	f0 91 03 04 	lds	r31, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 964:	96 89       	ldd	r25, Z+22	; 0x16
 966:	8e 89       	ldd	r24, Y+22	; 0x16
 968:	98 17       	cp	r25, r24
 96a:	30 f4       	brcc	.+12     	; 0x978 <__stack+0x119>
 96c:	0e 94 90 02 	call	0x520	; 0x520 <vPortYield>
 970:	81 e0       	ldi	r24, 0x01	; 1
 972:	05 c0       	rjmp	.+10     	; 0x97e <__stack+0x11f>
 974:	81 e0       	ldi	r24, 0x01	; 1
 976:	03 c0       	rjmp	.+6      	; 0x97e <__stack+0x11f>
 978:	81 e0       	ldi	r24, 0x01	; 1
 97a:	01 c0       	rjmp	.+2      	; 0x97e <__stack+0x11f>
 97c:	8f ef       	ldi	r24, 0xFF	; 255
 97e:	df 91       	pop	r29
 980:	cf 91       	pop	r28
 982:	1f 91       	pop	r17
 984:	0f 91       	pop	r16
 986:	ff 90       	pop	r15
 988:	ef 90       	pop	r14
 98a:	df 90       	pop	r13
 98c:	cf 90       	pop	r12
 98e:	bf 90       	pop	r11
 990:	af 90       	pop	r10
 992:	9f 90       	pop	r9
 994:	8f 90       	pop	r8
 996:	7f 90       	pop	r7
 998:	6f 90       	pop	r6
 99a:	5f 90       	pop	r5
 99c:	4f 90       	pop	r4
 99e:	08 95       	ret

000009a0 <vTaskStartScheduler>:
 9a0:	ef 92       	push	r14
 9a2:	ff 92       	push	r15
 9a4:	0f 93       	push	r16
 9a6:	0f 2e       	mov	r0, r31
 9a8:	f6 e9       	ldi	r31, 0x96	; 150
 9aa:	ef 2e       	mov	r14, r31
 9ac:	f3 e0       	ldi	r31, 0x03	; 3
 9ae:	ff 2e       	mov	r15, r31
 9b0:	f0 2d       	mov	r31, r0
 9b2:	00 e0       	ldi	r16, 0x00	; 0
 9b4:	20 e0       	ldi	r18, 0x00	; 0
 9b6:	30 e0       	ldi	r19, 0x00	; 0
 9b8:	48 ec       	ldi	r20, 0xC8	; 200
 9ba:	50 e0       	ldi	r21, 0x00	; 0
 9bc:	66 e6       	ldi	r22, 0x66	; 102
 9be:	70 e0       	ldi	r23, 0x00	; 0
 9c0:	86 e3       	ldi	r24, 0x36	; 54
 9c2:	96 e0       	ldi	r25, 0x06	; 6
 9c4:	0e 94 bf 03 	call	0x77e	; 0x77e <xTaskCreate>
 9c8:	81 30       	cpi	r24, 0x01	; 1
 9ca:	81 f4       	brne	.+32     	; 0x9ec <vTaskStartScheduler+0x4c>
 9cc:	f8 94       	cli
 9ce:	8f ef       	ldi	r24, 0xFF	; 255
 9d0:	9f ef       	ldi	r25, 0xFF	; 255
 9d2:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <xNextTaskUnblockTime+0x1>
 9d6:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <xNextTaskUnblockTime>
 9da:	81 e0       	ldi	r24, 0x01	; 1
 9dc:	80 93 9e 03 	sts	0x039E, r24	; 0x80039e <xSchedulerRunning>
 9e0:	10 92 a1 03 	sts	0x03A1, r1	; 0x8003a1 <xTickCount+0x1>
 9e4:	10 92 a0 03 	sts	0x03A0, r1	; 0x8003a0 <xTickCount>
 9e8:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <xPortStartScheduler>
 9ec:	0f 91       	pop	r16
 9ee:	ff 90       	pop	r15
 9f0:	ef 90       	pop	r14
 9f2:	08 95       	ret

000009f4 <vTaskSuspendAll>:
 9f4:	80 91 95 03 	lds	r24, 0x0395	; 0x800395 <uxSchedulerSuspended>
 9f8:	8f 5f       	subi	r24, 0xFF	; 255
 9fa:	80 93 95 03 	sts	0x0395, r24	; 0x800395 <uxSchedulerSuspended>
 9fe:	08 95       	ret

00000a00 <xTaskIncrementTick>:
 a00:	cf 92       	push	r12
 a02:	df 92       	push	r13
 a04:	ef 92       	push	r14
 a06:	ff 92       	push	r15
 a08:	0f 93       	push	r16
 a0a:	1f 93       	push	r17
 a0c:	cf 93       	push	r28
 a0e:	df 93       	push	r29
 a10:	80 91 95 03 	lds	r24, 0x0395	; 0x800395 <uxSchedulerSuspended>
 a14:	81 11       	cpse	r24, r1
 a16:	81 c0       	rjmp	.+258    	; 0xb1a <xTaskIncrementTick+0x11a>
 a18:	e0 90 a0 03 	lds	r14, 0x03A0	; 0x8003a0 <xTickCount>
 a1c:	f0 90 a1 03 	lds	r15, 0x03A1	; 0x8003a1 <xTickCount+0x1>
 a20:	8f ef       	ldi	r24, 0xFF	; 255
 a22:	e8 1a       	sub	r14, r24
 a24:	f8 0a       	sbc	r15, r24
 a26:	f0 92 a1 03 	sts	0x03A1, r15	; 0x8003a1 <xTickCount+0x1>
 a2a:	e0 92 a0 03 	sts	0x03A0, r14	; 0x8003a0 <xTickCount>
 a2e:	e1 14       	cp	r14, r1
 a30:	f1 04       	cpc	r15, r1
 a32:	b9 f4       	brne	.+46     	; 0xa62 <xTaskIncrementTick+0x62>
 a34:	80 91 c1 03 	lds	r24, 0x03C1	; 0x8003c1 <pxDelayedTaskList>
 a38:	90 91 c2 03 	lds	r25, 0x03C2	; 0x8003c2 <pxDelayedTaskList+0x1>
 a3c:	20 91 bf 03 	lds	r18, 0x03BF	; 0x8003bf <pxOverflowDelayedTaskList>
 a40:	30 91 c0 03 	lds	r19, 0x03C0	; 0x8003c0 <pxOverflowDelayedTaskList+0x1>
 a44:	30 93 c2 03 	sts	0x03C2, r19	; 0x8003c2 <pxDelayedTaskList+0x1>
 a48:	20 93 c1 03 	sts	0x03C1, r18	; 0x8003c1 <pxDelayedTaskList>
 a4c:	90 93 c0 03 	sts	0x03C0, r25	; 0x8003c0 <pxOverflowDelayedTaskList+0x1>
 a50:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <pxOverflowDelayedTaskList>
 a54:	80 91 9b 03 	lds	r24, 0x039B	; 0x80039b <xNumOfOverflows>
 a58:	8f 5f       	subi	r24, 0xFF	; 255
 a5a:	80 93 9b 03 	sts	0x039B, r24	; 0x80039b <xNumOfOverflows>
 a5e:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
 a62:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <xNextTaskUnblockTime>
 a66:	90 91 99 03 	lds	r25, 0x0399	; 0x800399 <xNextTaskUnblockTime+0x1>
 a6a:	e8 16       	cp	r14, r24
 a6c:	f9 06       	cpc	r15, r25
 a6e:	10 f4       	brcc	.+4      	; 0xa74 <xTaskIncrementTick+0x74>
 a70:	d1 2c       	mov	r13, r1
 a72:	59 c0       	rjmp	.+178    	; 0xb26 <xTaskIncrementTick+0x126>
 a74:	d1 2c       	mov	r13, r1
 a76:	cc 24       	eor	r12, r12
 a78:	c3 94       	inc	r12
 a7a:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxDelayedTaskList>
 a7e:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxDelayedTaskList+0x1>
 a82:	80 81       	ld	r24, Z
 a84:	81 11       	cpse	r24, r1
 a86:	07 c0       	rjmp	.+14     	; 0xa96 <xTaskIncrementTick+0x96>
 a88:	8f ef       	ldi	r24, 0xFF	; 255
 a8a:	9f ef       	ldi	r25, 0xFF	; 255
 a8c:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <xNextTaskUnblockTime+0x1>
 a90:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <xNextTaskUnblockTime>
 a94:	48 c0       	rjmp	.+144    	; 0xb26 <xTaskIncrementTick+0x126>
 a96:	e0 91 c1 03 	lds	r30, 0x03C1	; 0x8003c1 <pxDelayedTaskList>
 a9a:	f0 91 c2 03 	lds	r31, 0x03C2	; 0x8003c2 <pxDelayedTaskList+0x1>
 a9e:	05 80       	ldd	r0, Z+5	; 0x05
 aa0:	f6 81       	ldd	r31, Z+6	; 0x06
 aa2:	e0 2d       	mov	r30, r0
 aa4:	c6 81       	ldd	r28, Z+6	; 0x06
 aa6:	d7 81       	ldd	r29, Z+7	; 0x07
 aa8:	8a 81       	ldd	r24, Y+2	; 0x02
 aaa:	9b 81       	ldd	r25, Y+3	; 0x03
 aac:	e8 16       	cp	r14, r24
 aae:	f9 06       	cpc	r15, r25
 ab0:	28 f4       	brcc	.+10     	; 0xabc <xTaskIncrementTick+0xbc>
 ab2:	90 93 99 03 	sts	0x0399, r25	; 0x800399 <xNextTaskUnblockTime+0x1>
 ab6:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <xNextTaskUnblockTime>
 aba:	35 c0       	rjmp	.+106    	; 0xb26 <xTaskIncrementTick+0x126>
 abc:	8e 01       	movw	r16, r28
 abe:	0e 5f       	subi	r16, 0xFE	; 254
 ac0:	1f 4f       	sbci	r17, 0xFF	; 255
 ac2:	c8 01       	movw	r24, r16
 ac4:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 ac8:	8c 89       	ldd	r24, Y+20	; 0x14
 aca:	9d 89       	ldd	r25, Y+21	; 0x15
 acc:	89 2b       	or	r24, r25
 ace:	21 f0       	breq	.+8      	; 0xad8 <xTaskIncrementTick+0xd8>
 ad0:	ce 01       	movw	r24, r28
 ad2:	0c 96       	adiw	r24, 0x0c	; 12
 ad4:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 ad8:	8e 89       	ldd	r24, Y+22	; 0x16
 ada:	90 91 9f 03 	lds	r25, 0x039F	; 0x80039f <uxTopReadyPriority>
 ade:	98 17       	cp	r25, r24
 ae0:	10 f4       	brcc	.+4      	; 0xae6 <xTaskIncrementTick+0xe6>
 ae2:	80 93 9f 03 	sts	0x039F, r24	; 0x80039f <uxTopReadyPriority>
 ae6:	90 e0       	ldi	r25, 0x00	; 0
 ae8:	9c 01       	movw	r18, r24
 aea:	22 0f       	add	r18, r18
 aec:	33 1f       	adc	r19, r19
 aee:	22 0f       	add	r18, r18
 af0:	33 1f       	adc	r19, r19
 af2:	22 0f       	add	r18, r18
 af4:	33 1f       	adc	r19, r19
 af6:	82 0f       	add	r24, r18
 af8:	93 1f       	adc	r25, r19
 afa:	b8 01       	movw	r22, r16
 afc:	8b 52       	subi	r24, 0x2B	; 43
 afe:	9c 4f       	sbci	r25, 0xFC	; 252
 b00:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
 b04:	e0 91 02 04 	lds	r30, 0x0402	; 0x800402 <pxCurrentTCB>
 b08:	f0 91 03 04 	lds	r31, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 b0c:	9e 89       	ldd	r25, Y+22	; 0x16
 b0e:	86 89       	ldd	r24, Z+22	; 0x16
 b10:	98 17       	cp	r25, r24
 b12:	08 f4       	brcc	.+2      	; 0xb16 <xTaskIncrementTick+0x116>
 b14:	b2 cf       	rjmp	.-156    	; 0xa7a <xTaskIncrementTick+0x7a>
 b16:	dc 2c       	mov	r13, r12
 b18:	b0 cf       	rjmp	.-160    	; 0xa7a <xTaskIncrementTick+0x7a>
 b1a:	80 91 9d 03 	lds	r24, 0x039D	; 0x80039d <uxPendedTicks>
 b1e:	8f 5f       	subi	r24, 0xFF	; 255
 b20:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxPendedTicks>
 b24:	d1 2c       	mov	r13, r1
 b26:	80 91 9c 03 	lds	r24, 0x039C	; 0x80039c <xYieldPending>
 b2a:	88 23       	and	r24, r24
 b2c:	11 f0       	breq	.+4      	; 0xb32 <xTaskIncrementTick+0x132>
 b2e:	dd 24       	eor	r13, r13
 b30:	d3 94       	inc	r13
 b32:	8d 2d       	mov	r24, r13
 b34:	df 91       	pop	r29
 b36:	cf 91       	pop	r28
 b38:	1f 91       	pop	r17
 b3a:	0f 91       	pop	r16
 b3c:	ff 90       	pop	r15
 b3e:	ef 90       	pop	r14
 b40:	df 90       	pop	r13
 b42:	cf 90       	pop	r12
 b44:	08 95       	ret

00000b46 <xTaskResumeAll>:
 b46:	df 92       	push	r13
 b48:	ef 92       	push	r14
 b4a:	ff 92       	push	r15
 b4c:	0f 93       	push	r16
 b4e:	1f 93       	push	r17
 b50:	cf 93       	push	r28
 b52:	df 93       	push	r29
 b54:	0f b6       	in	r0, 0x3f	; 63
 b56:	f8 94       	cli
 b58:	0f 92       	push	r0
 b5a:	80 91 95 03 	lds	r24, 0x0395	; 0x800395 <uxSchedulerSuspended>
 b5e:	81 50       	subi	r24, 0x01	; 1
 b60:	80 93 95 03 	sts	0x0395, r24	; 0x800395 <uxSchedulerSuspended>
 b64:	80 91 95 03 	lds	r24, 0x0395	; 0x800395 <uxSchedulerSuspended>
 b68:	81 11       	cpse	r24, r1
 b6a:	5f c0       	rjmp	.+190    	; 0xc2a <xTaskResumeAll+0xe4>
 b6c:	80 91 a2 03 	lds	r24, 0x03A2	; 0x8003a2 <uxCurrentNumberOfTasks>
 b70:	81 11       	cpse	r24, r1
 b72:	33 c0       	rjmp	.+102    	; 0xbda <xTaskResumeAll+0x94>
 b74:	5d c0       	rjmp	.+186    	; 0xc30 <xTaskResumeAll+0xea>
 b76:	d7 01       	movw	r26, r14
 b78:	15 96       	adiw	r26, 0x05	; 5
 b7a:	ed 91       	ld	r30, X+
 b7c:	fc 91       	ld	r31, X
 b7e:	16 97       	sbiw	r26, 0x06	; 6
 b80:	c6 81       	ldd	r28, Z+6	; 0x06
 b82:	d7 81       	ldd	r29, Z+7	; 0x07
 b84:	ce 01       	movw	r24, r28
 b86:	0c 96       	adiw	r24, 0x0c	; 12
 b88:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 b8c:	8e 01       	movw	r16, r28
 b8e:	0e 5f       	subi	r16, 0xFE	; 254
 b90:	1f 4f       	sbci	r17, 0xFF	; 255
 b92:	c8 01       	movw	r24, r16
 b94:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
 b98:	8e 89       	ldd	r24, Y+22	; 0x16
 b9a:	90 91 9f 03 	lds	r25, 0x039F	; 0x80039f <uxTopReadyPriority>
 b9e:	98 17       	cp	r25, r24
 ba0:	10 f4       	brcc	.+4      	; 0xba6 <xTaskResumeAll+0x60>
 ba2:	80 93 9f 03 	sts	0x039F, r24	; 0x80039f <uxTopReadyPriority>
 ba6:	90 e0       	ldi	r25, 0x00	; 0
 ba8:	9c 01       	movw	r18, r24
 baa:	22 0f       	add	r18, r18
 bac:	33 1f       	adc	r19, r19
 bae:	22 0f       	add	r18, r18
 bb0:	33 1f       	adc	r19, r19
 bb2:	22 0f       	add	r18, r18
 bb4:	33 1f       	adc	r19, r19
 bb6:	82 0f       	add	r24, r18
 bb8:	93 1f       	adc	r25, r19
 bba:	b8 01       	movw	r22, r16
 bbc:	8b 52       	subi	r24, 0x2B	; 43
 bbe:	9c 4f       	sbci	r25, 0xFC	; 252
 bc0:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
 bc4:	e0 91 02 04 	lds	r30, 0x0402	; 0x800402 <pxCurrentTCB>
 bc8:	f0 91 03 04 	lds	r31, 0x0403	; 0x800403 <pxCurrentTCB+0x1>
 bcc:	9e 89       	ldd	r25, Y+22	; 0x16
 bce:	86 89       	ldd	r24, Z+22	; 0x16
 bd0:	98 17       	cp	r25, r24
 bd2:	68 f0       	brcs	.+26     	; 0xbee <xTaskResumeAll+0xa8>
 bd4:	d0 92 9c 03 	sts	0x039C, r13	; 0x80039c <xYieldPending>
 bd8:	0a c0       	rjmp	.+20     	; 0xbee <xTaskResumeAll+0xa8>
 bda:	c0 e0       	ldi	r28, 0x00	; 0
 bdc:	d0 e0       	ldi	r29, 0x00	; 0
 bde:	0f 2e       	mov	r0, r31
 be0:	f6 eb       	ldi	r31, 0xB6	; 182
 be2:	ef 2e       	mov	r14, r31
 be4:	f3 e0       	ldi	r31, 0x03	; 3
 be6:	ff 2e       	mov	r15, r31
 be8:	f0 2d       	mov	r31, r0
 bea:	dd 24       	eor	r13, r13
 bec:	d3 94       	inc	r13
 bee:	f7 01       	movw	r30, r14
 bf0:	80 81       	ld	r24, Z
 bf2:	81 11       	cpse	r24, r1
 bf4:	c0 cf       	rjmp	.-128    	; 0xb76 <xTaskResumeAll+0x30>
 bf6:	cd 2b       	or	r28, r29
 bf8:	11 f0       	breq	.+4      	; 0xbfe <xTaskResumeAll+0xb8>
 bfa:	0e 94 48 03 	call	0x690	; 0x690 <prvResetNextTaskUnblockTime>
 bfe:	c0 91 9d 03 	lds	r28, 0x039D	; 0x80039d <uxPendedTicks>
 c02:	cc 23       	and	r28, r28
 c04:	51 f0       	breq	.+20     	; 0xc1a <xTaskResumeAll+0xd4>
 c06:	d1 e0       	ldi	r29, 0x01	; 1
 c08:	0e 94 00 05 	call	0xa00	; 0xa00 <xTaskIncrementTick>
 c0c:	81 11       	cpse	r24, r1
 c0e:	d0 93 9c 03 	sts	0x039C, r29	; 0x80039c <xYieldPending>
 c12:	c1 50       	subi	r28, 0x01	; 1
 c14:	c9 f7       	brne	.-14     	; 0xc08 <xTaskResumeAll+0xc2>
 c16:	10 92 9d 03 	sts	0x039D, r1	; 0x80039d <uxPendedTicks>
 c1a:	80 91 9c 03 	lds	r24, 0x039C	; 0x80039c <xYieldPending>
 c1e:	88 23       	and	r24, r24
 c20:	31 f0       	breq	.+12     	; 0xc2e <xTaskResumeAll+0xe8>
 c22:	0e 94 90 02 	call	0x520	; 0x520 <vPortYield>
 c26:	81 e0       	ldi	r24, 0x01	; 1
 c28:	03 c0       	rjmp	.+6      	; 0xc30 <xTaskResumeAll+0xea>
 c2a:	80 e0       	ldi	r24, 0x00	; 0
 c2c:	01 c0       	rjmp	.+2      	; 0xc30 <xTaskResumeAll+0xea>
 c2e:	80 e0       	ldi	r24, 0x00	; 0
 c30:	0f 90       	pop	r0
 c32:	0f be       	out	0x3f, r0	; 63
 c34:	df 91       	pop	r29
 c36:	cf 91       	pop	r28
 c38:	1f 91       	pop	r17
 c3a:	0f 91       	pop	r16
 c3c:	ff 90       	pop	r15
 c3e:	ef 90       	pop	r14
 c40:	df 90       	pop	r13
 c42:	08 95       	ret

00000c44 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 c44:	cf 93       	push	r28
 c46:	df 93       	push	r29
 c48:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 c4a:	89 2b       	or	r24, r25
 c4c:	51 f0       	breq	.+20     	; 0xc62 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 c4e:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 c52:	60 e0       	ldi	r22, 0x00	; 0
 c54:	ce 01       	movw	r24, r28
 c56:	0e 94 67 03 	call	0x6ce	; 0x6ce <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 c5a:	0e 94 a3 05 	call	0xb46	; 0xb46 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 c5e:	81 11       	cpse	r24, r1
 c60:	02 c0       	rjmp	.+4      	; 0xc66 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 c62:	0e 94 90 02 	call	0x520	; 0x520 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 c66:	df 91       	pop	r29
 c68:	cf 91       	pop	r28
 c6a:	08 95       	ret

00000c6c <prvIdleTask>:
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c6c:	0d ea       	ldi	r16, 0xAD	; 173
 c6e:	13 e0       	ldi	r17, 0x03	; 3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 c70:	0f 2e       	mov	r0, r31
 c72:	f5 ed       	ldi	r31, 0xD5	; 213
 c74:	ef 2e       	mov	r14, r31
 c76:	f3 e0       	ldi	r31, 0x03	; 3
 c78:	ff 2e       	mov	r15, r31
 c7a:	f0 2d       	mov	r31, r0
 c7c:	29 c0       	rjmp	.+82     	; 0xcd0 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 c7e:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c82:	d8 01       	movw	r26, r16
 c84:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 c86:	0e 94 a3 05 	call	0xb46	; 0xb46 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 c8a:	cc 23       	and	r28, r28
 c8c:	09 f1       	breq	.+66     	; 0xcd0 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 c8e:	0f b6       	in	r0, 0x3f	; 63
 c90:	f8 94       	cli
 c92:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 c94:	d8 01       	movw	r26, r16
 c96:	15 96       	adiw	r26, 0x05	; 5
 c98:	ed 91       	ld	r30, X+
 c9a:	fc 91       	ld	r31, X
 c9c:	16 97       	sbiw	r26, 0x06	; 6
 c9e:	c6 81       	ldd	r28, Z+6	; 0x06
 ca0:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 ca2:	ce 01       	movw	r24, r28
 ca4:	02 96       	adiw	r24, 0x02	; 2
 ca6:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
					--uxCurrentNumberOfTasks;
 caa:	80 91 a2 03 	lds	r24, 0x03A2	; 0x8003a2 <uxCurrentNumberOfTasks>
 cae:	81 50       	subi	r24, 0x01	; 1
 cb0:	80 93 a2 03 	sts	0x03A2, r24	; 0x8003a2 <uxCurrentNumberOfTasks>
					--uxDeletedTasksWaitingCleanUp;
 cb4:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <uxDeletedTasksWaitingCleanUp>
 cb8:	81 50       	subi	r24, 0x01	; 1
 cba:	80 93 ac 03 	sts	0x03AC, r24	; 0x8003ac <uxDeletedTasksWaitingCleanUp>
				}
				taskEXIT_CRITICAL();
 cbe:	0f 90       	pop	r0
 cc0:	0f be       	out	0x3f, r0	; 63

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
 cc2:	8f 89       	ldd	r24, Y+23	; 0x17
 cc4:	98 8d       	ldd	r25, Y+24	; 0x18
 cc6:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
			vPortFree( pxTCB );
 cca:	ce 01       	movw	r24, r28
 ccc:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 cd0:	80 91 ac 03 	lds	r24, 0x03AC	; 0x8003ac <uxDeletedTasksWaitingCleanUp>
 cd4:	81 11       	cpse	r24, r1
 cd6:	d3 cf       	rjmp	.-90     	; 0xc7e <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 cd8:	f7 01       	movw	r30, r14
 cda:	80 81       	ld	r24, Z
 cdc:	82 30       	cpi	r24, 0x02	; 2
 cde:	c0 f3       	brcs	.-16     	; 0xcd0 <prvIdleTask+0x64>
			{
				taskYIELD();
 ce0:	0e 94 90 02 	call	0x520	; 0x520 <vPortYield>
 ce4:	f5 cf       	rjmp	.-22     	; 0xcd0 <prvIdleTask+0x64>

00000ce6 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 ce6:	80 91 95 03 	lds	r24, 0x0395	; 0x800395 <uxSchedulerSuspended>
 cea:	88 23       	and	r24, r24
 cec:	21 f0       	breq	.+8      	; 0xcf6 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 cee:	81 e0       	ldi	r24, 0x01	; 1
 cf0:	80 93 9c 03 	sts	0x039C, r24	; 0x80039c <xYieldPending>
 cf4:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 cf6:	10 92 9c 03 	sts	0x039C, r1	; 0x80039c <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 cfa:	20 91 9f 03 	lds	r18, 0x039F	; 0x80039f <uxTopReadyPriority>
 cfe:	82 2f       	mov	r24, r18
 d00:	90 e0       	ldi	r25, 0x00	; 0
 d02:	fc 01       	movw	r30, r24
 d04:	ee 0f       	add	r30, r30
 d06:	ff 1f       	adc	r31, r31
 d08:	ee 0f       	add	r30, r30
 d0a:	ff 1f       	adc	r31, r31
 d0c:	ee 0f       	add	r30, r30
 d0e:	ff 1f       	adc	r31, r31
 d10:	e8 0f       	add	r30, r24
 d12:	f9 1f       	adc	r31, r25
 d14:	eb 52       	subi	r30, 0x2B	; 43
 d16:	fc 4f       	sbci	r31, 0xFC	; 252
 d18:	30 81       	ld	r19, Z
 d1a:	31 11       	cpse	r19, r1
 d1c:	11 c0       	rjmp	.+34     	; 0xd40 <vTaskSwitchContext+0x5a>
 d1e:	21 50       	subi	r18, 0x01	; 1
 d20:	82 2f       	mov	r24, r18
 d22:	90 e0       	ldi	r25, 0x00	; 0
 d24:	fc 01       	movw	r30, r24
 d26:	ee 0f       	add	r30, r30
 d28:	ff 1f       	adc	r31, r31
 d2a:	ee 0f       	add	r30, r30
 d2c:	ff 1f       	adc	r31, r31
 d2e:	ee 0f       	add	r30, r30
 d30:	ff 1f       	adc	r31, r31
 d32:	e8 0f       	add	r30, r24
 d34:	f9 1f       	adc	r31, r25
 d36:	eb 52       	subi	r30, 0x2B	; 43
 d38:	fc 4f       	sbci	r31, 0xFC	; 252
 d3a:	30 81       	ld	r19, Z
 d3c:	33 23       	and	r19, r19
 d3e:	79 f3       	breq	.-34     	; 0xd1e <vTaskSwitchContext+0x38>
 d40:	ac 01       	movw	r20, r24
 d42:	44 0f       	add	r20, r20
 d44:	55 1f       	adc	r21, r21
 d46:	44 0f       	add	r20, r20
 d48:	55 1f       	adc	r21, r21
 d4a:	44 0f       	add	r20, r20
 d4c:	55 1f       	adc	r21, r21
 d4e:	48 0f       	add	r20, r24
 d50:	59 1f       	adc	r21, r25
 d52:	da 01       	movw	r26, r20
 d54:	ab 52       	subi	r26, 0x2B	; 43
 d56:	bc 4f       	sbci	r27, 0xFC	; 252
 d58:	11 96       	adiw	r26, 0x01	; 1
 d5a:	ed 91       	ld	r30, X+
 d5c:	fc 91       	ld	r31, X
 d5e:	12 97       	sbiw	r26, 0x02	; 2
 d60:	02 80       	ldd	r0, Z+2	; 0x02
 d62:	f3 81       	ldd	r31, Z+3	; 0x03
 d64:	e0 2d       	mov	r30, r0
 d66:	12 96       	adiw	r26, 0x02	; 2
 d68:	fc 93       	st	X, r31
 d6a:	ee 93       	st	-X, r30
 d6c:	11 97       	sbiw	r26, 0x01	; 1
 d6e:	48 52       	subi	r20, 0x28	; 40
 d70:	5c 4f       	sbci	r21, 0xFC	; 252
 d72:	e4 17       	cp	r30, r20
 d74:	f5 07       	cpc	r31, r21
 d76:	29 f4       	brne	.+10     	; 0xd82 <vTaskSwitchContext+0x9c>
 d78:	42 81       	ldd	r20, Z+2	; 0x02
 d7a:	53 81       	ldd	r21, Z+3	; 0x03
 d7c:	fd 01       	movw	r30, r26
 d7e:	52 83       	std	Z+2, r21	; 0x02
 d80:	41 83       	std	Z+1, r20	; 0x01
 d82:	fc 01       	movw	r30, r24
 d84:	ee 0f       	add	r30, r30
 d86:	ff 1f       	adc	r31, r31
 d88:	ee 0f       	add	r30, r30
 d8a:	ff 1f       	adc	r31, r31
 d8c:	ee 0f       	add	r30, r30
 d8e:	ff 1f       	adc	r31, r31
 d90:	8e 0f       	add	r24, r30
 d92:	9f 1f       	adc	r25, r31
 d94:	fc 01       	movw	r30, r24
 d96:	eb 52       	subi	r30, 0x2B	; 43
 d98:	fc 4f       	sbci	r31, 0xFC	; 252
 d9a:	01 80       	ldd	r0, Z+1	; 0x01
 d9c:	f2 81       	ldd	r31, Z+2	; 0x02
 d9e:	e0 2d       	mov	r30, r0
 da0:	86 81       	ldd	r24, Z+6	; 0x06
 da2:	97 81       	ldd	r25, Z+7	; 0x07
 da4:	90 93 03 04 	sts	0x0403, r25	; 0x800403 <pxCurrentTCB+0x1>
 da8:	80 93 02 04 	sts	0x0402, r24	; 0x800402 <pxCurrentTCB>
 dac:	20 93 9f 03 	sts	0x039F, r18	; 0x80039f <uxTopReadyPriority>
 db0:	08 95       	ret

00000db2 <_exit>:
 db2:	f8 94       	cli

00000db4 <__stop_program>:
 db4:	ff cf       	rjmp	.-2      	; 0xdb4 <__stop_program>
