
semaphore.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000161a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000a  00800060  0000161a  000016ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000039a  0080006a  0080006a  000016b8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000016b8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000016e8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000310  00000000  00000000  00001724  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000040d0  00000000  00000000  00001a34  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001004  00000000  00000000  00005b04  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002341  00000000  00000000  00006b08  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000009bc  00000000  00000000  00008e4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000149f  00000000  00000000  00009808  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000409c  00000000  00000000  0000aca7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000388  00000000  00000000  0000ed43  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 05 06 	jmp	0xc0a	; 0xc0a <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 f6 02 	jmp	0x5ec	; 0x5ec <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ea e1       	ldi	r30, 0x1A	; 26
      68:	f6 e1       	ldi	r31, 0x16	; 22
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 36       	cpi	r26, 0x6A	; 106
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	24 e0       	ldi	r18, 0x04	; 4
      78:	aa e6       	ldi	r26, 0x6A	; 106
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 30       	cpi	r26, 0x04	; 4
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 e5 05 	call	0xbca	; 0xbca <main>
      8a:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 6a 00 	lds	r24, 0x006A	; 0x80006a <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	ef e6       	ldi	r30, 0x6F	; 111
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	84 e7       	ldi	r24, 0x74	; 116
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	eb e6       	ldi	r30, 0x6B	; 107
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	8f e1       	ldi	r24, 0x1F	; 31
      be:	93 e0       	ldi	r25, 0x03	; 3
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	a3 e7       	ldi	r26, 0x73	; 115
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 6a 00 	sts	0x006A, r24	; 0x80006a <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	ce 31       	cpi	r28, 0x1E	; 30
      f2:	d3 40       	sbci	r29, 0x03	; 3
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 6f 00 	lds	r30, 0x006F	; 0x80006f <xStart>
      fc:	f0 91 70 00 	lds	r31, 0x0070	; 0x800070 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	af e6       	ldi	r26, 0x6F	; 111
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	eb 36       	cpi	r30, 0x6B	; 107
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	8f e6       	ldi	r24, 0x6F	; 111
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	af e6       	ldi	r26, 0x6F	; 111
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__data_start>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__data_start+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     22c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     22e:	03 96       	adiw	r24, 0x03	; 3
     230:	92 83       	std	Z+2, r25	; 0x02
     232:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     234:	2f ef       	ldi	r18, 0xFF	; 255
     236:	3f ef       	ldi	r19, 0xFF	; 255
     238:	34 83       	std	Z+4, r19	; 0x04
     23a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23c:	96 83       	std	Z+6, r25	; 0x06
     23e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     240:	90 87       	std	Z+8, r25	; 0x08
     242:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     244:	10 82       	st	Z, r1
     246:	08 95       	ret

00000248 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     248:	fc 01       	movw	r30, r24
     24a:	11 86       	std	Z+9, r1	; 0x09
     24c:	10 86       	std	Z+8, r1	; 0x08
     24e:	08 95       	ret

00000250 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     250:	cf 93       	push	r28
     252:	df 93       	push	r29
     254:	9c 01       	movw	r18, r24
     256:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     258:	dc 01       	movw	r26, r24
     25a:	11 96       	adiw	r26, 0x01	; 1
     25c:	cd 91       	ld	r28, X+
     25e:	dc 91       	ld	r29, X
     260:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     262:	d3 83       	std	Z+3, r29	; 0x03
     264:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     266:	8c 81       	ldd	r24, Y+4	; 0x04
     268:	9d 81       	ldd	r25, Y+5	; 0x05
     26a:	95 83       	std	Z+5, r25	; 0x05
     26c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     26e:	8c 81       	ldd	r24, Y+4	; 0x04
     270:	9d 81       	ldd	r25, Y+5	; 0x05
     272:	dc 01       	movw	r26, r24
     274:	13 96       	adiw	r26, 0x03	; 3
     276:	7c 93       	st	X, r23
     278:	6e 93       	st	-X, r22
     27a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     27c:	7d 83       	std	Y+5, r23	; 0x05
     27e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     280:	31 87       	std	Z+9, r19	; 0x09
     282:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     284:	f9 01       	movw	r30, r18
     286:	80 81       	ld	r24, Z
     288:	8f 5f       	subi	r24, 0xFF	; 255
     28a:	80 83       	st	Z, r24
}
     28c:	df 91       	pop	r29
     28e:	cf 91       	pop	r28
     290:	08 95       	ret

00000292 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
     296:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     298:	48 81       	ld	r20, Y
     29a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     29c:	4f 3f       	cpi	r20, 0xFF	; 255
     29e:	2f ef       	ldi	r18, 0xFF	; 255
     2a0:	52 07       	cpc	r21, r18
     2a2:	21 f4       	brne	.+8      	; 0x2ac <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2a4:	fc 01       	movw	r30, r24
     2a6:	a7 81       	ldd	r26, Z+7	; 0x07
     2a8:	b0 85       	ldd	r27, Z+8	; 0x08
     2aa:	0d c0       	rjmp	.+26     	; 0x2c6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ac:	dc 01       	movw	r26, r24
     2ae:	13 96       	adiw	r26, 0x03	; 3
     2b0:	01 c0       	rjmp	.+2      	; 0x2b4 <vListInsert+0x22>
     2b2:	df 01       	movw	r26, r30
     2b4:	12 96       	adiw	r26, 0x02	; 2
     2b6:	ed 91       	ld	r30, X+
     2b8:	fc 91       	ld	r31, X
     2ba:	13 97       	sbiw	r26, 0x03	; 3
     2bc:	20 81       	ld	r18, Z
     2be:	31 81       	ldd	r19, Z+1	; 0x01
     2c0:	42 17       	cp	r20, r18
     2c2:	53 07       	cpc	r21, r19
     2c4:	b0 f7       	brcc	.-20     	; 0x2b2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2c6:	12 96       	adiw	r26, 0x02	; 2
     2c8:	ed 91       	ld	r30, X+
     2ca:	fc 91       	ld	r31, X
     2cc:	13 97       	sbiw	r26, 0x03	; 3
     2ce:	fb 83       	std	Y+3, r31	; 0x03
     2d0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2d2:	d5 83       	std	Z+5, r29	; 0x05
     2d4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2d6:	bd 83       	std	Y+5, r27	; 0x05
     2d8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2da:	13 96       	adiw	r26, 0x03	; 3
     2dc:	dc 93       	st	X, r29
     2de:	ce 93       	st	-X, r28
     2e0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2e2:	99 87       	std	Y+9, r25	; 0x09
     2e4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2e6:	fc 01       	movw	r30, r24
     2e8:	20 81       	ld	r18, Z
     2ea:	2f 5f       	subi	r18, 0xFF	; 255
     2ec:	20 83       	st	Z, r18
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	08 95       	ret

000002f4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2f4:	cf 93       	push	r28
     2f6:	df 93       	push	r29
     2f8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2fa:	a0 85       	ldd	r26, Z+8	; 0x08
     2fc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2fe:	c2 81       	ldd	r28, Z+2	; 0x02
     300:	d3 81       	ldd	r29, Z+3	; 0x03
     302:	84 81       	ldd	r24, Z+4	; 0x04
     304:	95 81       	ldd	r25, Z+5	; 0x05
     306:	9d 83       	std	Y+5, r25	; 0x05
     308:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     30a:	c4 81       	ldd	r28, Z+4	; 0x04
     30c:	d5 81       	ldd	r29, Z+5	; 0x05
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	93 81       	ldd	r25, Z+3	; 0x03
     312:	9b 83       	std	Y+3, r25	; 0x03
     314:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     316:	11 96       	adiw	r26, 0x01	; 1
     318:	8d 91       	ld	r24, X+
     31a:	9c 91       	ld	r25, X
     31c:	12 97       	sbiw	r26, 0x02	; 2
     31e:	e8 17       	cp	r30, r24
     320:	f9 07       	cpc	r31, r25
     322:	31 f4       	brne	.+12     	; 0x330 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     324:	84 81       	ldd	r24, Z+4	; 0x04
     326:	95 81       	ldd	r25, Z+5	; 0x05
     328:	12 96       	adiw	r26, 0x02	; 2
     32a:	9c 93       	st	X, r25
     32c:	8e 93       	st	-X, r24
     32e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     330:	11 86       	std	Z+9, r1	; 0x09
     332:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     334:	8c 91       	ld	r24, X
     336:	81 50       	subi	r24, 0x01	; 1
     338:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     33a:	df 91       	pop	r29
     33c:	cf 91       	pop	r28
     33e:	08 95       	ret

00000340 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     340:	31 e1       	ldi	r19, 0x11	; 17
     342:	fc 01       	movw	r30, r24
     344:	30 83       	st	Z, r19
     346:	31 97       	sbiw	r30, 0x01	; 1
     348:	22 e2       	ldi	r18, 0x22	; 34
     34a:	20 83       	st	Z, r18
     34c:	31 97       	sbiw	r30, 0x01	; 1
     34e:	a3 e3       	ldi	r26, 0x33	; 51
     350:	a0 83       	st	Z, r26
     352:	31 97       	sbiw	r30, 0x01	; 1
     354:	60 83       	st	Z, r22
     356:	31 97       	sbiw	r30, 0x01	; 1
     358:	70 83       	st	Z, r23
     35a:	31 97       	sbiw	r30, 0x01	; 1
     35c:	10 82       	st	Z, r1
     35e:	31 97       	sbiw	r30, 0x01	; 1
     360:	60 e8       	ldi	r22, 0x80	; 128
     362:	60 83       	st	Z, r22
     364:	31 97       	sbiw	r30, 0x01	; 1
     366:	10 82       	st	Z, r1
     368:	31 97       	sbiw	r30, 0x01	; 1
     36a:	62 e0       	ldi	r22, 0x02	; 2
     36c:	60 83       	st	Z, r22
     36e:	31 97       	sbiw	r30, 0x01	; 1
     370:	63 e0       	ldi	r22, 0x03	; 3
     372:	60 83       	st	Z, r22
     374:	31 97       	sbiw	r30, 0x01	; 1
     376:	64 e0       	ldi	r22, 0x04	; 4
     378:	60 83       	st	Z, r22
     37a:	31 97       	sbiw	r30, 0x01	; 1
     37c:	65 e0       	ldi	r22, 0x05	; 5
     37e:	60 83       	st	Z, r22
     380:	31 97       	sbiw	r30, 0x01	; 1
     382:	66 e0       	ldi	r22, 0x06	; 6
     384:	60 83       	st	Z, r22
     386:	31 97       	sbiw	r30, 0x01	; 1
     388:	67 e0       	ldi	r22, 0x07	; 7
     38a:	60 83       	st	Z, r22
     38c:	31 97       	sbiw	r30, 0x01	; 1
     38e:	68 e0       	ldi	r22, 0x08	; 8
     390:	60 83       	st	Z, r22
     392:	31 97       	sbiw	r30, 0x01	; 1
     394:	69 e0       	ldi	r22, 0x09	; 9
     396:	60 83       	st	Z, r22
     398:	31 97       	sbiw	r30, 0x01	; 1
     39a:	60 e1       	ldi	r22, 0x10	; 16
     39c:	60 83       	st	Z, r22
     39e:	31 97       	sbiw	r30, 0x01	; 1
     3a0:	30 83       	st	Z, r19
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	32 e1       	ldi	r19, 0x12	; 18
     3a6:	30 83       	st	Z, r19
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	33 e1       	ldi	r19, 0x13	; 19
     3ac:	30 83       	st	Z, r19
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	34 e1       	ldi	r19, 0x14	; 20
     3b2:	30 83       	st	Z, r19
     3b4:	31 97       	sbiw	r30, 0x01	; 1
     3b6:	35 e1       	ldi	r19, 0x15	; 21
     3b8:	30 83       	st	Z, r19
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	36 e1       	ldi	r19, 0x16	; 22
     3be:	30 83       	st	Z, r19
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	37 e1       	ldi	r19, 0x17	; 23
     3c4:	30 83       	st	Z, r19
     3c6:	31 97       	sbiw	r30, 0x01	; 1
     3c8:	38 e1       	ldi	r19, 0x18	; 24
     3ca:	30 83       	st	Z, r19
     3cc:	31 97       	sbiw	r30, 0x01	; 1
     3ce:	39 e1       	ldi	r19, 0x19	; 25
     3d0:	30 83       	st	Z, r19
     3d2:	31 97       	sbiw	r30, 0x01	; 1
     3d4:	30 e2       	ldi	r19, 0x20	; 32
     3d6:	30 83       	st	Z, r19
     3d8:	31 97       	sbiw	r30, 0x01	; 1
     3da:	31 e2       	ldi	r19, 0x21	; 33
     3dc:	30 83       	st	Z, r19
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	20 83       	st	Z, r18
     3e2:	31 97       	sbiw	r30, 0x01	; 1
     3e4:	23 e2       	ldi	r18, 0x23	; 35
     3e6:	20 83       	st	Z, r18
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	40 83       	st	Z, r20
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	50 83       	st	Z, r21
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	26 e2       	ldi	r18, 0x26	; 38
     3f4:	20 83       	st	Z, r18
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	27 e2       	ldi	r18, 0x27	; 39
     3fa:	20 83       	st	Z, r18
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	28 e2       	ldi	r18, 0x28	; 40
     400:	20 83       	st	Z, r18
     402:	31 97       	sbiw	r30, 0x01	; 1
     404:	29 e2       	ldi	r18, 0x29	; 41
     406:	20 83       	st	Z, r18
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	20 e3       	ldi	r18, 0x30	; 48
     40c:	20 83       	st	Z, r18
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	21 e3       	ldi	r18, 0x31	; 49
     412:	20 83       	st	Z, r18
     414:	86 97       	sbiw	r24, 0x26	; 38
     416:	08 95       	ret

00000418 <xPortStartScheduler>:
     418:	1b bc       	out	0x2b, r1	; 43
     41a:	8c e7       	ldi	r24, 0x7C	; 124
     41c:	8a bd       	out	0x2a, r24	; 42
     41e:	8b e0       	ldi	r24, 0x0B	; 11
     420:	8e bd       	out	0x2e, r24	; 46
     422:	89 b7       	in	r24, 0x39	; 57
     424:	80 61       	ori	r24, 0x10	; 16
     426:	89 bf       	out	0x39, r24	; 57
     428:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
     42c:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     430:	cd 91       	ld	r28, X+
     432:	cd bf       	out	0x3d, r28	; 61
     434:	dd 91       	ld	r29, X+
     436:	de bf       	out	0x3e, r29	; 62
     438:	ff 91       	pop	r31
     43a:	ef 91       	pop	r30
     43c:	df 91       	pop	r29
     43e:	cf 91       	pop	r28
     440:	bf 91       	pop	r27
     442:	af 91       	pop	r26
     444:	9f 91       	pop	r25
     446:	8f 91       	pop	r24
     448:	7f 91       	pop	r23
     44a:	6f 91       	pop	r22
     44c:	5f 91       	pop	r21
     44e:	4f 91       	pop	r20
     450:	3f 91       	pop	r19
     452:	2f 91       	pop	r18
     454:	1f 91       	pop	r17
     456:	0f 91       	pop	r16
     458:	ff 90       	pop	r15
     45a:	ef 90       	pop	r14
     45c:	df 90       	pop	r13
     45e:	cf 90       	pop	r12
     460:	bf 90       	pop	r11
     462:	af 90       	pop	r10
     464:	9f 90       	pop	r9
     466:	8f 90       	pop	r8
     468:	7f 90       	pop	r7
     46a:	6f 90       	pop	r6
     46c:	5f 90       	pop	r5
     46e:	4f 90       	pop	r4
     470:	3f 90       	pop	r3
     472:	2f 90       	pop	r2
     474:	1f 90       	pop	r1
     476:	0f 90       	pop	r0
     478:	0f be       	out	0x3f, r0	; 63
     47a:	0f 90       	pop	r0
     47c:	08 95       	ret
     47e:	81 e0       	ldi	r24, 0x01	; 1
     480:	08 95       	ret

00000482 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     482:	0f 92       	push	r0
     484:	0f b6       	in	r0, 0x3f	; 63
     486:	f8 94       	cli
     488:	0f 92       	push	r0
     48a:	1f 92       	push	r1
     48c:	11 24       	eor	r1, r1
     48e:	2f 92       	push	r2
     490:	3f 92       	push	r3
     492:	4f 92       	push	r4
     494:	5f 92       	push	r5
     496:	6f 92       	push	r6
     498:	7f 92       	push	r7
     49a:	8f 92       	push	r8
     49c:	9f 92       	push	r9
     49e:	af 92       	push	r10
     4a0:	bf 92       	push	r11
     4a2:	cf 92       	push	r12
     4a4:	df 92       	push	r13
     4a6:	ef 92       	push	r14
     4a8:	ff 92       	push	r15
     4aa:	0f 93       	push	r16
     4ac:	1f 93       	push	r17
     4ae:	2f 93       	push	r18
     4b0:	3f 93       	push	r19
     4b2:	4f 93       	push	r20
     4b4:	5f 93       	push	r21
     4b6:	6f 93       	push	r22
     4b8:	7f 93       	push	r23
     4ba:	8f 93       	push	r24
     4bc:	9f 93       	push	r25
     4be:	af 93       	push	r26
     4c0:	bf 93       	push	r27
     4c2:	cf 93       	push	r28
     4c4:	df 93       	push	r29
     4c6:	ef 93       	push	r30
     4c8:	ff 93       	push	r31
     4ca:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
     4ce:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     4d2:	0d b6       	in	r0, 0x3d	; 61
     4d4:	0d 92       	st	X+, r0
     4d6:	0e b6       	in	r0, 0x3e	; 62
     4d8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4da:	0e 94 46 09 	call	0x128c	; 0x128c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4de:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
     4e2:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     4e6:	cd 91       	ld	r28, X+
     4e8:	cd bf       	out	0x3d, r28	; 61
     4ea:	dd 91       	ld	r29, X+
     4ec:	de bf       	out	0x3e, r29	; 62
     4ee:	ff 91       	pop	r31
     4f0:	ef 91       	pop	r30
     4f2:	df 91       	pop	r29
     4f4:	cf 91       	pop	r28
     4f6:	bf 91       	pop	r27
     4f8:	af 91       	pop	r26
     4fa:	9f 91       	pop	r25
     4fc:	8f 91       	pop	r24
     4fe:	7f 91       	pop	r23
     500:	6f 91       	pop	r22
     502:	5f 91       	pop	r21
     504:	4f 91       	pop	r20
     506:	3f 91       	pop	r19
     508:	2f 91       	pop	r18
     50a:	1f 91       	pop	r17
     50c:	0f 91       	pop	r16
     50e:	ff 90       	pop	r15
     510:	ef 90       	pop	r14
     512:	df 90       	pop	r13
     514:	cf 90       	pop	r12
     516:	bf 90       	pop	r11
     518:	af 90       	pop	r10
     51a:	9f 90       	pop	r9
     51c:	8f 90       	pop	r8
     51e:	7f 90       	pop	r7
     520:	6f 90       	pop	r6
     522:	5f 90       	pop	r5
     524:	4f 90       	pop	r4
     526:	3f 90       	pop	r3
     528:	2f 90       	pop	r2
     52a:	1f 90       	pop	r1
     52c:	0f 90       	pop	r0
     52e:	0f be       	out	0x3f, r0	; 63
     530:	0f 90       	pop	r0

	asm volatile ( "ret" );
     532:	08 95       	ret

00000534 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     534:	0f 92       	push	r0
     536:	0f b6       	in	r0, 0x3f	; 63
     538:	f8 94       	cli
     53a:	0f 92       	push	r0
     53c:	1f 92       	push	r1
     53e:	11 24       	eor	r1, r1
     540:	2f 92       	push	r2
     542:	3f 92       	push	r3
     544:	4f 92       	push	r4
     546:	5f 92       	push	r5
     548:	6f 92       	push	r6
     54a:	7f 92       	push	r7
     54c:	8f 92       	push	r8
     54e:	9f 92       	push	r9
     550:	af 92       	push	r10
     552:	bf 92       	push	r11
     554:	cf 92       	push	r12
     556:	df 92       	push	r13
     558:	ef 92       	push	r14
     55a:	ff 92       	push	r15
     55c:	0f 93       	push	r16
     55e:	1f 93       	push	r17
     560:	2f 93       	push	r18
     562:	3f 93       	push	r19
     564:	4f 93       	push	r20
     566:	5f 93       	push	r21
     568:	6f 93       	push	r22
     56a:	7f 93       	push	r23
     56c:	8f 93       	push	r24
     56e:	9f 93       	push	r25
     570:	af 93       	push	r26
     572:	bf 93       	push	r27
     574:	cf 93       	push	r28
     576:	df 93       	push	r29
     578:	ef 93       	push	r30
     57a:	ff 93       	push	r31
     57c:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
     580:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     584:	0d b6       	in	r0, 0x3d	; 61
     586:	0d 92       	st	X+, r0
     588:	0e b6       	in	r0, 0x3e	; 62
     58a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     58c:	0e 94 e7 07 	call	0xfce	; 0xfce <xTaskIncrementTick>
     590:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     592:	0e 94 46 09 	call	0x128c	; 0x128c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     596:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
     59a:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     59e:	cd 91       	ld	r28, X+
     5a0:	cd bf       	out	0x3d, r28	; 61
     5a2:	dd 91       	ld	r29, X+
     5a4:	de bf       	out	0x3e, r29	; 62
     5a6:	ff 91       	pop	r31
     5a8:	ef 91       	pop	r30
     5aa:	df 91       	pop	r29
     5ac:	cf 91       	pop	r28
     5ae:	bf 91       	pop	r27
     5b0:	af 91       	pop	r26
     5b2:	9f 91       	pop	r25
     5b4:	8f 91       	pop	r24
     5b6:	7f 91       	pop	r23
     5b8:	6f 91       	pop	r22
     5ba:	5f 91       	pop	r21
     5bc:	4f 91       	pop	r20
     5be:	3f 91       	pop	r19
     5c0:	2f 91       	pop	r18
     5c2:	1f 91       	pop	r17
     5c4:	0f 91       	pop	r16
     5c6:	ff 90       	pop	r15
     5c8:	ef 90       	pop	r14
     5ca:	df 90       	pop	r13
     5cc:	cf 90       	pop	r12
     5ce:	bf 90       	pop	r11
     5d0:	af 90       	pop	r10
     5d2:	9f 90       	pop	r9
     5d4:	8f 90       	pop	r8
     5d6:	7f 90       	pop	r7
     5d8:	6f 90       	pop	r6
     5da:	5f 90       	pop	r5
     5dc:	4f 90       	pop	r4
     5de:	3f 90       	pop	r3
     5e0:	2f 90       	pop	r2
     5e2:	1f 90       	pop	r1
     5e4:	0f 90       	pop	r0
     5e6:	0f be       	out	0x3f, r0	; 63
     5e8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5ea:	08 95       	ret

000005ec <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     5ec:	0e 94 9a 02 	call	0x534	; 0x534 <vPortYieldFromTick>
		asm volatile ( "reti" );
     5f0:	18 95       	reti

000005f2 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     5f2:	0f 93       	push	r16
     5f4:	1f 93       	push	r17
     5f6:	cf 93       	push	r28
     5f8:	df 93       	push	r29
     5fa:	ec 01       	movw	r28, r24
     5fc:	04 2f       	mov	r16, r20
     5fe:	1a 8d       	ldd	r17, Y+26	; 0x1a
     600:	4c 8d       	ldd	r20, Y+28	; 0x1c
     602:	41 11       	cpse	r20, r1
     604:	0c c0       	rjmp	.+24     	; 0x61e <prvCopyDataToQueue+0x2c>
     606:	88 81       	ld	r24, Y
     608:	99 81       	ldd	r25, Y+1	; 0x01
     60a:	89 2b       	or	r24, r25
     60c:	09 f0       	breq	.+2      	; 0x610 <prvCopyDataToQueue+0x1e>
     60e:	42 c0       	rjmp	.+132    	; 0x694 <prvCopyDataToQueue+0xa2>
     610:	8a 81       	ldd	r24, Y+2	; 0x02
     612:	9b 81       	ldd	r25, Y+3	; 0x03
     614:	0e 94 b0 0a 	call	0x1560	; 0x1560 <xTaskPriorityDisinherit>
     618:	1b 82       	std	Y+3, r1	; 0x03
     61a:	1a 82       	std	Y+2, r1	; 0x02
     61c:	42 c0       	rjmp	.+132    	; 0x6a2 <prvCopyDataToQueue+0xb0>
     61e:	01 11       	cpse	r16, r1
     620:	17 c0       	rjmp	.+46     	; 0x650 <prvCopyDataToQueue+0x5e>
     622:	50 e0       	ldi	r21, 0x00	; 0
     624:	8c 81       	ldd	r24, Y+4	; 0x04
     626:	9d 81       	ldd	r25, Y+5	; 0x05
     628:	0e 94 02 0b 	call	0x1604	; 0x1604 <memcpy>
     62c:	2c 8d       	ldd	r18, Y+28	; 0x1c
     62e:	8c 81       	ldd	r24, Y+4	; 0x04
     630:	9d 81       	ldd	r25, Y+5	; 0x05
     632:	82 0f       	add	r24, r18
     634:	91 1d       	adc	r25, r1
     636:	9d 83       	std	Y+5, r25	; 0x05
     638:	8c 83       	std	Y+4, r24	; 0x04
     63a:	2a 81       	ldd	r18, Y+2	; 0x02
     63c:	3b 81       	ldd	r19, Y+3	; 0x03
     63e:	82 17       	cp	r24, r18
     640:	93 07       	cpc	r25, r19
     642:	50 f1       	brcs	.+84     	; 0x698 <prvCopyDataToQueue+0xa6>
     644:	88 81       	ld	r24, Y
     646:	99 81       	ldd	r25, Y+1	; 0x01
     648:	9d 83       	std	Y+5, r25	; 0x05
     64a:	8c 83       	std	Y+4, r24	; 0x04
     64c:	80 e0       	ldi	r24, 0x00	; 0
     64e:	29 c0       	rjmp	.+82     	; 0x6a2 <prvCopyDataToQueue+0xb0>
     650:	50 e0       	ldi	r21, 0x00	; 0
     652:	8e 81       	ldd	r24, Y+6	; 0x06
     654:	9f 81       	ldd	r25, Y+7	; 0x07
     656:	0e 94 02 0b 	call	0x1604	; 0x1604 <memcpy>
     65a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	91 95       	neg	r25
     660:	81 95       	neg	r24
     662:	91 09       	sbc	r25, r1
     664:	2e 81       	ldd	r18, Y+6	; 0x06
     666:	3f 81       	ldd	r19, Y+7	; 0x07
     668:	28 0f       	add	r18, r24
     66a:	39 1f       	adc	r19, r25
     66c:	3f 83       	std	Y+7, r19	; 0x07
     66e:	2e 83       	std	Y+6, r18	; 0x06
     670:	48 81       	ld	r20, Y
     672:	59 81       	ldd	r21, Y+1	; 0x01
     674:	24 17       	cp	r18, r20
     676:	35 07       	cpc	r19, r21
     678:	30 f4       	brcc	.+12     	; 0x686 <prvCopyDataToQueue+0x94>
     67a:	2a 81       	ldd	r18, Y+2	; 0x02
     67c:	3b 81       	ldd	r19, Y+3	; 0x03
     67e:	82 0f       	add	r24, r18
     680:	93 1f       	adc	r25, r19
     682:	9f 83       	std	Y+7, r25	; 0x07
     684:	8e 83       	std	Y+6, r24	; 0x06
     686:	02 30       	cpi	r16, 0x02	; 2
     688:	49 f4       	brne	.+18     	; 0x69c <prvCopyDataToQueue+0xaa>
     68a:	11 23       	and	r17, r17
     68c:	49 f0       	breq	.+18     	; 0x6a0 <prvCopyDataToQueue+0xae>
     68e:	11 50       	subi	r17, 0x01	; 1
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	07 c0       	rjmp	.+14     	; 0x6a2 <prvCopyDataToQueue+0xb0>
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	05 c0       	rjmp	.+10     	; 0x6a2 <prvCopyDataToQueue+0xb0>
     698:	80 e0       	ldi	r24, 0x00	; 0
     69a:	03 c0       	rjmp	.+6      	; 0x6a2 <prvCopyDataToQueue+0xb0>
     69c:	80 e0       	ldi	r24, 0x00	; 0
     69e:	01 c0       	rjmp	.+2      	; 0x6a2 <prvCopyDataToQueue+0xb0>
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	1f 5f       	subi	r17, 0xFF	; 255
     6a4:	1a 8f       	std	Y+26, r17	; 0x1a
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	1f 91       	pop	r17
     6ac:	0f 91       	pop	r16
     6ae:	08 95       	ret

000006b0 <prvCopyDataFromQueue>:
     6b0:	fc 01       	movw	r30, r24
     6b2:	44 8d       	ldd	r20, Z+28	; 0x1c
     6b4:	44 23       	and	r20, r20
     6b6:	a9 f0       	breq	.+42     	; 0x6e2 <prvCopyDataFromQueue+0x32>
     6b8:	50 e0       	ldi	r21, 0x00	; 0
     6ba:	26 81       	ldd	r18, Z+6	; 0x06
     6bc:	37 81       	ldd	r19, Z+7	; 0x07
     6be:	24 0f       	add	r18, r20
     6c0:	35 1f       	adc	r19, r21
     6c2:	37 83       	std	Z+7, r19	; 0x07
     6c4:	26 83       	std	Z+6, r18	; 0x06
     6c6:	82 81       	ldd	r24, Z+2	; 0x02
     6c8:	93 81       	ldd	r25, Z+3	; 0x03
     6ca:	28 17       	cp	r18, r24
     6cc:	39 07       	cpc	r19, r25
     6ce:	20 f0       	brcs	.+8      	; 0x6d8 <prvCopyDataFromQueue+0x28>
     6d0:	80 81       	ld	r24, Z
     6d2:	91 81       	ldd	r25, Z+1	; 0x01
     6d4:	97 83       	std	Z+7, r25	; 0x07
     6d6:	86 83       	std	Z+6, r24	; 0x06
     6d8:	cb 01       	movw	r24, r22
     6da:	66 81       	ldd	r22, Z+6	; 0x06
     6dc:	77 81       	ldd	r23, Z+7	; 0x07
     6de:	0e 94 02 0b 	call	0x1604	; 0x1604 <memcpy>
     6e2:	08 95       	ret

000006e4 <prvUnlockQueue>:
     6e4:	ef 92       	push	r14
     6e6:	ff 92       	push	r15
     6e8:	0f 93       	push	r16
     6ea:	1f 93       	push	r17
     6ec:	cf 93       	push	r28
     6ee:	8c 01       	movw	r16, r24
     6f0:	0f b6       	in	r0, 0x3f	; 63
     6f2:	f8 94       	cli
     6f4:	0f 92       	push	r0
     6f6:	fc 01       	movw	r30, r24
     6f8:	c6 8d       	ldd	r28, Z+30	; 0x1e
     6fa:	1c 16       	cp	r1, r28
     6fc:	ac f4       	brge	.+42     	; 0x728 <prvUnlockQueue+0x44>
     6fe:	81 89       	ldd	r24, Z+17	; 0x11
     700:	81 11       	cpse	r24, r1
     702:	06 c0       	rjmp	.+12     	; 0x710 <prvUnlockQueue+0x2c>
     704:	11 c0       	rjmp	.+34     	; 0x728 <prvUnlockQueue+0x44>
     706:	f8 01       	movw	r30, r16
     708:	81 89       	ldd	r24, Z+17	; 0x11
     70a:	81 11       	cpse	r24, r1
     70c:	05 c0       	rjmp	.+10     	; 0x718 <prvUnlockQueue+0x34>
     70e:	0c c0       	rjmp	.+24     	; 0x728 <prvUnlockQueue+0x44>
     710:	78 01       	movw	r14, r16
     712:	f1 e1       	ldi	r31, 0x11	; 17
     714:	ef 0e       	add	r14, r31
     716:	f1 1c       	adc	r15, r1
     718:	c7 01       	movw	r24, r14
     71a:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     71e:	81 11       	cpse	r24, r1
     720:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vTaskMissedYield>
     724:	c1 50       	subi	r28, 0x01	; 1
     726:	79 f7       	brne	.-34     	; 0x706 <prvUnlockQueue+0x22>
     728:	8f ef       	ldi	r24, 0xFF	; 255
     72a:	f8 01       	movw	r30, r16
     72c:	86 8f       	std	Z+30, r24	; 0x1e
     72e:	0f 90       	pop	r0
     730:	0f be       	out	0x3f, r0	; 63
     732:	0f b6       	in	r0, 0x3f	; 63
     734:	f8 94       	cli
     736:	0f 92       	push	r0
     738:	c5 8d       	ldd	r28, Z+29	; 0x1d
     73a:	1c 16       	cp	r1, r28
     73c:	ac f4       	brge	.+42     	; 0x768 <prvUnlockQueue+0x84>
     73e:	80 85       	ldd	r24, Z+8	; 0x08
     740:	81 11       	cpse	r24, r1
     742:	06 c0       	rjmp	.+12     	; 0x750 <prvUnlockQueue+0x6c>
     744:	11 c0       	rjmp	.+34     	; 0x768 <prvUnlockQueue+0x84>
     746:	f8 01       	movw	r30, r16
     748:	80 85       	ldd	r24, Z+8	; 0x08
     74a:	81 11       	cpse	r24, r1
     74c:	05 c0       	rjmp	.+10     	; 0x758 <prvUnlockQueue+0x74>
     74e:	0c c0       	rjmp	.+24     	; 0x768 <prvUnlockQueue+0x84>
     750:	78 01       	movw	r14, r16
     752:	f8 e0       	ldi	r31, 0x08	; 8
     754:	ef 0e       	add	r14, r31
     756:	f1 1c       	adc	r15, r1
     758:	c7 01       	movw	r24, r14
     75a:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     75e:	81 11       	cpse	r24, r1
     760:	0e 94 4a 0a 	call	0x1494	; 0x1494 <vTaskMissedYield>
     764:	c1 50       	subi	r28, 0x01	; 1
     766:	79 f7       	brne	.-34     	; 0x746 <prvUnlockQueue+0x62>
     768:	8f ef       	ldi	r24, 0xFF	; 255
     76a:	f8 01       	movw	r30, r16
     76c:	85 8f       	std	Z+29, r24	; 0x1d
     76e:	0f 90       	pop	r0
     770:	0f be       	out	0x3f, r0	; 63
     772:	cf 91       	pop	r28
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	ff 90       	pop	r15
     77a:	ef 90       	pop	r14
     77c:	08 95       	ret

0000077e <xQueueGenericReset>:
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ec 01       	movw	r28, r24
     784:	0f b6       	in	r0, 0x3f	; 63
     786:	f8 94       	cli
     788:	0f 92       	push	r0
     78a:	48 81       	ld	r20, Y
     78c:	59 81       	ldd	r21, Y+1	; 0x01
     78e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     790:	30 e0       	ldi	r19, 0x00	; 0
     792:	7b 8d       	ldd	r23, Y+27	; 0x1b
     794:	72 9f       	mul	r23, r18
     796:	c0 01       	movw	r24, r0
     798:	73 9f       	mul	r23, r19
     79a:	90 0d       	add	r25, r0
     79c:	11 24       	eor	r1, r1
     79e:	fa 01       	movw	r30, r20
     7a0:	e8 0f       	add	r30, r24
     7a2:	f9 1f       	adc	r31, r25
     7a4:	fb 83       	std	Y+3, r31	; 0x03
     7a6:	ea 83       	std	Y+2, r30	; 0x02
     7a8:	1a 8e       	std	Y+26, r1	; 0x1a
     7aa:	5d 83       	std	Y+5, r21	; 0x05
     7ac:	4c 83       	std	Y+4, r20	; 0x04
     7ae:	82 1b       	sub	r24, r18
     7b0:	93 0b       	sbc	r25, r19
     7b2:	84 0f       	add	r24, r20
     7b4:	95 1f       	adc	r25, r21
     7b6:	9f 83       	std	Y+7, r25	; 0x07
     7b8:	8e 83       	std	Y+6, r24	; 0x06
     7ba:	8f ef       	ldi	r24, 0xFF	; 255
     7bc:	8d 8f       	std	Y+29, r24	; 0x1d
     7be:	8e 8f       	std	Y+30, r24	; 0x1e
     7c0:	61 11       	cpse	r22, r1
     7c2:	0c c0       	rjmp	.+24     	; 0x7dc <xQueueGenericReset+0x5e>
     7c4:	88 85       	ldd	r24, Y+8	; 0x08
     7c6:	88 23       	and	r24, r24
     7c8:	89 f0       	breq	.+34     	; 0x7ec <xQueueGenericReset+0x6e>
     7ca:	ce 01       	movw	r24, r28
     7cc:	08 96       	adiw	r24, 0x08	; 8
     7ce:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     7d2:	88 23       	and	r24, r24
     7d4:	59 f0       	breq	.+22     	; 0x7ec <xQueueGenericReset+0x6e>
     7d6:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     7da:	08 c0       	rjmp	.+16     	; 0x7ec <xQueueGenericReset+0x6e>
     7dc:	ce 01       	movw	r24, r28
     7de:	08 96       	adiw	r24, 0x08	; 8
     7e0:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     7e4:	ce 01       	movw	r24, r28
     7e6:	41 96       	adiw	r24, 0x11	; 17
     7e8:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     7ec:	0f 90       	pop	r0
     7ee:	0f be       	out	0x3f, r0	; 63
     7f0:	81 e0       	ldi	r24, 0x01	; 1
     7f2:	df 91       	pop	r29
     7f4:	cf 91       	pop	r28
     7f6:	08 95       	ret

000007f8 <xQueueGenericCreate>:
     7f8:	0f 93       	push	r16
     7fa:	1f 93       	push	r17
     7fc:	cf 93       	push	r28
     7fe:	df 93       	push	r29
     800:	08 2f       	mov	r16, r24
     802:	16 2f       	mov	r17, r22
     804:	66 23       	and	r22, r22
     806:	c1 f0       	breq	.+48     	; 0x838 <xQueueGenericCreate+0x40>
     808:	86 9f       	mul	r24, r22
     80a:	c0 01       	movw	r24, r0
     80c:	11 24       	eor	r1, r1
     80e:	4f 96       	adiw	r24, 0x1f	; 31
     810:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     814:	ec 01       	movw	r28, r24
     816:	00 97       	sbiw	r24, 0x00	; 0
     818:	41 f4       	brne	.+16     	; 0x82a <xQueueGenericCreate+0x32>
     81a:	15 c0       	rjmp	.+42     	; 0x846 <xQueueGenericCreate+0x4e>
     81c:	0b 8f       	std	Y+27, r16	; 0x1b
     81e:	1c 8f       	std	Y+28, r17	; 0x1c
     820:	61 e0       	ldi	r22, 0x01	; 1
     822:	ce 01       	movw	r24, r28
     824:	0e 94 bf 03 	call	0x77e	; 0x77e <xQueueGenericReset>
     828:	0e c0       	rjmp	.+28     	; 0x846 <xQueueGenericCreate+0x4e>
     82a:	4f 96       	adiw	r24, 0x1f	; 31
     82c:	99 83       	std	Y+1, r25	; 0x01
     82e:	88 83       	st	Y, r24
     830:	f5 cf       	rjmp	.-22     	; 0x81c <xQueueGenericCreate+0x24>
     832:	d9 83       	std	Y+1, r29	; 0x01
     834:	c8 83       	st	Y, r28
     836:	f2 cf       	rjmp	.-28     	; 0x81c <xQueueGenericCreate+0x24>
     838:	8f e1       	ldi	r24, 0x1F	; 31
     83a:	90 e0       	ldi	r25, 0x00	; 0
     83c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     840:	ec 01       	movw	r28, r24
     842:	89 2b       	or	r24, r25
     844:	b1 f7       	brne	.-20     	; 0x832 <xQueueGenericCreate+0x3a>
     846:	ce 01       	movw	r24, r28
     848:	df 91       	pop	r29
     84a:	cf 91       	pop	r28
     84c:	1f 91       	pop	r17
     84e:	0f 91       	pop	r16
     850:	08 95       	ret

00000852 <xQueueGenericSend>:
     852:	9f 92       	push	r9
     854:	af 92       	push	r10
     856:	bf 92       	push	r11
     858:	cf 92       	push	r12
     85a:	df 92       	push	r13
     85c:	ef 92       	push	r14
     85e:	ff 92       	push	r15
     860:	0f 93       	push	r16
     862:	1f 93       	push	r17
     864:	cf 93       	push	r28
     866:	df 93       	push	r29
     868:	00 d0       	rcall	.+0      	; 0x86a <__stack+0xb>
     86a:	00 d0       	rcall	.+0      	; 0x86c <__stack+0xd>
     86c:	1f 92       	push	r1
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	8c 01       	movw	r16, r24
     874:	6b 01       	movw	r12, r22
     876:	5d 83       	std	Y+5, r21	; 0x05
     878:	4c 83       	std	Y+4, r20	; 0x04
     87a:	a2 2e       	mov	r10, r18
     87c:	b1 2c       	mov	r11, r1
     87e:	99 24       	eor	r9, r9
     880:	93 94       	inc	r9
     882:	7c 01       	movw	r14, r24
     884:	88 e0       	ldi	r24, 0x08	; 8
     886:	e8 0e       	add	r14, r24
     888:	f1 1c       	adc	r15, r1
     88a:	0f b6       	in	r0, 0x3f	; 63
     88c:	f8 94       	cli
     88e:	0f 92       	push	r0
     890:	f8 01       	movw	r30, r16
     892:	92 8d       	ldd	r25, Z+26	; 0x1a
     894:	83 8d       	ldd	r24, Z+27	; 0x1b
     896:	98 17       	cp	r25, r24
     898:	18 f0       	brcs	.+6      	; 0x8a0 <__stack+0x41>
     89a:	f2 e0       	ldi	r31, 0x02	; 2
     89c:	af 12       	cpse	r10, r31
     89e:	19 c0       	rjmp	.+50     	; 0x8d2 <__stack+0x73>
     8a0:	4a 2d       	mov	r20, r10
     8a2:	b6 01       	movw	r22, r12
     8a4:	c8 01       	movw	r24, r16
     8a6:	0e 94 f9 02 	call	0x5f2	; 0x5f2 <prvCopyDataToQueue>
     8aa:	f8 01       	movw	r30, r16
     8ac:	91 89       	ldd	r25, Z+17	; 0x11
     8ae:	99 23       	and	r25, r25
     8b0:	49 f0       	breq	.+18     	; 0x8c4 <__stack+0x65>
     8b2:	c8 01       	movw	r24, r16
     8b4:	41 96       	adiw	r24, 0x11	; 17
     8b6:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     8ba:	88 23       	and	r24, r24
     8bc:	31 f0       	breq	.+12     	; 0x8ca <__stack+0x6b>
     8be:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     8c2:	03 c0       	rjmp	.+6      	; 0x8ca <__stack+0x6b>
     8c4:	81 11       	cpse	r24, r1
     8c6:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     8ca:	0f 90       	pop	r0
     8cc:	0f be       	out	0x3f, r0	; 63
     8ce:	81 e0       	ldi	r24, 0x01	; 1
     8d0:	50 c0       	rjmp	.+160    	; 0x972 <__stack+0x113>
     8d2:	8c 81       	ldd	r24, Y+4	; 0x04
     8d4:	9d 81       	ldd	r25, Y+5	; 0x05
     8d6:	89 2b       	or	r24, r25
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__stack+0x83>
     8da:	0f 90       	pop	r0
     8dc:	0f be       	out	0x3f, r0	; 63
     8de:	80 e0       	ldi	r24, 0x00	; 0
     8e0:	48 c0       	rjmp	.+144    	; 0x972 <__stack+0x113>
     8e2:	b1 10       	cpse	r11, r1
     8e4:	05 c0       	rjmp	.+10     	; 0x8f0 <__stack+0x91>
     8e6:	ce 01       	movw	r24, r28
     8e8:	01 96       	adiw	r24, 0x01	; 1
     8ea:	0e 94 06 0a 	call	0x140c	; 0x140c <vTaskSetTimeOutState>
     8ee:	b9 2c       	mov	r11, r9
     8f0:	0f 90       	pop	r0
     8f2:	0f be       	out	0x3f, r0	; 63
     8f4:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <vTaskSuspendAll>
     8f8:	0f b6       	in	r0, 0x3f	; 63
     8fa:	f8 94       	cli
     8fc:	0f 92       	push	r0
     8fe:	f8 01       	movw	r30, r16
     900:	85 8d       	ldd	r24, Z+29	; 0x1d
     902:	8f 3f       	cpi	r24, 0xFF	; 255
     904:	09 f4       	brne	.+2      	; 0x908 <__stack+0xa9>
     906:	15 8e       	std	Z+29, r1	; 0x1d
     908:	f8 01       	movw	r30, r16
     90a:	86 8d       	ldd	r24, Z+30	; 0x1e
     90c:	8f 3f       	cpi	r24, 0xFF	; 255
     90e:	09 f4       	brne	.+2      	; 0x912 <__stack+0xb3>
     910:	16 8e       	std	Z+30, r1	; 0x1e
     912:	0f 90       	pop	r0
     914:	0f be       	out	0x3f, r0	; 63
     916:	be 01       	movw	r22, r28
     918:	6c 5f       	subi	r22, 0xFC	; 252
     91a:	7f 4f       	sbci	r23, 0xFF	; 255
     91c:	ce 01       	movw	r24, r28
     91e:	01 96       	adiw	r24, 0x01	; 1
     920:	0e 94 11 0a 	call	0x1422	; 0x1422 <xTaskCheckForTimeOut>
     924:	81 11       	cpse	r24, r1
     926:	1f c0       	rjmp	.+62     	; 0x966 <__stack+0x107>
     928:	0f b6       	in	r0, 0x3f	; 63
     92a:	f8 94       	cli
     92c:	0f 92       	push	r0
     92e:	f8 01       	movw	r30, r16
     930:	92 8d       	ldd	r25, Z+26	; 0x1a
     932:	0f 90       	pop	r0
     934:	0f be       	out	0x3f, r0	; 63
     936:	83 8d       	ldd	r24, Z+27	; 0x1b
     938:	98 13       	cpse	r25, r24
     93a:	0f c0       	rjmp	.+30     	; 0x95a <__stack+0xfb>
     93c:	6c 81       	ldd	r22, Y+4	; 0x04
     93e:	7d 81       	ldd	r23, Y+5	; 0x05
     940:	c7 01       	movw	r24, r14
     942:	0e 94 ac 09 	call	0x1358	; 0x1358 <vTaskPlaceOnEventList>
     946:	c8 01       	movw	r24, r16
     948:	0e 94 72 03 	call	0x6e4	; 0x6e4 <prvUnlockQueue>
     94c:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
     950:	81 11       	cpse	r24, r1
     952:	9b cf       	rjmp	.-202    	; 0x88a <__stack+0x2b>
     954:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     958:	98 cf       	rjmp	.-208    	; 0x88a <__stack+0x2b>
     95a:	c8 01       	movw	r24, r16
     95c:	0e 94 72 03 	call	0x6e4	; 0x6e4 <prvUnlockQueue>
     960:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
     964:	92 cf       	rjmp	.-220    	; 0x88a <__stack+0x2b>
     966:	c8 01       	movw	r24, r16
     968:	0e 94 72 03 	call	0x6e4	; 0x6e4 <prvUnlockQueue>
     96c:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
     970:	80 e0       	ldi	r24, 0x00	; 0
     972:	0f 90       	pop	r0
     974:	0f 90       	pop	r0
     976:	0f 90       	pop	r0
     978:	0f 90       	pop	r0
     97a:	0f 90       	pop	r0
     97c:	df 91       	pop	r29
     97e:	cf 91       	pop	r28
     980:	1f 91       	pop	r17
     982:	0f 91       	pop	r16
     984:	ff 90       	pop	r15
     986:	ef 90       	pop	r14
     988:	df 90       	pop	r13
     98a:	cf 90       	pop	r12
     98c:	bf 90       	pop	r11
     98e:	af 90       	pop	r10
     990:	9f 90       	pop	r9
     992:	08 95       	ret

00000994 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     994:	cf 93       	push	r28
     996:	df 93       	push	r29
     998:	fc 01       	movw	r30, r24
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     99a:	82 8d       	ldd	r24, Z+26	; 0x1a

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
     99c:	93 8d       	ldd	r25, Z+27	; 0x1b
     99e:	89 17       	cp	r24, r25
     9a0:	c0 f4       	brcc	.+48     	; 0x9d2 <xQueueGiveFromISR+0x3e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
     9a2:	96 8d       	ldd	r25, Z+30	; 0x1e
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
     9a4:	8f 5f       	subi	r24, 0xFF	; 255
     9a6:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
     9a8:	9f 3f       	cpi	r25, 0xFF	; 255
     9aa:	79 f4       	brne	.+30     	; 0x9ca <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     9ac:	81 89       	ldd	r24, Z+17	; 0x11
     9ae:	88 23       	and	r24, r24
     9b0:	91 f0       	breq	.+36     	; 0x9d6 <xQueueGiveFromISR+0x42>
     9b2:	eb 01       	movw	r28, r22
     9b4:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     9b6:	41 96       	adiw	r24, 0x11	; 17
     9b8:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     9bc:	88 23       	and	r24, r24
     9be:	69 f0       	breq	.+26     	; 0x9da <xQueueGiveFromISR+0x46>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     9c0:	20 97       	sbiw	r28, 0x00	; 0
     9c2:	69 f0       	breq	.+26     	; 0x9de <xQueueGiveFromISR+0x4a>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     9c4:	81 e0       	ldi	r24, 0x01	; 1
     9c6:	88 83       	st	Y, r24
     9c8:	0b c0       	rjmp	.+22     	; 0x9e0 <xQueueGiveFromISR+0x4c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
     9ca:	9f 5f       	subi	r25, 0xFF	; 255
     9cc:	96 8f       	std	Z+30, r25	; 0x1e
			}

			xReturn = pdPASS;
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	07 c0       	rjmp	.+14     	; 0x9e0 <xQueueGiveFromISR+0x4c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     9d2:	80 e0       	ldi	r24, 0x00	; 0
     9d4:	05 c0       	rjmp	.+10     	; 0x9e0 <xQueueGiveFromISR+0x4c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
     9d6:	81 e0       	ldi	r24, 0x01	; 1
     9d8:	03 c0       	rjmp	.+6      	; 0x9e0 <xQueueGiveFromISR+0x4c>
     9da:	81 e0       	ldi	r24, 0x01	; 1
     9dc:	01 c0       	rjmp	.+2      	; 0x9e0 <xQueueGiveFromISR+0x4c>
     9de:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	08 95       	ret

000009e6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     9e6:	8f 92       	push	r8
     9e8:	9f 92       	push	r9
     9ea:	af 92       	push	r10
     9ec:	bf 92       	push	r11
     9ee:	cf 92       	push	r12
     9f0:	df 92       	push	r13
     9f2:	ef 92       	push	r14
     9f4:	ff 92       	push	r15
     9f6:	0f 93       	push	r16
     9f8:	1f 93       	push	r17
     9fa:	cf 93       	push	r28
     9fc:	df 93       	push	r29
     9fe:	00 d0       	rcall	.+0      	; 0xa00 <xQueueGenericReceive+0x1a>
     a00:	00 d0       	rcall	.+0      	; 0xa02 <xQueueGenericReceive+0x1c>
     a02:	1f 92       	push	r1
     a04:	cd b7       	in	r28, 0x3d	; 61
     a06:	de b7       	in	r29, 0x3e	; 62
     a08:	8c 01       	movw	r16, r24
     a0a:	5b 01       	movw	r10, r22
     a0c:	5d 83       	std	Y+5, r21	; 0x05
     a0e:	4c 83       	std	Y+4, r20	; 0x04
     a10:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a12:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a14:	99 24       	eor	r9, r9
     a16:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a18:	6c 01       	movw	r12, r24
     a1a:	81 e1       	ldi	r24, 0x11	; 17
     a1c:	c8 0e       	add	r12, r24
     a1e:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a20:	0f b6       	in	r0, 0x3f	; 63
     a22:	f8 94       	cli
     a24:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     a26:	f8 01       	movw	r30, r16
     a28:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     a2a:	ff 20       	and	r15, r15
     a2c:	91 f1       	breq	.+100    	; 0xa92 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a2e:	c6 80       	ldd	r12, Z+6	; 0x06
     a30:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a32:	b5 01       	movw	r22, r10
     a34:	c8 01       	movw	r24, r16
     a36:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     a3a:	81 10       	cpse	r8, r1
     a3c:	19 c0       	rjmp	.+50     	; 0xa70 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
     a3e:	fa 94       	dec	r15
     a40:	f8 01       	movw	r30, r16
     a42:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     a44:	80 81       	ld	r24, Z
     a46:	91 81       	ldd	r25, Z+1	; 0x01
     a48:	89 2b       	or	r24, r25
     a4a:	29 f4       	brne	.+10     	; 0xa56 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     a4c:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <pvTaskIncrementMutexHeldCount>
     a50:	f8 01       	movw	r30, r16
     a52:	93 83       	std	Z+3, r25	; 0x03
     a54:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a56:	f8 01       	movw	r30, r16
     a58:	80 85       	ldd	r24, Z+8	; 0x08
     a5a:	88 23       	and	r24, r24
     a5c:	b1 f0       	breq	.+44     	; 0xa8a <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     a5e:	c8 01       	movw	r24, r16
     a60:	08 96       	adiw	r24, 0x08	; 8
     a62:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     a66:	88 23       	and	r24, r24
     a68:	81 f0       	breq	.+32     	; 0xa8a <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     a6a:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     a6e:	0d c0       	rjmp	.+26     	; 0xa8a <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     a70:	f8 01       	movw	r30, r16
     a72:	d7 82       	std	Z+7, r13	; 0x07
     a74:	c6 82       	std	Z+6, r12	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a76:	81 89       	ldd	r24, Z+17	; 0x11
     a78:	88 23       	and	r24, r24
     a7a:	39 f0       	breq	.+14     	; 0xa8a <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a7c:	c8 01       	movw	r24, r16
     a7e:	41 96       	adiw	r24, 0x11	; 17
     a80:	0e 94 be 09 	call	0x137c	; 0x137c <xTaskRemoveFromEventList>
     a84:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     a86:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     a8a:	0f 90       	pop	r0
     a8c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     a8e:	81 e0       	ldi	r24, 0x01	; 1
     a90:	64 c0       	rjmp	.+200    	; 0xb5a <xQueueGenericReceive+0x174>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     a92:	8c 81       	ldd	r24, Y+4	; 0x04
     a94:	9d 81       	ldd	r25, Y+5	; 0x05
     a96:	89 2b       	or	r24, r25
     a98:	21 f4       	brne	.+8      	; 0xaa2 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a9a:	0f 90       	pop	r0
     a9c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     a9e:	80 e0       	ldi	r24, 0x00	; 0
     aa0:	5c c0       	rjmp	.+184    	; 0xb5a <xQueueGenericReceive+0x174>
				}
				else if( xEntryTimeSet == pdFALSE )
     aa2:	e1 10       	cpse	r14, r1
     aa4:	05 c0       	rjmp	.+10     	; 0xab0 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     aa6:	ce 01       	movw	r24, r28
     aa8:	01 96       	adiw	r24, 0x01	; 1
     aaa:	0e 94 06 0a 	call	0x140c	; 0x140c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     aae:	e9 2c       	mov	r14, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     ab0:	0f 90       	pop	r0
     ab2:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ab4:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ab8:	0f b6       	in	r0, 0x3f	; 63
     aba:	f8 94       	cli
     abc:	0f 92       	push	r0
     abe:	f8 01       	movw	r30, r16
     ac0:	85 8d       	ldd	r24, Z+29	; 0x1d
     ac2:	8f 3f       	cpi	r24, 0xFF	; 255
     ac4:	09 f4       	brne	.+2      	; 0xac8 <xQueueGenericReceive+0xe2>
     ac6:	15 8e       	std	Z+29, r1	; 0x1d
     ac8:	f8 01       	movw	r30, r16
     aca:	86 8d       	ldd	r24, Z+30	; 0x1e
     acc:	8f 3f       	cpi	r24, 0xFF	; 255
     ace:	09 f4       	brne	.+2      	; 0xad2 <xQueueGenericReceive+0xec>
     ad0:	16 8e       	std	Z+30, r1	; 0x1e
     ad2:	0f 90       	pop	r0
     ad4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ad6:	be 01       	movw	r22, r28
     ad8:	6c 5f       	subi	r22, 0xFC	; 252
     ada:	7f 4f       	sbci	r23, 0xFF	; 255
     adc:	ce 01       	movw	r24, r28
     ade:	01 96       	adiw	r24, 0x01	; 1
     ae0:	0e 94 11 0a 	call	0x1422	; 0x1422 <xTaskCheckForTimeOut>
     ae4:	81 11       	cpse	r24, r1
     ae6:	2b c0       	rjmp	.+86     	; 0xb3e <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     ae8:	0f b6       	in	r0, 0x3f	; 63
     aea:	f8 94       	cli
     aec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     aee:	f8 01       	movw	r30, r16
     af0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     af2:	0f 90       	pop	r0
     af4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     af6:	81 11       	cpse	r24, r1
     af8:	1c c0       	rjmp	.+56     	; 0xb32 <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     afa:	80 81       	ld	r24, Z
     afc:	91 81       	ldd	r25, Z+1	; 0x01
     afe:	89 2b       	or	r24, r25
     b00:	49 f4       	brne	.+18     	; 0xb14 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     b08:	82 81       	ldd	r24, Z+2	; 0x02
     b0a:	93 81       	ldd	r25, Z+3	; 0x03
     b0c:	0e 94 4e 0a 	call	0x149c	; 0x149c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     b10:	0f 90       	pop	r0
     b12:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b14:	6c 81       	ldd	r22, Y+4	; 0x04
     b16:	7d 81       	ldd	r23, Y+5	; 0x05
     b18:	c6 01       	movw	r24, r12
     b1a:	0e 94 ac 09 	call	0x1358	; 0x1358 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b1e:	c8 01       	movw	r24, r16
     b20:	0e 94 72 03 	call	0x6e4	; 0x6e4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b24:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
     b28:	81 11       	cpse	r24, r1
     b2a:	7a cf       	rjmp	.-268    	; 0xa20 <xQueueGenericReceive+0x3a>
				{
					portYIELD_WITHIN_API();
     b2c:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     b30:	77 cf       	rjmp	.-274    	; 0xa20 <xQueueGenericReceive+0x3a>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b32:	c8 01       	movw	r24, r16
     b34:	0e 94 72 03 	call	0x6e4	; 0x6e4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b38:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
     b3c:	71 cf       	rjmp	.-286    	; 0xa20 <xQueueGenericReceive+0x3a>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b3e:	c8 01       	movw	r24, r16
     b40:	0e 94 72 03 	call	0x6e4	; 0x6e4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b44:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b48:	0f b6       	in	r0, 0x3f	; 63
     b4a:	f8 94       	cli
     b4c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b4e:	f8 01       	movw	r30, r16
     b50:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b52:	0f 90       	pop	r0
     b54:	0f be       	out	0x3f, r0	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b56:	81 11       	cpse	r24, r1
     b58:	63 cf       	rjmp	.-314    	; 0xa20 <xQueueGenericReceive+0x3a>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
     b5a:	0f 90       	pop	r0
     b5c:	0f 90       	pop	r0
     b5e:	0f 90       	pop	r0
     b60:	0f 90       	pop	r0
     b62:	0f 90       	pop	r0
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	1f 91       	pop	r17
     b6a:	0f 91       	pop	r16
     b6c:	ff 90       	pop	r15
     b6e:	ef 90       	pop	r14
     b70:	df 90       	pop	r13
     b72:	cf 90       	pop	r12
     b74:	bf 90       	pop	r11
     b76:	af 90       	pop	r10
     b78:	9f 90       	pop	r9
     b7a:	8f 90       	pop	r8
     b7c:	08 95       	ret

00000b7e <task1>:
}

void task1(void *PV)
{
	char x;
	DDRD|=(1<<7);
     b7e:	8f 9a       	sbi	0x11, 7	; 17
	while(1)
	{
	x=xSemaphoreTake(my_sem,100);
     b80:	20 e0       	ldi	r18, 0x00	; 0
     b82:	44 e6       	ldi	r20, 0x64	; 100
     b84:	50 e0       	ldi	r21, 0x00	; 0
     b86:	60 e0       	ldi	r22, 0x00	; 0
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	80 91 02 04 	lds	r24, 0x0402	; 0x800402 <my_sem>
     b8e:	90 91 03 04 	lds	r25, 0x0403	; 0x800403 <my_sem+0x1>
     b92:	0e 94 f3 04 	call	0x9e6	; 0x9e6 <xQueueGenericReceive>
	if(x==1)
     b96:	81 30       	cpi	r24, 0x01	; 1
     b98:	99 f7       	brne	.-26     	; 0xb80 <task1+0x2>
		{
		PORTD^=(1<<7);
     b9a:	82 b3       	in	r24, 0x12	; 18
     b9c:	80 58       	subi	r24, 0x80	; 128
     b9e:	82 bb       	out	0x12, r24	; 18
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     ba0:	2f ef       	ldi	r18, 0xFF	; 255
     ba2:	89 e6       	ldi	r24, 0x69	; 105
     ba4:	98 e1       	ldi	r25, 0x18	; 24
     ba6:	21 50       	subi	r18, 0x01	; 1
     ba8:	80 40       	sbci	r24, 0x00	; 0
     baa:	90 40       	sbci	r25, 0x00	; 0
     bac:	e1 f7       	brne	.-8      	; 0xba6 <task1+0x28>
     bae:	00 c0       	rjmp	.+0      	; 0xbb0 <task1+0x32>
     bb0:	00 00       	nop
		_delay_ms(1000);
		xSemaphoreGive(my_sem);
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	40 e0       	ldi	r20, 0x00	; 0
     bb6:	50 e0       	ldi	r21, 0x00	; 0
     bb8:	60 e0       	ldi	r22, 0x00	; 0
     bba:	70 e0       	ldi	r23, 0x00	; 0
     bbc:	80 91 02 04 	lds	r24, 0x0402	; 0x800402 <my_sem>
     bc0:	90 91 03 04 	lds	r25, 0x0403	; 0x800403 <my_sem+0x1>
     bc4:	0e 94 29 04 	call	0x852	; 0x852 <xQueueGenericSend>
     bc8:	db cf       	rjmp	.-74     	; 0xb80 <task1+0x2>

00000bca <main>:

SemaphoreHandle_t my_sem ;
int main(void)
{
	
	xTaskCreate(task1,"M",100,NULL,1,NULL);
     bca:	e1 2c       	mov	r14, r1
     bcc:	f1 2c       	mov	r15, r1
     bce:	01 e0       	ldi	r16, 0x01	; 1
     bd0:	20 e0       	ldi	r18, 0x00	; 0
     bd2:	30 e0       	ldi	r19, 0x00	; 0
     bd4:	44 e6       	ldi	r20, 0x64	; 100
     bd6:	50 e0       	ldi	r21, 0x00	; 0
     bd8:	62 e6       	ldi	r22, 0x62	; 98
     bda:	70 e0       	ldi	r23, 0x00	; 0
     bdc:	8f eb       	ldi	r24, 0xBF	; 191
     bde:	95 e0       	ldi	r25, 0x05	; 5
     be0:	0e 94 a6 06 	call	0xd4c	; 0xd4c <xTaskCreate>
	sei();
     be4:	78 94       	sei
	GICR|=(1<<INT0);
     be6:	8b b7       	in	r24, 0x3b	; 59
     be8:	80 64       	ori	r24, 0x40	; 64
     bea:	8b bf       	out	0x3b, r24	; 59
	MCUCR|=(1<<ISC00)|(1<<ISC01);
     bec:	85 b7       	in	r24, 0x35	; 53
     bee:	83 60       	ori	r24, 0x03	; 3
     bf0:	85 bf       	out	0x35, r24	; 53
	my_sem=xSemaphoreCreateBinary();
     bf2:	43 e0       	ldi	r20, 0x03	; 3
     bf4:	60 e0       	ldi	r22, 0x00	; 0
     bf6:	81 e0       	ldi	r24, 0x01	; 1
     bf8:	0e 94 fc 03 	call	0x7f8	; 0x7f8 <xQueueGenericCreate>
     bfc:	90 93 03 04 	sts	0x0403, r25	; 0x800403 <my_sem+0x1>
     c00:	80 93 02 04 	sts	0x0402, r24	; 0x800402 <my_sem>
	vTaskStartScheduler();
     c04:	0e 94 b7 07 	call	0xf6e	; 0xf6e <vTaskStartScheduler>
     c08:	ff cf       	rjmp	.-2      	; 0xc08 <main+0x3e>

00000c0a <__vector_1>:
		}		
	}
}

ISR(INT0_vect)
{
     c0a:	1f 92       	push	r1
     c0c:	0f 92       	push	r0
     c0e:	0f b6       	in	r0, 0x3f	; 63
     c10:	0f 92       	push	r0
     c12:	11 24       	eor	r1, r1
     c14:	2f 93       	push	r18
     c16:	3f 93       	push	r19
     c18:	4f 93       	push	r20
     c1a:	5f 93       	push	r21
     c1c:	6f 93       	push	r22
     c1e:	7f 93       	push	r23
     c20:	8f 93       	push	r24
     c22:	9f 93       	push	r25
     c24:	af 93       	push	r26
     c26:	bf 93       	push	r27
     c28:	ef 93       	push	r30
     c2a:	ff 93       	push	r31
	xSemaphoreGiveFromISR(my_sem,NULL);
     c2c:	60 e0       	ldi	r22, 0x00	; 0
     c2e:	70 e0       	ldi	r23, 0x00	; 0
     c30:	80 91 02 04 	lds	r24, 0x0402	; 0x800402 <my_sem>
     c34:	90 91 03 04 	lds	r25, 0x0403	; 0x800403 <my_sem+0x1>
     c38:	0e 94 ca 04 	call	0x994	; 0x994 <xQueueGiveFromISR>
}
     c3c:	ff 91       	pop	r31
     c3e:	ef 91       	pop	r30
     c40:	bf 91       	pop	r27
     c42:	af 91       	pop	r26
     c44:	9f 91       	pop	r25
     c46:	8f 91       	pop	r24
     c48:	7f 91       	pop	r23
     c4a:	6f 91       	pop	r22
     c4c:	5f 91       	pop	r21
     c4e:	4f 91       	pop	r20
     c50:	3f 91       	pop	r19
     c52:	2f 91       	pop	r18
     c54:	0f 90       	pop	r0
     c56:	0f be       	out	0x3f, r0	; 63
     c58:	0f 90       	pop	r0
     c5a:	1f 90       	pop	r1
     c5c:	18 95       	reti

00000c5e <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     c5e:	e0 91 bf 03 	lds	r30, 0x03BF	; 0x8003bf <pxDelayedTaskList>
     c62:	f0 91 c0 03 	lds	r31, 0x03C0	; 0x8003c0 <pxDelayedTaskList+0x1>
     c66:	80 81       	ld	r24, Z
     c68:	81 11       	cpse	r24, r1
     c6a:	07 c0       	rjmp	.+14     	; 0xc7a <prvResetNextTaskUnblockTime+0x1c>
     c6c:	8f ef       	ldi	r24, 0xFF	; 255
     c6e:	9f ef       	ldi	r25, 0xFF	; 255
     c70:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <xNextTaskUnblockTime+0x1>
     c74:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <xNextTaskUnblockTime>
     c78:	08 95       	ret
     c7a:	e0 91 bf 03 	lds	r30, 0x03BF	; 0x8003bf <pxDelayedTaskList>
     c7e:	f0 91 c0 03 	lds	r31, 0x03C0	; 0x8003c0 <pxDelayedTaskList+0x1>
     c82:	05 80       	ldd	r0, Z+5	; 0x05
     c84:	f6 81       	ldd	r31, Z+6	; 0x06
     c86:	e0 2d       	mov	r30, r0
     c88:	06 80       	ldd	r0, Z+6	; 0x06
     c8a:	f7 81       	ldd	r31, Z+7	; 0x07
     c8c:	e0 2d       	mov	r30, r0
     c8e:	82 81       	ldd	r24, Z+2	; 0x02
     c90:	93 81       	ldd	r25, Z+3	; 0x03
     c92:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <xNextTaskUnblockTime+0x1>
     c96:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <xNextTaskUnblockTime>
     c9a:	08 95       	ret

00000c9c <prvAddCurrentTaskToDelayedList>:
     c9c:	ff 92       	push	r15
     c9e:	0f 93       	push	r16
     ca0:	1f 93       	push	r17
     ca2:	cf 93       	push	r28
     ca4:	df 93       	push	r29
     ca6:	ec 01       	movw	r28, r24
     ca8:	f6 2e       	mov	r15, r22
     caa:	00 91 9e 03 	lds	r16, 0x039E	; 0x80039e <xTickCount>
     cae:	10 91 9f 03 	lds	r17, 0x039F	; 0x80039f <xTickCount+0x1>
     cb2:	80 91 00 04 	lds	r24, 0x0400	; 0x800400 <pxCurrentTCB>
     cb6:	90 91 01 04 	lds	r25, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     cba:	02 96       	adiw	r24, 0x02	; 2
     cbc:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
     cc0:	cf 3f       	cpi	r28, 0xFF	; 255
     cc2:	8f ef       	ldi	r24, 0xFF	; 255
     cc4:	d8 07       	cpc	r29, r24
     cc6:	69 f4       	brne	.+26     	; 0xce2 <prvAddCurrentTaskToDelayedList+0x46>
     cc8:	ff 20       	and	r15, r15
     cca:	59 f0       	breq	.+22     	; 0xce2 <prvAddCurrentTaskToDelayedList+0x46>
     ccc:	60 91 00 04 	lds	r22, 0x0400	; 0x800400 <pxCurrentTCB>
     cd0:	70 91 01 04 	lds	r23, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     cd4:	6e 5f       	subi	r22, 0xFE	; 254
     cd6:	7f 4f       	sbci	r23, 0xFF	; 255
     cd8:	81 ea       	ldi	r24, 0xA1	; 161
     cda:	93 e0       	ldi	r25, 0x03	; 3
     cdc:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     ce0:	2f c0       	rjmp	.+94     	; 0xd40 <prvAddCurrentTaskToDelayedList+0xa4>
     ce2:	c0 0f       	add	r28, r16
     ce4:	d1 1f       	adc	r29, r17
     ce6:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
     cea:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     cee:	d3 83       	std	Z+3, r29	; 0x03
     cf0:	c2 83       	std	Z+2, r28	; 0x02
     cf2:	c0 17       	cp	r28, r16
     cf4:	d1 07       	cpc	r29, r17
     cf6:	68 f4       	brcc	.+26     	; 0xd12 <prvAddCurrentTaskToDelayedList+0x76>
     cf8:	60 91 00 04 	lds	r22, 0x0400	; 0x800400 <pxCurrentTCB>
     cfc:	70 91 01 04 	lds	r23, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     d00:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <pxOverflowDelayedTaskList>
     d04:	90 91 be 03 	lds	r25, 0x03BE	; 0x8003be <pxOverflowDelayedTaskList+0x1>
     d08:	6e 5f       	subi	r22, 0xFE	; 254
     d0a:	7f 4f       	sbci	r23, 0xFF	; 255
     d0c:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     d10:	17 c0       	rjmp	.+46     	; 0xd40 <prvAddCurrentTaskToDelayedList+0xa4>
     d12:	60 91 00 04 	lds	r22, 0x0400	; 0x800400 <pxCurrentTCB>
     d16:	70 91 01 04 	lds	r23, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     d1a:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <pxDelayedTaskList>
     d1e:	90 91 c0 03 	lds	r25, 0x03C0	; 0x8003c0 <pxDelayedTaskList+0x1>
     d22:	6e 5f       	subi	r22, 0xFE	; 254
     d24:	7f 4f       	sbci	r23, 0xFF	; 255
     d26:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
     d2a:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <xNextTaskUnblockTime>
     d2e:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <xNextTaskUnblockTime+0x1>
     d32:	c8 17       	cp	r28, r24
     d34:	d9 07       	cpc	r29, r25
     d36:	20 f4       	brcc	.+8      	; 0xd40 <prvAddCurrentTaskToDelayedList+0xa4>
     d38:	d0 93 97 03 	sts	0x0397, r29	; 0x800397 <xNextTaskUnblockTime+0x1>
     d3c:	c0 93 96 03 	sts	0x0396, r28	; 0x800396 <xNextTaskUnblockTime>
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	1f 91       	pop	r17
     d46:	0f 91       	pop	r16
     d48:	ff 90       	pop	r15
     d4a:	08 95       	ret

00000d4c <xTaskCreate>:
     d4c:	4f 92       	push	r4
     d4e:	5f 92       	push	r5
     d50:	6f 92       	push	r6
     d52:	7f 92       	push	r7
     d54:	8f 92       	push	r8
     d56:	9f 92       	push	r9
     d58:	af 92       	push	r10
     d5a:	bf 92       	push	r11
     d5c:	cf 92       	push	r12
     d5e:	df 92       	push	r13
     d60:	ef 92       	push	r14
     d62:	ff 92       	push	r15
     d64:	0f 93       	push	r16
     d66:	1f 93       	push	r17
     d68:	cf 93       	push	r28
     d6a:	df 93       	push	r29
     d6c:	4c 01       	movw	r8, r24
     d6e:	6b 01       	movw	r12, r22
     d70:	5a 01       	movw	r10, r20
     d72:	29 01       	movw	r4, r18
     d74:	ca 01       	movw	r24, r20
     d76:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d7a:	3c 01       	movw	r6, r24
     d7c:	89 2b       	or	r24, r25
     d7e:	09 f4       	brne	.+2      	; 0xd82 <xTaskCreate+0x36>
     d80:	e4 c0       	rjmp	.+456    	; 0xf4a <xTaskCreate+0x1fe>
     d82:	8a e2       	ldi	r24, 0x2A	; 42
     d84:	90 e0       	ldi	r25, 0x00	; 0
     d86:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     d8a:	ec 01       	movw	r28, r24
     d8c:	89 2b       	or	r24, r25
     d8e:	71 f0       	breq	.+28     	; 0xdac <xTaskCreate+0x60>
     d90:	78 8e       	std	Y+24, r7	; 0x18
     d92:	6f 8a       	std	Y+23, r6	; 0x17
     d94:	81 e0       	ldi	r24, 0x01	; 1
     d96:	a8 1a       	sub	r10, r24
     d98:	b1 08       	sbc	r11, r1
     d9a:	6a 0c       	add	r6, r10
     d9c:	7b 1c       	adc	r7, r11
     d9e:	d6 01       	movw	r26, r12
     da0:	8c 91       	ld	r24, X
     da2:	89 8f       	std	Y+25, r24	; 0x19
     da4:	8c 91       	ld	r24, X
     da6:	81 11       	cpse	r24, r1
     da8:	05 c0       	rjmp	.+10     	; 0xdb4 <xTaskCreate+0x68>
     daa:	18 c0       	rjmp	.+48     	; 0xddc <xTaskCreate+0x90>
     dac:	c3 01       	movw	r24, r6
     dae:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     db2:	cb c0       	rjmp	.+406    	; 0xf4a <xTaskCreate+0x1fe>
     db4:	ae 01       	movw	r20, r28
     db6:	46 5e       	subi	r20, 0xE6	; 230
     db8:	5f 4f       	sbci	r21, 0xFF	; 255
     dba:	f6 01       	movw	r30, r12
     dbc:	31 96       	adiw	r30, 0x01	; 1
     dbe:	ba e0       	ldi	r27, 0x0A	; 10
     dc0:	cb 0e       	add	r12, r27
     dc2:	d1 1c       	adc	r13, r1
     dc4:	cf 01       	movw	r24, r30
     dc6:	21 91       	ld	r18, Z+
     dc8:	da 01       	movw	r26, r20
     dca:	2d 93       	st	X+, r18
     dcc:	ad 01       	movw	r20, r26
     dce:	dc 01       	movw	r26, r24
     dd0:	8c 91       	ld	r24, X
     dd2:	88 23       	and	r24, r24
     dd4:	19 f0       	breq	.+6      	; 0xddc <xTaskCreate+0x90>
     dd6:	ce 16       	cp	r12, r30
     dd8:	df 06       	cpc	r13, r31
     dda:	a1 f7       	brne	.-24     	; 0xdc4 <xTaskCreate+0x78>
     ddc:	1a a2       	std	Y+34, r1	; 0x22
     dde:	05 30       	cpi	r16, 0x05	; 5
     de0:	08 f0       	brcs	.+2      	; 0xde4 <xTaskCreate+0x98>
     de2:	04 e0       	ldi	r16, 0x04	; 4
     de4:	0e 8b       	std	Y+22, r16	; 0x16
     de6:	0b a3       	std	Y+35, r16	; 0x23
     de8:	1c a2       	std	Y+36, r1	; 0x24
     dea:	6e 01       	movw	r12, r28
     dec:	b2 e0       	ldi	r27, 0x02	; 2
     dee:	cb 0e       	add	r12, r27
     df0:	d1 1c       	adc	r13, r1
     df2:	c6 01       	movw	r24, r12
     df4:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     df8:	ce 01       	movw	r24, r28
     dfa:	0c 96       	adiw	r24, 0x0c	; 12
     dfc:	0e 94 24 01 	call	0x248	; 0x248 <vListInitialiseItem>
     e00:	d9 87       	std	Y+9, r29	; 0x09
     e02:	c8 87       	std	Y+8, r28	; 0x08
     e04:	85 e0       	ldi	r24, 0x05	; 5
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	80 1b       	sub	r24, r16
     e0a:	91 09       	sbc	r25, r1
     e0c:	9d 87       	std	Y+13, r25	; 0x0d
     e0e:	8c 87       	std	Y+12, r24	; 0x0c
     e10:	db 8b       	std	Y+19, r29	; 0x13
     e12:	ca 8b       	std	Y+18, r28	; 0x12
     e14:	1d a2       	std	Y+37, r1	; 0x25
     e16:	1e a2       	std	Y+38, r1	; 0x26
     e18:	1f a2       	std	Y+39, r1	; 0x27
     e1a:	18 a6       	std	Y+40, r1	; 0x28
     e1c:	19 a6       	std	Y+41, r1	; 0x29
     e1e:	a2 01       	movw	r20, r4
     e20:	b4 01       	movw	r22, r8
     e22:	c3 01       	movw	r24, r6
     e24:	0e 94 a0 01 	call	0x340	; 0x340 <pxPortInitialiseStack>
     e28:	99 83       	std	Y+1, r25	; 0x01
     e2a:	88 83       	st	Y, r24
     e2c:	e1 14       	cp	r14, r1
     e2e:	f1 04       	cpc	r15, r1
     e30:	19 f0       	breq	.+6      	; 0xe38 <xTaskCreate+0xec>
     e32:	f7 01       	movw	r30, r14
     e34:	d1 83       	std	Z+1, r29	; 0x01
     e36:	c0 83       	st	Z, r28
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	0f 92       	push	r0
     e3e:	80 91 a0 03 	lds	r24, 0x03A0	; 0x8003a0 <uxCurrentNumberOfTasks>
     e42:	8f 5f       	subi	r24, 0xFF	; 255
     e44:	80 93 a0 03 	sts	0x03A0, r24	; 0x8003a0 <uxCurrentNumberOfTasks>
     e48:	80 91 00 04 	lds	r24, 0x0400	; 0x800400 <pxCurrentTCB>
     e4c:	90 91 01 04 	lds	r25, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     e50:	89 2b       	or	r24, r25
     e52:	d1 f5       	brne	.+116    	; 0xec8 <xTaskCreate+0x17c>
     e54:	d0 93 01 04 	sts	0x0401, r29	; 0x800401 <pxCurrentTCB+0x1>
     e58:	c0 93 00 04 	sts	0x0400, r28	; 0x800400 <pxCurrentTCB>
     e5c:	80 91 a0 03 	lds	r24, 0x03A0	; 0x8003a0 <uxCurrentNumberOfTasks>
     e60:	81 30       	cpi	r24, 0x01	; 1
     e62:	09 f0       	breq	.+2      	; 0xe66 <xTaskCreate+0x11a>
     e64:	41 c0       	rjmp	.+130    	; 0xee8 <xTaskCreate+0x19c>
     e66:	03 ed       	ldi	r16, 0xD3	; 211
     e68:	13 e0       	ldi	r17, 0x03	; 3
     e6a:	0f 2e       	mov	r0, r31
     e6c:	f0 e0       	ldi	r31, 0x00	; 0
     e6e:	ef 2e       	mov	r14, r31
     e70:	f4 e0       	ldi	r31, 0x04	; 4
     e72:	ff 2e       	mov	r15, r31
     e74:	f0 2d       	mov	r31, r0
     e76:	c8 01       	movw	r24, r16
     e78:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e7c:	07 5f       	subi	r16, 0xF7	; 247
     e7e:	1f 4f       	sbci	r17, 0xFF	; 255
     e80:	0e 15       	cp	r16, r14
     e82:	1f 05       	cpc	r17, r15
     e84:	c1 f7       	brne	.-16     	; 0xe76 <xTaskCreate+0x12a>
     e86:	8a ec       	ldi	r24, 0xCA	; 202
     e88:	93 e0       	ldi	r25, 0x03	; 3
     e8a:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e8e:	81 ec       	ldi	r24, 0xC1	; 193
     e90:	93 e0       	ldi	r25, 0x03	; 3
     e92:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e96:	84 eb       	ldi	r24, 0xB4	; 180
     e98:	93 e0       	ldi	r25, 0x03	; 3
     e9a:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     e9e:	8b ea       	ldi	r24, 0xAB	; 171
     ea0:	93 e0       	ldi	r25, 0x03	; 3
     ea2:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     ea6:	81 ea       	ldi	r24, 0xA1	; 161
     ea8:	93 e0       	ldi	r25, 0x03	; 3
     eaa:	0e 94 16 01 	call	0x22c	; 0x22c <vListInitialise>
     eae:	8a ec       	ldi	r24, 0xCA	; 202
     eb0:	93 e0       	ldi	r25, 0x03	; 3
     eb2:	90 93 c0 03 	sts	0x03C0, r25	; 0x8003c0 <pxDelayedTaskList+0x1>
     eb6:	80 93 bf 03 	sts	0x03BF, r24	; 0x8003bf <pxDelayedTaskList>
     eba:	81 ec       	ldi	r24, 0xC1	; 193
     ebc:	93 e0       	ldi	r25, 0x03	; 3
     ebe:	90 93 be 03 	sts	0x03BE, r25	; 0x8003be <pxOverflowDelayedTaskList+0x1>
     ec2:	80 93 bd 03 	sts	0x03BD, r24	; 0x8003bd <pxOverflowDelayedTaskList>
     ec6:	10 c0       	rjmp	.+32     	; 0xee8 <xTaskCreate+0x19c>
     ec8:	80 91 9c 03 	lds	r24, 0x039C	; 0x80039c <xSchedulerRunning>
     ecc:	81 11       	cpse	r24, r1
     ece:	0c c0       	rjmp	.+24     	; 0xee8 <xTaskCreate+0x19c>
     ed0:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
     ed4:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     ed8:	96 89       	ldd	r25, Z+22	; 0x16
     eda:	8e 89       	ldd	r24, Y+22	; 0x16
     edc:	89 17       	cp	r24, r25
     ede:	20 f0       	brcs	.+8      	; 0xee8 <xTaskCreate+0x19c>
     ee0:	d0 93 01 04 	sts	0x0401, r29	; 0x800401 <pxCurrentTCB+0x1>
     ee4:	c0 93 00 04 	sts	0x0400, r28	; 0x800400 <pxCurrentTCB>
     ee8:	80 91 98 03 	lds	r24, 0x0398	; 0x800398 <uxTaskNumber>
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	80 93 98 03 	sts	0x0398, r24	; 0x800398 <uxTaskNumber>
     ef2:	8e 89       	ldd	r24, Y+22	; 0x16
     ef4:	90 91 9d 03 	lds	r25, 0x039D	; 0x80039d <uxTopReadyPriority>
     ef8:	98 17       	cp	r25, r24
     efa:	10 f4       	brcc	.+4      	; 0xf00 <xTaskCreate+0x1b4>
     efc:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxTopReadyPriority>
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	9c 01       	movw	r18, r24
     f04:	22 0f       	add	r18, r18
     f06:	33 1f       	adc	r19, r19
     f08:	22 0f       	add	r18, r18
     f0a:	33 1f       	adc	r19, r19
     f0c:	22 0f       	add	r18, r18
     f0e:	33 1f       	adc	r19, r19
     f10:	82 0f       	add	r24, r18
     f12:	93 1f       	adc	r25, r19
     f14:	b6 01       	movw	r22, r12
     f16:	8d 52       	subi	r24, 0x2D	; 45
     f18:	9c 4f       	sbci	r25, 0xFC	; 252
     f1a:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
     f1e:	0f 90       	pop	r0
     f20:	0f be       	out	0x3f, r0	; 63
     f22:	80 91 9c 03 	lds	r24, 0x039C	; 0x80039c <xSchedulerRunning>
     f26:	88 23       	and	r24, r24
     f28:	61 f0       	breq	.+24     	; 0xf42 <xTaskCreate+0x1f6>
     f2a:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
     f2e:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
     f32:	96 89       	ldd	r25, Z+22	; 0x16
     f34:	8e 89       	ldd	r24, Y+22	; 0x16
     f36:	98 17       	cp	r25, r24
     f38:	30 f4       	brcc	.+12     	; 0xf46 <xTaskCreate+0x1fa>
     f3a:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	05 c0       	rjmp	.+10     	; 0xf4c <xTaskCreate+0x200>
     f42:	81 e0       	ldi	r24, 0x01	; 1
     f44:	03 c0       	rjmp	.+6      	; 0xf4c <xTaskCreate+0x200>
     f46:	81 e0       	ldi	r24, 0x01	; 1
     f48:	01 c0       	rjmp	.+2      	; 0xf4c <xTaskCreate+0x200>
     f4a:	8f ef       	ldi	r24, 0xFF	; 255
     f4c:	df 91       	pop	r29
     f4e:	cf 91       	pop	r28
     f50:	1f 91       	pop	r17
     f52:	0f 91       	pop	r16
     f54:	ff 90       	pop	r15
     f56:	ef 90       	pop	r14
     f58:	df 90       	pop	r13
     f5a:	cf 90       	pop	r12
     f5c:	bf 90       	pop	r11
     f5e:	af 90       	pop	r10
     f60:	9f 90       	pop	r9
     f62:	8f 90       	pop	r8
     f64:	7f 90       	pop	r7
     f66:	6f 90       	pop	r6
     f68:	5f 90       	pop	r5
     f6a:	4f 90       	pop	r4
     f6c:	08 95       	ret

00000f6e <vTaskStartScheduler>:
     f6e:	ef 92       	push	r14
     f70:	ff 92       	push	r15
     f72:	0f 93       	push	r16
     f74:	0f 2e       	mov	r0, r31
     f76:	f4 e9       	ldi	r31, 0x94	; 148
     f78:	ef 2e       	mov	r14, r31
     f7a:	f3 e0       	ldi	r31, 0x03	; 3
     f7c:	ff 2e       	mov	r15, r31
     f7e:	f0 2d       	mov	r31, r0
     f80:	00 e0       	ldi	r16, 0x00	; 0
     f82:	20 e0       	ldi	r18, 0x00	; 0
     f84:	30 e0       	ldi	r19, 0x00	; 0
     f86:	48 ec       	ldi	r20, 0xC8	; 200
     f88:	50 e0       	ldi	r21, 0x00	; 0
     f8a:	64 e6       	ldi	r22, 0x64	; 100
     f8c:	70 e0       	ldi	r23, 0x00	; 0
     f8e:	89 e0       	ldi	r24, 0x09	; 9
     f90:	99 e0       	ldi	r25, 0x09	; 9
     f92:	0e 94 a6 06 	call	0xd4c	; 0xd4c <xTaskCreate>
     f96:	81 30       	cpi	r24, 0x01	; 1
     f98:	81 f4       	brne	.+32     	; 0xfba <vTaskStartScheduler+0x4c>
     f9a:	f8 94       	cli
     f9c:	8f ef       	ldi	r24, 0xFF	; 255
     f9e:	9f ef       	ldi	r25, 0xFF	; 255
     fa0:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <xNextTaskUnblockTime+0x1>
     fa4:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <xNextTaskUnblockTime>
     fa8:	81 e0       	ldi	r24, 0x01	; 1
     faa:	80 93 9c 03 	sts	0x039C, r24	; 0x80039c <xSchedulerRunning>
     fae:	10 92 9f 03 	sts	0x039F, r1	; 0x80039f <xTickCount+0x1>
     fb2:	10 92 9e 03 	sts	0x039E, r1	; 0x80039e <xTickCount>
     fb6:	0e 94 0c 02 	call	0x418	; 0x418 <xPortStartScheduler>
     fba:	0f 91       	pop	r16
     fbc:	ff 90       	pop	r15
     fbe:	ef 90       	pop	r14
     fc0:	08 95       	ret

00000fc2 <vTaskSuspendAll>:
     fc2:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <uxSchedulerSuspended>
     fc6:	8f 5f       	subi	r24, 0xFF	; 255
     fc8:	80 93 93 03 	sts	0x0393, r24	; 0x800393 <uxSchedulerSuspended>
     fcc:	08 95       	ret

00000fce <xTaskIncrementTick>:
     fce:	cf 92       	push	r12
     fd0:	df 92       	push	r13
     fd2:	ef 92       	push	r14
     fd4:	ff 92       	push	r15
     fd6:	0f 93       	push	r16
     fd8:	1f 93       	push	r17
     fda:	cf 93       	push	r28
     fdc:	df 93       	push	r29
     fde:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <uxSchedulerSuspended>
     fe2:	81 11       	cpse	r24, r1
     fe4:	81 c0       	rjmp	.+258    	; 0x10e8 <xTaskIncrementTick+0x11a>
     fe6:	e0 90 9e 03 	lds	r14, 0x039E	; 0x80039e <xTickCount>
     fea:	f0 90 9f 03 	lds	r15, 0x039F	; 0x80039f <xTickCount+0x1>
     fee:	8f ef       	ldi	r24, 0xFF	; 255
     ff0:	e8 1a       	sub	r14, r24
     ff2:	f8 0a       	sbc	r15, r24
     ff4:	f0 92 9f 03 	sts	0x039F, r15	; 0x80039f <xTickCount+0x1>
     ff8:	e0 92 9e 03 	sts	0x039E, r14	; 0x80039e <xTickCount>
     ffc:	e1 14       	cp	r14, r1
     ffe:	f1 04       	cpc	r15, r1
    1000:	b9 f4       	brne	.+46     	; 0x1030 <xTaskIncrementTick+0x62>
    1002:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <pxDelayedTaskList>
    1006:	90 91 c0 03 	lds	r25, 0x03C0	; 0x8003c0 <pxDelayedTaskList+0x1>
    100a:	20 91 bd 03 	lds	r18, 0x03BD	; 0x8003bd <pxOverflowDelayedTaskList>
    100e:	30 91 be 03 	lds	r19, 0x03BE	; 0x8003be <pxOverflowDelayedTaskList+0x1>
    1012:	30 93 c0 03 	sts	0x03C0, r19	; 0x8003c0 <pxDelayedTaskList+0x1>
    1016:	20 93 bf 03 	sts	0x03BF, r18	; 0x8003bf <pxDelayedTaskList>
    101a:	90 93 be 03 	sts	0x03BE, r25	; 0x8003be <pxOverflowDelayedTaskList+0x1>
    101e:	80 93 bd 03 	sts	0x03BD, r24	; 0x8003bd <pxOverflowDelayedTaskList>
    1022:	80 91 99 03 	lds	r24, 0x0399	; 0x800399 <xNumOfOverflows>
    1026:	8f 5f       	subi	r24, 0xFF	; 255
    1028:	80 93 99 03 	sts	0x0399, r24	; 0x800399 <xNumOfOverflows>
    102c:	0e 94 2f 06 	call	0xc5e	; 0xc5e <prvResetNextTaskUnblockTime>
    1030:	80 91 96 03 	lds	r24, 0x0396	; 0x800396 <xNextTaskUnblockTime>
    1034:	90 91 97 03 	lds	r25, 0x0397	; 0x800397 <xNextTaskUnblockTime+0x1>
    1038:	e8 16       	cp	r14, r24
    103a:	f9 06       	cpc	r15, r25
    103c:	10 f4       	brcc	.+4      	; 0x1042 <xTaskIncrementTick+0x74>
    103e:	d1 2c       	mov	r13, r1
    1040:	59 c0       	rjmp	.+178    	; 0x10f4 <xTaskIncrementTick+0x126>
    1042:	d1 2c       	mov	r13, r1
    1044:	cc 24       	eor	r12, r12
    1046:	c3 94       	inc	r12
    1048:	e0 91 bf 03 	lds	r30, 0x03BF	; 0x8003bf <pxDelayedTaskList>
    104c:	f0 91 c0 03 	lds	r31, 0x03C0	; 0x8003c0 <pxDelayedTaskList+0x1>
    1050:	80 81       	ld	r24, Z
    1052:	81 11       	cpse	r24, r1
    1054:	07 c0       	rjmp	.+14     	; 0x1064 <xTaskIncrementTick+0x96>
    1056:	8f ef       	ldi	r24, 0xFF	; 255
    1058:	9f ef       	ldi	r25, 0xFF	; 255
    105a:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <xNextTaskUnblockTime+0x1>
    105e:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <xNextTaskUnblockTime>
    1062:	48 c0       	rjmp	.+144    	; 0x10f4 <xTaskIncrementTick+0x126>
    1064:	e0 91 bf 03 	lds	r30, 0x03BF	; 0x8003bf <pxDelayedTaskList>
    1068:	f0 91 c0 03 	lds	r31, 0x03C0	; 0x8003c0 <pxDelayedTaskList+0x1>
    106c:	05 80       	ldd	r0, Z+5	; 0x05
    106e:	f6 81       	ldd	r31, Z+6	; 0x06
    1070:	e0 2d       	mov	r30, r0
    1072:	c6 81       	ldd	r28, Z+6	; 0x06
    1074:	d7 81       	ldd	r29, Z+7	; 0x07
    1076:	8a 81       	ldd	r24, Y+2	; 0x02
    1078:	9b 81       	ldd	r25, Y+3	; 0x03
    107a:	e8 16       	cp	r14, r24
    107c:	f9 06       	cpc	r15, r25
    107e:	28 f4       	brcc	.+10     	; 0x108a <xTaskIncrementTick+0xbc>
    1080:	90 93 97 03 	sts	0x0397, r25	; 0x800397 <xNextTaskUnblockTime+0x1>
    1084:	80 93 96 03 	sts	0x0396, r24	; 0x800396 <xNextTaskUnblockTime>
    1088:	35 c0       	rjmp	.+106    	; 0x10f4 <xTaskIncrementTick+0x126>
    108a:	8e 01       	movw	r16, r28
    108c:	0e 5f       	subi	r16, 0xFE	; 254
    108e:	1f 4f       	sbci	r17, 0xFF	; 255
    1090:	c8 01       	movw	r24, r16
    1092:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1096:	8c 89       	ldd	r24, Y+20	; 0x14
    1098:	9d 89       	ldd	r25, Y+21	; 0x15
    109a:	89 2b       	or	r24, r25
    109c:	21 f0       	breq	.+8      	; 0x10a6 <xTaskIncrementTick+0xd8>
    109e:	ce 01       	movw	r24, r28
    10a0:	0c 96       	adiw	r24, 0x0c	; 12
    10a2:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    10a6:	8e 89       	ldd	r24, Y+22	; 0x16
    10a8:	90 91 9d 03 	lds	r25, 0x039D	; 0x80039d <uxTopReadyPriority>
    10ac:	98 17       	cp	r25, r24
    10ae:	10 f4       	brcc	.+4      	; 0x10b4 <xTaskIncrementTick+0xe6>
    10b0:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxTopReadyPriority>
    10b4:	90 e0       	ldi	r25, 0x00	; 0
    10b6:	9c 01       	movw	r18, r24
    10b8:	22 0f       	add	r18, r18
    10ba:	33 1f       	adc	r19, r19
    10bc:	22 0f       	add	r18, r18
    10be:	33 1f       	adc	r19, r19
    10c0:	22 0f       	add	r18, r18
    10c2:	33 1f       	adc	r19, r19
    10c4:	82 0f       	add	r24, r18
    10c6:	93 1f       	adc	r25, r19
    10c8:	b8 01       	movw	r22, r16
    10ca:	8d 52       	subi	r24, 0x2D	; 45
    10cc:	9c 4f       	sbci	r25, 0xFC	; 252
    10ce:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    10d2:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
    10d6:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    10da:	9e 89       	ldd	r25, Y+22	; 0x16
    10dc:	86 89       	ldd	r24, Z+22	; 0x16
    10de:	98 17       	cp	r25, r24
    10e0:	08 f4       	brcc	.+2      	; 0x10e4 <xTaskIncrementTick+0x116>
    10e2:	b2 cf       	rjmp	.-156    	; 0x1048 <xTaskIncrementTick+0x7a>
    10e4:	dc 2c       	mov	r13, r12
    10e6:	b0 cf       	rjmp	.-160    	; 0x1048 <xTaskIncrementTick+0x7a>
    10e8:	80 91 9b 03 	lds	r24, 0x039B	; 0x80039b <uxPendedTicks>
    10ec:	8f 5f       	subi	r24, 0xFF	; 255
    10ee:	80 93 9b 03 	sts	0x039B, r24	; 0x80039b <uxPendedTicks>
    10f2:	d1 2c       	mov	r13, r1
    10f4:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <xYieldPending>
    10f8:	88 23       	and	r24, r24
    10fa:	11 f0       	breq	.+4      	; 0x1100 <xTaskIncrementTick+0x132>
    10fc:	dd 24       	eor	r13, r13
    10fe:	d3 94       	inc	r13
    1100:	8d 2d       	mov	r24, r13
    1102:	df 91       	pop	r29
    1104:	cf 91       	pop	r28
    1106:	1f 91       	pop	r17
    1108:	0f 91       	pop	r16
    110a:	ff 90       	pop	r15
    110c:	ef 90       	pop	r14
    110e:	df 90       	pop	r13
    1110:	cf 90       	pop	r12
    1112:	08 95       	ret

00001114 <xTaskResumeAll>:
    1114:	df 92       	push	r13
    1116:	ef 92       	push	r14
    1118:	ff 92       	push	r15
    111a:	0f 93       	push	r16
    111c:	1f 93       	push	r17
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	0f b6       	in	r0, 0x3f	; 63
    1124:	f8 94       	cli
    1126:	0f 92       	push	r0
    1128:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <uxSchedulerSuspended>
    112c:	81 50       	subi	r24, 0x01	; 1
    112e:	80 93 93 03 	sts	0x0393, r24	; 0x800393 <uxSchedulerSuspended>
    1132:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <uxSchedulerSuspended>
    1136:	81 11       	cpse	r24, r1
    1138:	5f c0       	rjmp	.+190    	; 0x11f8 <xTaskResumeAll+0xe4>
    113a:	80 91 a0 03 	lds	r24, 0x03A0	; 0x8003a0 <uxCurrentNumberOfTasks>
    113e:	81 11       	cpse	r24, r1
    1140:	33 c0       	rjmp	.+102    	; 0x11a8 <xTaskResumeAll+0x94>
    1142:	5d c0       	rjmp	.+186    	; 0x11fe <xTaskResumeAll+0xea>
    1144:	d7 01       	movw	r26, r14
    1146:	15 96       	adiw	r26, 0x05	; 5
    1148:	ed 91       	ld	r30, X+
    114a:	fc 91       	ld	r31, X
    114c:	16 97       	sbiw	r26, 0x06	; 6
    114e:	c6 81       	ldd	r28, Z+6	; 0x06
    1150:	d7 81       	ldd	r29, Z+7	; 0x07
    1152:	ce 01       	movw	r24, r28
    1154:	0c 96       	adiw	r24, 0x0c	; 12
    1156:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    115a:	8e 01       	movw	r16, r28
    115c:	0e 5f       	subi	r16, 0xFE	; 254
    115e:	1f 4f       	sbci	r17, 0xFF	; 255
    1160:	c8 01       	movw	r24, r16
    1162:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1166:	8e 89       	ldd	r24, Y+22	; 0x16
    1168:	90 91 9d 03 	lds	r25, 0x039D	; 0x80039d <uxTopReadyPriority>
    116c:	98 17       	cp	r25, r24
    116e:	10 f4       	brcc	.+4      	; 0x1174 <xTaskResumeAll+0x60>
    1170:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxTopReadyPriority>
    1174:	90 e0       	ldi	r25, 0x00	; 0
    1176:	9c 01       	movw	r18, r24
    1178:	22 0f       	add	r18, r18
    117a:	33 1f       	adc	r19, r19
    117c:	22 0f       	add	r18, r18
    117e:	33 1f       	adc	r19, r19
    1180:	22 0f       	add	r18, r18
    1182:	33 1f       	adc	r19, r19
    1184:	82 0f       	add	r24, r18
    1186:	93 1f       	adc	r25, r19
    1188:	b8 01       	movw	r22, r16
    118a:	8d 52       	subi	r24, 0x2D	; 45
    118c:	9c 4f       	sbci	r25, 0xFC	; 252
    118e:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1192:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
    1196:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    119a:	9e 89       	ldd	r25, Y+22	; 0x16
    119c:	86 89       	ldd	r24, Z+22	; 0x16
    119e:	98 17       	cp	r25, r24
    11a0:	68 f0       	brcs	.+26     	; 0x11bc <xTaskResumeAll+0xa8>
    11a2:	d0 92 9a 03 	sts	0x039A, r13	; 0x80039a <xYieldPending>
    11a6:	0a c0       	rjmp	.+20     	; 0x11bc <xTaskResumeAll+0xa8>
    11a8:	c0 e0       	ldi	r28, 0x00	; 0
    11aa:	d0 e0       	ldi	r29, 0x00	; 0
    11ac:	0f 2e       	mov	r0, r31
    11ae:	f4 eb       	ldi	r31, 0xB4	; 180
    11b0:	ef 2e       	mov	r14, r31
    11b2:	f3 e0       	ldi	r31, 0x03	; 3
    11b4:	ff 2e       	mov	r15, r31
    11b6:	f0 2d       	mov	r31, r0
    11b8:	dd 24       	eor	r13, r13
    11ba:	d3 94       	inc	r13
    11bc:	f7 01       	movw	r30, r14
    11be:	80 81       	ld	r24, Z
    11c0:	81 11       	cpse	r24, r1
    11c2:	c0 cf       	rjmp	.-128    	; 0x1144 <xTaskResumeAll+0x30>
    11c4:	cd 2b       	or	r28, r29
    11c6:	11 f0       	breq	.+4      	; 0x11cc <xTaskResumeAll+0xb8>
    11c8:	0e 94 2f 06 	call	0xc5e	; 0xc5e <prvResetNextTaskUnblockTime>
    11cc:	c0 91 9b 03 	lds	r28, 0x039B	; 0x80039b <uxPendedTicks>
    11d0:	cc 23       	and	r28, r28
    11d2:	51 f0       	breq	.+20     	; 0x11e8 <xTaskResumeAll+0xd4>
    11d4:	d1 e0       	ldi	r29, 0x01	; 1
    11d6:	0e 94 e7 07 	call	0xfce	; 0xfce <xTaskIncrementTick>
    11da:	81 11       	cpse	r24, r1
    11dc:	d0 93 9a 03 	sts	0x039A, r29	; 0x80039a <xYieldPending>
    11e0:	c1 50       	subi	r28, 0x01	; 1
    11e2:	c9 f7       	brne	.-14     	; 0x11d6 <xTaskResumeAll+0xc2>
    11e4:	10 92 9b 03 	sts	0x039B, r1	; 0x80039b <uxPendedTicks>
    11e8:	80 91 9a 03 	lds	r24, 0x039A	; 0x80039a <xYieldPending>
    11ec:	88 23       	and	r24, r24
    11ee:	31 f0       	breq	.+12     	; 0x11fc <xTaskResumeAll+0xe8>
    11f0:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	03 c0       	rjmp	.+6      	; 0x11fe <xTaskResumeAll+0xea>
    11f8:	80 e0       	ldi	r24, 0x00	; 0
    11fa:	01 c0       	rjmp	.+2      	; 0x11fe <xTaskResumeAll+0xea>
    11fc:	80 e0       	ldi	r24, 0x00	; 0
    11fe:	0f 90       	pop	r0
    1200:	0f be       	out	0x3f, r0	; 63
    1202:	df 91       	pop	r29
    1204:	cf 91       	pop	r28
    1206:	1f 91       	pop	r17
    1208:	0f 91       	pop	r16
    120a:	ff 90       	pop	r15
    120c:	ef 90       	pop	r14
    120e:	df 90       	pop	r13
    1210:	08 95       	ret

00001212 <prvIdleTask>:
    1212:	0b ea       	ldi	r16, 0xAB	; 171
    1214:	13 e0       	ldi	r17, 0x03	; 3
    1216:	0f 2e       	mov	r0, r31
    1218:	f3 ed       	ldi	r31, 0xD3	; 211
    121a:	ef 2e       	mov	r14, r31
    121c:	f3 e0       	ldi	r31, 0x03	; 3
    121e:	ff 2e       	mov	r15, r31
    1220:	f0 2d       	mov	r31, r0
    1222:	29 c0       	rjmp	.+82     	; 0x1276 <prvIdleTask+0x64>
    1224:	0e 94 e1 07 	call	0xfc2	; 0xfc2 <vTaskSuspendAll>
    1228:	d8 01       	movw	r26, r16
    122a:	cc 91       	ld	r28, X
    122c:	0e 94 8a 08 	call	0x1114	; 0x1114 <xTaskResumeAll>
    1230:	cc 23       	and	r28, r28
    1232:	09 f1       	breq	.+66     	; 0x1276 <prvIdleTask+0x64>
    1234:	0f b6       	in	r0, 0x3f	; 63
    1236:	f8 94       	cli
    1238:	0f 92       	push	r0
    123a:	d8 01       	movw	r26, r16
    123c:	15 96       	adiw	r26, 0x05	; 5
    123e:	ed 91       	ld	r30, X+
    1240:	fc 91       	ld	r31, X
    1242:	16 97       	sbiw	r26, 0x06	; 6
    1244:	c6 81       	ldd	r28, Z+6	; 0x06
    1246:	d7 81       	ldd	r29, Z+7	; 0x07
    1248:	ce 01       	movw	r24, r28
    124a:	02 96       	adiw	r24, 0x02	; 2
    124c:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    1250:	80 91 a0 03 	lds	r24, 0x03A0	; 0x8003a0 <uxCurrentNumberOfTasks>
    1254:	81 50       	subi	r24, 0x01	; 1
    1256:	80 93 a0 03 	sts	0x03A0, r24	; 0x8003a0 <uxCurrentNumberOfTasks>
    125a:	80 91 aa 03 	lds	r24, 0x03AA	; 0x8003aa <uxDeletedTasksWaitingCleanUp>
    125e:	81 50       	subi	r24, 0x01	; 1
    1260:	80 93 aa 03 	sts	0x03AA, r24	; 0x8003aa <uxDeletedTasksWaitingCleanUp>
    1264:	0f 90       	pop	r0
    1266:	0f be       	out	0x3f, r0	; 63
    1268:	8f 89       	ldd	r24, Y+23	; 0x17
    126a:	98 8d       	ldd	r25, Y+24	; 0x18
    126c:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    1270:	ce 01       	movw	r24, r28
    1272:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    1276:	80 91 aa 03 	lds	r24, 0x03AA	; 0x8003aa <uxDeletedTasksWaitingCleanUp>
    127a:	81 11       	cpse	r24, r1
    127c:	d3 cf       	rjmp	.-90     	; 0x1224 <prvIdleTask+0x12>
    127e:	f7 01       	movw	r30, r14
    1280:	80 81       	ld	r24, Z
    1282:	82 30       	cpi	r24, 0x02	; 2
    1284:	c0 f3       	brcs	.-16     	; 0x1276 <prvIdleTask+0x64>
    1286:	0e 94 41 02 	call	0x482	; 0x482 <vPortYield>
    128a:	f5 cf       	rjmp	.-22     	; 0x1276 <prvIdleTask+0x64>

0000128c <vTaskSwitchContext>:
    128c:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <uxSchedulerSuspended>
    1290:	88 23       	and	r24, r24
    1292:	21 f0       	breq	.+8      	; 0x129c <vTaskSwitchContext+0x10>
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	80 93 9a 03 	sts	0x039A, r24	; 0x80039a <xYieldPending>
    129a:	08 95       	ret
    129c:	10 92 9a 03 	sts	0x039A, r1	; 0x80039a <xYieldPending>
    12a0:	20 91 9d 03 	lds	r18, 0x039D	; 0x80039d <uxTopReadyPriority>
    12a4:	82 2f       	mov	r24, r18
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	fc 01       	movw	r30, r24
    12aa:	ee 0f       	add	r30, r30
    12ac:	ff 1f       	adc	r31, r31
    12ae:	ee 0f       	add	r30, r30
    12b0:	ff 1f       	adc	r31, r31
    12b2:	ee 0f       	add	r30, r30
    12b4:	ff 1f       	adc	r31, r31
    12b6:	e8 0f       	add	r30, r24
    12b8:	f9 1f       	adc	r31, r25
    12ba:	ed 52       	subi	r30, 0x2D	; 45
    12bc:	fc 4f       	sbci	r31, 0xFC	; 252
    12be:	30 81       	ld	r19, Z
    12c0:	31 11       	cpse	r19, r1
    12c2:	11 c0       	rjmp	.+34     	; 0x12e6 <vTaskSwitchContext+0x5a>
    12c4:	21 50       	subi	r18, 0x01	; 1
    12c6:	82 2f       	mov	r24, r18
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	fc 01       	movw	r30, r24
    12cc:	ee 0f       	add	r30, r30
    12ce:	ff 1f       	adc	r31, r31
    12d0:	ee 0f       	add	r30, r30
    12d2:	ff 1f       	adc	r31, r31
    12d4:	ee 0f       	add	r30, r30
    12d6:	ff 1f       	adc	r31, r31
    12d8:	e8 0f       	add	r30, r24
    12da:	f9 1f       	adc	r31, r25
    12dc:	ed 52       	subi	r30, 0x2D	; 45
    12de:	fc 4f       	sbci	r31, 0xFC	; 252
    12e0:	30 81       	ld	r19, Z
    12e2:	33 23       	and	r19, r19
    12e4:	79 f3       	breq	.-34     	; 0x12c4 <vTaskSwitchContext+0x38>
    12e6:	ac 01       	movw	r20, r24
    12e8:	44 0f       	add	r20, r20
    12ea:	55 1f       	adc	r21, r21
    12ec:	44 0f       	add	r20, r20
    12ee:	55 1f       	adc	r21, r21
    12f0:	44 0f       	add	r20, r20
    12f2:	55 1f       	adc	r21, r21
    12f4:	48 0f       	add	r20, r24
    12f6:	59 1f       	adc	r21, r25
    12f8:	da 01       	movw	r26, r20
    12fa:	ad 52       	subi	r26, 0x2D	; 45
    12fc:	bc 4f       	sbci	r27, 0xFC	; 252
    12fe:	11 96       	adiw	r26, 0x01	; 1
    1300:	ed 91       	ld	r30, X+
    1302:	fc 91       	ld	r31, X
    1304:	12 97       	sbiw	r26, 0x02	; 2
    1306:	02 80       	ldd	r0, Z+2	; 0x02
    1308:	f3 81       	ldd	r31, Z+3	; 0x03
    130a:	e0 2d       	mov	r30, r0
    130c:	12 96       	adiw	r26, 0x02	; 2
    130e:	fc 93       	st	X, r31
    1310:	ee 93       	st	-X, r30
    1312:	11 97       	sbiw	r26, 0x01	; 1
    1314:	4a 52       	subi	r20, 0x2A	; 42
    1316:	5c 4f       	sbci	r21, 0xFC	; 252
    1318:	e4 17       	cp	r30, r20
    131a:	f5 07       	cpc	r31, r21
    131c:	29 f4       	brne	.+10     	; 0x1328 <vTaskSwitchContext+0x9c>
    131e:	42 81       	ldd	r20, Z+2	; 0x02
    1320:	53 81       	ldd	r21, Z+3	; 0x03
    1322:	fd 01       	movw	r30, r26
    1324:	52 83       	std	Z+2, r21	; 0x02
    1326:	41 83       	std	Z+1, r20	; 0x01
    1328:	fc 01       	movw	r30, r24
    132a:	ee 0f       	add	r30, r30
    132c:	ff 1f       	adc	r31, r31
    132e:	ee 0f       	add	r30, r30
    1330:	ff 1f       	adc	r31, r31
    1332:	ee 0f       	add	r30, r30
    1334:	ff 1f       	adc	r31, r31
    1336:	8e 0f       	add	r24, r30
    1338:	9f 1f       	adc	r25, r31
    133a:	fc 01       	movw	r30, r24
    133c:	ed 52       	subi	r30, 0x2D	; 45
    133e:	fc 4f       	sbci	r31, 0xFC	; 252
    1340:	01 80       	ldd	r0, Z+1	; 0x01
    1342:	f2 81       	ldd	r31, Z+2	; 0x02
    1344:	e0 2d       	mov	r30, r0
    1346:	86 81       	ldd	r24, Z+6	; 0x06
    1348:	97 81       	ldd	r25, Z+7	; 0x07
    134a:	90 93 01 04 	sts	0x0401, r25	; 0x800401 <pxCurrentTCB+0x1>
    134e:	80 93 00 04 	sts	0x0400, r24	; 0x800400 <pxCurrentTCB>
    1352:	20 93 9d 03 	sts	0x039D, r18	; 0x80039d <uxTopReadyPriority>
    1356:	08 95       	ret

00001358 <vTaskPlaceOnEventList>:
    1358:	cf 93       	push	r28
    135a:	df 93       	push	r29
    135c:	eb 01       	movw	r28, r22
    135e:	60 91 00 04 	lds	r22, 0x0400	; 0x800400 <pxCurrentTCB>
    1362:	70 91 01 04 	lds	r23, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    1366:	64 5f       	subi	r22, 0xF4	; 244
    1368:	7f 4f       	sbci	r23, 0xFF	; 255
    136a:	0e 94 49 01 	call	0x292	; 0x292 <vListInsert>
    136e:	61 e0       	ldi	r22, 0x01	; 1
    1370:	ce 01       	movw	r24, r28
    1372:	0e 94 4e 06 	call	0xc9c	; 0xc9c <prvAddCurrentTaskToDelayedList>
    1376:	df 91       	pop	r29
    1378:	cf 91       	pop	r28
    137a:	08 95       	ret

0000137c <xTaskRemoveFromEventList>:
    137c:	0f 93       	push	r16
    137e:	1f 93       	push	r17
    1380:	cf 93       	push	r28
    1382:	df 93       	push	r29
    1384:	dc 01       	movw	r26, r24
    1386:	15 96       	adiw	r26, 0x05	; 5
    1388:	ed 91       	ld	r30, X+
    138a:	fc 91       	ld	r31, X
    138c:	16 97       	sbiw	r26, 0x06	; 6
    138e:	c6 81       	ldd	r28, Z+6	; 0x06
    1390:	d7 81       	ldd	r29, Z+7	; 0x07
    1392:	8e 01       	movw	r16, r28
    1394:	04 5f       	subi	r16, 0xF4	; 244
    1396:	1f 4f       	sbci	r17, 0xFF	; 255
    1398:	c8 01       	movw	r24, r16
    139a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    139e:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <uxSchedulerSuspended>
    13a2:	81 11       	cpse	r24, r1
    13a4:	1c c0       	rjmp	.+56     	; 0x13de <xTaskRemoveFromEventList+0x62>
    13a6:	0a 50       	subi	r16, 0x0A	; 10
    13a8:	11 09       	sbc	r17, r1
    13aa:	c8 01       	movw	r24, r16
    13ac:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    13b0:	8e 89       	ldd	r24, Y+22	; 0x16
    13b2:	90 91 9d 03 	lds	r25, 0x039D	; 0x80039d <uxTopReadyPriority>
    13b6:	98 17       	cp	r25, r24
    13b8:	10 f4       	brcc	.+4      	; 0x13be <xTaskRemoveFromEventList+0x42>
    13ba:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxTopReadyPriority>
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	9c 01       	movw	r18, r24
    13c2:	22 0f       	add	r18, r18
    13c4:	33 1f       	adc	r19, r19
    13c6:	22 0f       	add	r18, r18
    13c8:	33 1f       	adc	r19, r19
    13ca:	22 0f       	add	r18, r18
    13cc:	33 1f       	adc	r19, r19
    13ce:	82 0f       	add	r24, r18
    13d0:	93 1f       	adc	r25, r19
    13d2:	b8 01       	movw	r22, r16
    13d4:	8d 52       	subi	r24, 0x2D	; 45
    13d6:	9c 4f       	sbci	r25, 0xFC	; 252
    13d8:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    13dc:	05 c0       	rjmp	.+10     	; 0x13e8 <xTaskRemoveFromEventList+0x6c>
    13de:	b8 01       	movw	r22, r16
    13e0:	84 eb       	ldi	r24, 0xB4	; 180
    13e2:	93 e0       	ldi	r25, 0x03	; 3
    13e4:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    13e8:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
    13ec:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    13f0:	9e 89       	ldd	r25, Y+22	; 0x16
    13f2:	86 89       	ldd	r24, Z+22	; 0x16
    13f4:	89 17       	cp	r24, r25
    13f6:	20 f4       	brcc	.+8      	; 0x1400 <xTaskRemoveFromEventList+0x84>
    13f8:	81 e0       	ldi	r24, 0x01	; 1
    13fa:	80 93 9a 03 	sts	0x039A, r24	; 0x80039a <xYieldPending>
    13fe:	01 c0       	rjmp	.+2      	; 0x1402 <xTaskRemoveFromEventList+0x86>
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	df 91       	pop	r29
    1404:	cf 91       	pop	r28
    1406:	1f 91       	pop	r17
    1408:	0f 91       	pop	r16
    140a:	08 95       	ret

0000140c <vTaskSetTimeOutState>:
    140c:	20 91 99 03 	lds	r18, 0x0399	; 0x800399 <xNumOfOverflows>
    1410:	fc 01       	movw	r30, r24
    1412:	20 83       	st	Z, r18
    1414:	20 91 9e 03 	lds	r18, 0x039E	; 0x80039e <xTickCount>
    1418:	30 91 9f 03 	lds	r19, 0x039F	; 0x80039f <xTickCount+0x1>
    141c:	32 83       	std	Z+2, r19	; 0x02
    141e:	21 83       	std	Z+1, r18	; 0x01
    1420:	08 95       	ret

00001422 <xTaskCheckForTimeOut>:
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	0f 92       	push	r0
    1428:	40 91 9e 03 	lds	r20, 0x039E	; 0x80039e <xTickCount>
    142c:	50 91 9f 03 	lds	r21, 0x039F	; 0x80039f <xTickCount+0x1>
    1430:	db 01       	movw	r26, r22
    1432:	2d 91       	ld	r18, X+
    1434:	3c 91       	ld	r19, X
    1436:	2f 3f       	cpi	r18, 0xFF	; 255
    1438:	bf ef       	ldi	r27, 0xFF	; 255
    143a:	3b 07       	cpc	r19, r27
    143c:	19 f1       	breq	.+70     	; 0x1484 <xTaskCheckForTimeOut+0x62>
    143e:	e0 91 99 03 	lds	r30, 0x0399	; 0x800399 <xNumOfOverflows>
    1442:	dc 01       	movw	r26, r24
    1444:	fc 91       	ld	r31, X
    1446:	fe 17       	cp	r31, r30
    1448:	39 f0       	breq	.+14     	; 0x1458 <xTaskCheckForTimeOut+0x36>
    144a:	11 96       	adiw	r26, 0x01	; 1
    144c:	ed 91       	ld	r30, X+
    144e:	fc 91       	ld	r31, X
    1450:	12 97       	sbiw	r26, 0x02	; 2
    1452:	4e 17       	cp	r20, r30
    1454:	5f 07       	cpc	r21, r31
    1456:	c0 f4       	brcc	.+48     	; 0x1488 <xTaskCheckForTimeOut+0x66>
    1458:	dc 01       	movw	r26, r24
    145a:	11 96       	adiw	r26, 0x01	; 1
    145c:	ed 91       	ld	r30, X+
    145e:	fc 91       	ld	r31, X
    1460:	12 97       	sbiw	r26, 0x02	; 2
    1462:	da 01       	movw	r26, r20
    1464:	ae 1b       	sub	r26, r30
    1466:	bf 0b       	sbc	r27, r31
    1468:	a2 17       	cp	r26, r18
    146a:	b3 07       	cpc	r27, r19
    146c:	78 f4       	brcc	.+30     	; 0x148c <xTaskCheckForTimeOut+0x6a>
    146e:	db 01       	movw	r26, r22
    1470:	e4 1b       	sub	r30, r20
    1472:	f5 0b       	sbc	r31, r21
    1474:	2e 0f       	add	r18, r30
    1476:	3f 1f       	adc	r19, r31
    1478:	2d 93       	st	X+, r18
    147a:	3c 93       	st	X, r19
    147c:	0e 94 06 0a 	call	0x140c	; 0x140c <vTaskSetTimeOutState>
    1480:	80 e0       	ldi	r24, 0x00	; 0
    1482:	05 c0       	rjmp	.+10     	; 0x148e <xTaskCheckForTimeOut+0x6c>
    1484:	80 e0       	ldi	r24, 0x00	; 0
    1486:	03 c0       	rjmp	.+6      	; 0x148e <xTaskCheckForTimeOut+0x6c>
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	01 c0       	rjmp	.+2      	; 0x148e <xTaskCheckForTimeOut+0x6c>
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	0f 90       	pop	r0
    1490:	0f be       	out	0x3f, r0	; 63
    1492:	08 95       	ret

00001494 <vTaskMissedYield>:
    1494:	81 e0       	ldi	r24, 0x01	; 1
    1496:	80 93 9a 03 	sts	0x039A, r24	; 0x80039a <xYieldPending>
    149a:	08 95       	ret

0000149c <vTaskPriorityInherit>:
    149c:	0f 93       	push	r16
    149e:	1f 93       	push	r17
    14a0:	cf 93       	push	r28
    14a2:	df 93       	push	r29
    14a4:	fc 01       	movw	r30, r24
    14a6:	89 2b       	or	r24, r25
    14a8:	09 f4       	brne	.+2      	; 0x14ac <vTaskPriorityInherit+0x10>
    14aa:	55 c0       	rjmp	.+170    	; 0x1556 <vTaskPriorityInherit+0xba>
    14ac:	26 89       	ldd	r18, Z+22	; 0x16
    14ae:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
    14b2:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    14b6:	56 96       	adiw	r26, 0x16	; 22
    14b8:	8c 91       	ld	r24, X
    14ba:	28 17       	cp	r18, r24
    14bc:	08 f0       	brcs	.+2      	; 0x14c0 <vTaskPriorityInherit+0x24>
    14be:	4b c0       	rjmp	.+150    	; 0x1556 <vTaskPriorityInherit+0xba>
    14c0:	84 85       	ldd	r24, Z+12	; 0x0c
    14c2:	95 85       	ldd	r25, Z+13	; 0x0d
    14c4:	99 23       	and	r25, r25
    14c6:	64 f0       	brlt	.+24     	; 0x14e0 <vTaskPriorityInherit+0x44>
    14c8:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
    14cc:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    14d0:	56 96       	adiw	r26, 0x16	; 22
    14d2:	3c 91       	ld	r19, X
    14d4:	85 e0       	ldi	r24, 0x05	; 5
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	83 1b       	sub	r24, r19
    14da:	91 09       	sbc	r25, r1
    14dc:	95 87       	std	Z+13, r25	; 0x0d
    14de:	84 87       	std	Z+12, r24	; 0x0c
    14e0:	30 e0       	ldi	r19, 0x00	; 0
    14e2:	c9 01       	movw	r24, r18
    14e4:	88 0f       	add	r24, r24
    14e6:	99 1f       	adc	r25, r25
    14e8:	88 0f       	add	r24, r24
    14ea:	99 1f       	adc	r25, r25
    14ec:	88 0f       	add	r24, r24
    14ee:	99 1f       	adc	r25, r25
    14f0:	28 0f       	add	r18, r24
    14f2:	39 1f       	adc	r19, r25
    14f4:	2d 52       	subi	r18, 0x2D	; 45
    14f6:	3c 4f       	sbci	r19, 0xFC	; 252
    14f8:	82 85       	ldd	r24, Z+10	; 0x0a
    14fa:	93 85       	ldd	r25, Z+11	; 0x0b
    14fc:	82 17       	cp	r24, r18
    14fe:	93 07       	cpc	r25, r19
    1500:	19 f5       	brne	.+70     	; 0x1548 <vTaskPriorityInherit+0xac>
    1502:	8f 01       	movw	r16, r30
    1504:	ef 01       	movw	r28, r30
    1506:	22 96       	adiw	r28, 0x02	; 2
    1508:	ce 01       	movw	r24, r28
    150a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    150e:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
    1512:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    1516:	86 89       	ldd	r24, Z+22	; 0x16
    1518:	f8 01       	movw	r30, r16
    151a:	86 8b       	std	Z+22, r24	; 0x16
    151c:	90 91 9d 03 	lds	r25, 0x039D	; 0x80039d <uxTopReadyPriority>
    1520:	98 17       	cp	r25, r24
    1522:	10 f4       	brcc	.+4      	; 0x1528 <vTaskPriorityInherit+0x8c>
    1524:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxTopReadyPriority>
    1528:	90 e0       	ldi	r25, 0x00	; 0
    152a:	9c 01       	movw	r18, r24
    152c:	22 0f       	add	r18, r18
    152e:	33 1f       	adc	r19, r19
    1530:	22 0f       	add	r18, r18
    1532:	33 1f       	adc	r19, r19
    1534:	22 0f       	add	r18, r18
    1536:	33 1f       	adc	r19, r19
    1538:	82 0f       	add	r24, r18
    153a:	93 1f       	adc	r25, r19
    153c:	be 01       	movw	r22, r28
    153e:	8d 52       	subi	r24, 0x2D	; 45
    1540:	9c 4f       	sbci	r25, 0xFC	; 252
    1542:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    1546:	07 c0       	rjmp	.+14     	; 0x1556 <vTaskPriorityInherit+0xba>
    1548:	a0 91 00 04 	lds	r26, 0x0400	; 0x800400 <pxCurrentTCB>
    154c:	b0 91 01 04 	lds	r27, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    1550:	56 96       	adiw	r26, 0x16	; 22
    1552:	8c 91       	ld	r24, X
    1554:	86 8b       	std	Z+22, r24	; 0x16
    1556:	df 91       	pop	r29
    1558:	cf 91       	pop	r28
    155a:	1f 91       	pop	r17
    155c:	0f 91       	pop	r16
    155e:	08 95       	ret

00001560 <xTaskPriorityDisinherit>:
    1560:	0f 93       	push	r16
    1562:	1f 93       	push	r17
    1564:	cf 93       	push	r28
    1566:	df 93       	push	r29
    1568:	fc 01       	movw	r30, r24
    156a:	89 2b       	or	r24, r25
    156c:	79 f1       	breq	.+94     	; 0x15cc <xTaskPriorityDisinherit+0x6c>
    156e:	84 a1       	ldd	r24, Z+36	; 0x24
    1570:	81 50       	subi	r24, 0x01	; 1
    1572:	84 a3       	std	Z+36, r24	; 0x24
    1574:	26 89       	ldd	r18, Z+22	; 0x16
    1576:	93 a1       	ldd	r25, Z+35	; 0x23
    1578:	29 17       	cp	r18, r25
    157a:	51 f1       	breq	.+84     	; 0x15d0 <xTaskPriorityDisinherit+0x70>
    157c:	81 11       	cpse	r24, r1
    157e:	2a c0       	rjmp	.+84     	; 0x15d4 <xTaskPriorityDisinherit+0x74>
    1580:	ef 01       	movw	r28, r30
    1582:	8f 01       	movw	r16, r30
    1584:	0e 5f       	subi	r16, 0xFE	; 254
    1586:	1f 4f       	sbci	r17, 0xFF	; 255
    1588:	c8 01       	movw	r24, r16
    158a:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <uxListRemove>
    158e:	8b a1       	ldd	r24, Y+35	; 0x23
    1590:	8e 8b       	std	Y+22, r24	; 0x16
    1592:	25 e0       	ldi	r18, 0x05	; 5
    1594:	30 e0       	ldi	r19, 0x00	; 0
    1596:	28 1b       	sub	r18, r24
    1598:	31 09       	sbc	r19, r1
    159a:	3d 87       	std	Y+13, r19	; 0x0d
    159c:	2c 87       	std	Y+12, r18	; 0x0c
    159e:	90 91 9d 03 	lds	r25, 0x039D	; 0x80039d <uxTopReadyPriority>
    15a2:	98 17       	cp	r25, r24
    15a4:	10 f4       	brcc	.+4      	; 0x15aa <xTaskPriorityDisinherit+0x4a>
    15a6:	80 93 9d 03 	sts	0x039D, r24	; 0x80039d <uxTopReadyPriority>
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	9c 01       	movw	r18, r24
    15ae:	22 0f       	add	r18, r18
    15b0:	33 1f       	adc	r19, r19
    15b2:	22 0f       	add	r18, r18
    15b4:	33 1f       	adc	r19, r19
    15b6:	22 0f       	add	r18, r18
    15b8:	33 1f       	adc	r19, r19
    15ba:	82 0f       	add	r24, r18
    15bc:	93 1f       	adc	r25, r19
    15be:	b8 01       	movw	r22, r16
    15c0:	8d 52       	subi	r24, 0x2D	; 45
    15c2:	9c 4f       	sbci	r25, 0xFC	; 252
    15c4:	0e 94 28 01 	call	0x250	; 0x250 <vListInsertEnd>
    15c8:	81 e0       	ldi	r24, 0x01	; 1
    15ca:	05 c0       	rjmp	.+10     	; 0x15d6 <xTaskPriorityDisinherit+0x76>
    15cc:	80 e0       	ldi	r24, 0x00	; 0
    15ce:	03 c0       	rjmp	.+6      	; 0x15d6 <xTaskPriorityDisinherit+0x76>
    15d0:	80 e0       	ldi	r24, 0x00	; 0
    15d2:	01 c0       	rjmp	.+2      	; 0x15d6 <xTaskPriorityDisinherit+0x76>
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	df 91       	pop	r29
    15d8:	cf 91       	pop	r28
    15da:	1f 91       	pop	r17
    15dc:	0f 91       	pop	r16
    15de:	08 95       	ret

000015e0 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    15e0:	80 91 00 04 	lds	r24, 0x0400	; 0x800400 <pxCurrentTCB>
    15e4:	90 91 01 04 	lds	r25, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    15e8:	89 2b       	or	r24, r25
    15ea:	39 f0       	breq	.+14     	; 0x15fa <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    15ec:	e0 91 00 04 	lds	r30, 0x0400	; 0x800400 <pxCurrentTCB>
    15f0:	f0 91 01 04 	lds	r31, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
    15f4:	84 a1       	ldd	r24, Z+36	; 0x24
    15f6:	8f 5f       	subi	r24, 0xFF	; 255
    15f8:	84 a3       	std	Z+36, r24	; 0x24
		}

		return pxCurrentTCB;
    15fa:	80 91 00 04 	lds	r24, 0x0400	; 0x800400 <pxCurrentTCB>
    15fe:	90 91 01 04 	lds	r25, 0x0401	; 0x800401 <pxCurrentTCB+0x1>
	}
    1602:	08 95       	ret

00001604 <memcpy>:
    1604:	fb 01       	movw	r30, r22
    1606:	dc 01       	movw	r26, r24
    1608:	02 c0       	rjmp	.+4      	; 0x160e <memcpy+0xa>
    160a:	01 90       	ld	r0, Z+
    160c:	0d 92       	st	X+, r0
    160e:	41 50       	subi	r20, 0x01	; 1
    1610:	50 40       	sbci	r21, 0x00	; 0
    1612:	d8 f7       	brcc	.-10     	; 0x160a <memcpy+0x6>
    1614:	08 95       	ret

00001616 <_exit>:
    1616:	f8 94       	cli

00001618 <__stop_program>:
    1618:	ff cf       	rjmp	.-2      	; 0x1618 <__stop_program>
